<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: os/signal</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>signal</b></span>

<span class="title">Import Path</span>
	<a href="../../index.html#pkg-os/signal">os/signal</a><i> (on <a href="https://golang.org/pkg/os/signal/" target="_blank">golang.org</a> and <a href="https://pkg.go.dev/os/signal" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../../dep/os/signal.html">4 packages</a>, and imported by <a href="../../dep/os/signal.html#imported-by">one package</a>

<div id="files"><span class="title">Involved Source Files</span>

	<input type='checkbox' checked class="fold" id="file-0-fold-content"><label for="file-0-fold-content">   <a href="../../src/os/signal/doc.go.html#doc">dâžœ</a> <a href="../../src/os/signal/doc.go.html">doc.go</a></label><span id='file-0-fold-content-items' class="fold-items">
		Package signal implements access to incoming signals.

		Signals are primarily used on Unix-like systems. For the use of this
		package on Windows and Plan 9, see below.

		Types of signals

		The signals SIGKILL and SIGSTOP may not be caught by a program, and
		therefore cannot be affected by this package.

		Synchronous signals are signals triggered by errors in program
		execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered
		synchronous when caused by program execution, not when sent using
		os.Process.Kill or the kill program or some similar mechanism. In
		general, except as discussed below, Go programs will convert a
		synchronous signal into a run-time panic.

		The remaining signals are asynchronous signals. They are not
		triggered by program errors, but are instead sent from the kernel or
		from some other program.

		Of the asynchronous signals, the SIGHUP signal is sent when a program
		loses its controlling terminal. The SIGINT signal is sent when the
		user at the controlling terminal presses the interrupt character,
		which by default is ^C (Control-C). The SIGQUIT signal is sent when
		the user at the controlling terminal presses the quit character, which
		by default is ^\ (Control-Backslash). In general you can cause a
		program to simply exit by pressing ^C, and you can cause it to exit
		with a stack dump by pressing ^\.

		Default behavior of signals in Go programs

		By default, a synchronous signal is converted into a run-time panic. A
		SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A
		SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal
		causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or
		SIGTTOU signal gets the system default behavior (these signals are
		used by the shell for job control). The SIGPROF signal is handled
		directly by the Go runtime to implement runtime.CPUProfile. Other
		signals will be caught but no action will be taken.

		If the Go program is started with either SIGHUP or SIGINT ignored
		(signal handler set to SIG_IGN), they will remain ignored.

		If the Go program is started with a non-empty signal mask, that will
		generally be honored. However, some signals are explicitly unblocked:
		the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF,
		and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID)
		(SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses
		started by os.Exec, or by the os/exec package, will inherit the
		modified signal mask.

		Changing the behavior of signals in Go programs

		The functions in this package allow a program to change the way Go
		programs handle signals.

		Notify disables the default behavior for a given set of asynchronous
		signals and instead delivers them over one or more registered
		channels. Specifically, it applies to the signals SIGHUP, SIGINT,
		SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control
		signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system
		default behavior does not occur. It also applies to some signals that
		otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM,
		SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH,
		SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE,
		SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals
		used on the system. Note that not all of these signals are available
		on all systems.

		If the program was started with SIGHUP or SIGINT ignored, and Notify
		is called for either signal, a signal handler will be installed for
		that signal and it will no longer be ignored. If, later, Reset or
		Ignore is called for that signal, or Stop is called on all channels
		passed to Notify for that signal, the signal will once again be
		ignored. Reset will restore the system default behavior for the
		signal, while Ignore will cause the system to ignore the signal
		entirely.

		If the program is started with a non-empty signal mask, some signals
		will be explicitly unblocked as described above. If Notify is called
		for a blocked signal, it will be unblocked. If, later, Reset is
		called for that signal, or Stop is called on all channels passed to
		Notify for that signal, the signal will once again be blocked.

		SIGPIPE

		When a Go program writes to a broken pipe, the kernel will raise a
		SIGPIPE signal.

		If the program has not called Notify to receive SIGPIPE signals, then
		the behavior depends on the file descriptor number. A write to a
		broken pipe on file descriptors 1 or 2 (standard output or standard
		error) will cause the program to exit with a SIGPIPE signal. A write
		to a broken pipe on some other file descriptor will take no action on
		the SIGPIPE signal, and the write will fail with an EPIPE error.

		If the program has called Notify to receive SIGPIPE signals, the file
		descriptor number does not matter. The SIGPIPE signal will be
		delivered to the Notify channel, and the write will fail with an EPIPE
		error.

		This means that, by default, command line programs will behave like
		typical Unix command line programs, while other programs will not
		crash with SIGPIPE when writing to a closed network connection.

		Go programs that use cgo or SWIG

		In a Go program that includes non-Go code, typically C/C++ code
		accessed using cgo or SWIG, Go's startup code normally runs first. It
		configures the signal handlers as expected by the Go runtime, before
		the non-Go startup code runs. If the non-Go startup code wishes to
		install its own signal handlers, it must take certain steps to keep Go
		working well. This section documents those steps and the overall
		effect changes to signal handler settings by the non-Go code can have
		on Go programs. In rare cases, the non-Go code may run before the Go
		code, in which case the next section also applies.

		If the non-Go code called by the Go program does not change any signal
		handlers or masks, then the behavior is the same as for a pure Go
		program.

		If the non-Go code installs any signal handlers, it must use the
		SA_ONSTACK flag with sigaction. Failing to do so is likely to cause
		the program to crash if the signal is received. Go programs routinely
		run with a limited stack, and therefore set up an alternate signal
		stack. Also, the Go standard library expects that any signal handlers
		will use the SA_RESTART flag. Failing to do so may cause some library
		calls to return "interrupted system call" errors.

		If the non-Go code installs a signal handler for any of the
		synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record
		the existing Go signal handler. If those signals occur while
		executing Go code, it should invoke the Go signal handler (whether the
		signal occurs while executing Go code can be determined by looking at
		the PC passed to the signal handler). Otherwise some Go run-time
		panics will not occur as expected.

		If the non-Go code installs a signal handler for any of the
		asynchronous signals, it may invoke the Go signal handler or not as it
		chooses. Naturally, if it does not invoke the Go signal handler, the
		Go behavior described above will not occur. This can be an issue with
		the SIGPROF signal in particular.

		The non-Go code should not change the signal mask on any threads
		created by the Go runtime. If the non-Go code starts new threads of
		its own, it may set the signal mask as it pleases.

		If the non-Go code starts a new thread, changes the signal mask, and
		then invokes a Go function in that thread, the Go runtime will
		automatically unblock certain signals: the synchronous signals,
		SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and
		SIGSETXID. When the Go function returns, the non-Go signal mask will
		be restored.

		If the Go signal handler is invoked on a non-Go thread not running Go
		code, the handler generally forwards the signal to the non-Go code, as
		follows. If the signal is SIGPROF, the Go handler does
		nothing. Otherwise, the Go handler removes itself, unblocks the
		signal, and raises it again, to invoke any non-Go handler or default
		system handler. If the program does not exit, the Go handler then
		reinstalls itself and continues execution of the program.

		Non-Go programs that call Go code

		When Go code is built with options like -buildmode=c-shared, it will
		be run as part of an existing non-Go program. The non-Go code may
		have already installed signal handlers when the Go code starts (that
		may also happen in unusual cases when using cgo or SWIG; in that case,
		the discussion here applies).  For -buildmode=c-archive the Go runtime
		will initialize signals at global constructor time.  For
		-buildmode=c-shared the Go runtime will initialize signals when the
		shared library is loaded.

		If the Go runtime sees an existing signal handler for the SIGCANCEL or
		SIGSETXID signals (which are used only on GNU/Linux), it will turn on
		the SA_ONSTACK flag and otherwise keep the signal handler.

		For the synchronous signals and SIGPIPE, the Go runtime will install a
		signal handler. It will save any existing signal handler. If a
		synchronous signal arrives while executing non-Go code, the Go runtime
		will invoke the existing signal handler instead of the Go signal
		handler.

		Go code built with -buildmode=c-archive or -buildmode=c-shared will
		not install any other signal handlers by default. If there is an
		existing signal handler, the Go runtime will turn on the SA_ONSTACK
		flag and otherwise keep the signal handler. If Notify is called for an
		asynchronous signal, a Go signal handler will be installed for that
		signal. If, later, Reset is called for that signal, the original
		handling for that signal will be reinstalled, restoring the non-Go
		signal handler if any.

		Go code built without -buildmode=c-archive or -buildmode=c-shared will
		install a signal handler for the asynchronous signals listed above,
		and save any existing signal handler. If a signal is delivered to a
		non-Go thread, it will act as described above, except that if there is
		an existing non-Go signal handler, that handler will be installed
		before raising the signal.

		Windows

		On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause
		the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK
		will cause os.Interrupt to be sent on the channel, and the program will
		not exit. If Reset is called, or Stop is called on all channels passed
		to Notify, then the default behavior will be restored.

		Additionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT,
		CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will
		return syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does
		not change process behavior when either CTRL_CLOSE_EVENT,
		CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT is received - the process will
		still get terminated unless it exits. But receiving syscall.SIGTERM will
		give the process an opportunity to clean up before termination.

		Plan 9

		On Plan 9, signals have type syscall.Note, which is a string. Calling
		Notify with a syscall.Note will cause that value to be sent on the
		channel when that string is posted as a note.
</span>
	<span class="nodocs">      <a href="../../src/os/signal/signal.go.html">signal.go</a></span>
	<span class="nodocs">      <a href="../../src/os/signal/signal_unix.go.html">signal_unix.go</a></span>
	<span class="nodocs">      <a href="../../src/os/signal/sig.s.html">sig.s</a></span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content">Notify</label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"os"
			"os/signal"
		)
		
		func main() {
			// Set up channel on which to send signal notifications.
			// We must use a buffered channel or risk missing the signal
			// if we're not ready to receive when the signal is sent.
			c := make(chan os.Signal, 1)
			signal.Notify(c, os.Interrupt)
		
			// Block until a signal is received.
			s := <-c
			fmt.Println("Got signal:", s)
		}

</span>
	<input type='checkbox' class="fold" id="example-1-fold-content"><label for="example-1-fold-content">NotifyContext</label><span id='example-1-fold-content-items' class="fold-items">
		package main
		
		import (
			"context"
			"fmt"
			"log"
			"os"
			"os/signal"
			"time"
		)
		
		func main() {
			ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
			defer stop()
		
			p, err := os.FindProcess(os.Getpid())
			if err != nil {
				log.Fatal(err)
			}
		
			// On a Unix-like system, pressing Ctrl+C on a keyboard sends a
			// SIGINT signal to the process of the program in execution.
			//
			// This example simulates that by sending a SIGINT signal to itself.
			if err := p.Signal(os.Interrupt); err != nil {
				log.Fatal(err)
			}
		
			select {
			case <-time.After(time.Second):
				fmt.Println("missed signal")
			case <-ctx.Done():
				fmt.Println(ctx.Err()) // prints "context canceled"
				stop()                 // stop receiving signal notifications as soon as possible.
			}
		
		}

</span>
	<input type='checkbox' class="fold" id="example-2-fold-content"><label for="example-2-fold-content">Notify_allSignals</label><span id='example-2-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"os"
			"os/signal"
		)
		
		func main() {
			// Set up channel on which to send signal notifications.
			// We must use a buffered channel or risk missing the signal
			// if we're not ready to receive when the signal is sent.
			c := make(chan os.Signal, 1)
		
			// Passing no signals to Notify means that
			// all signals will be sent to the channel.
			signal.Notify(c)
		
			// Block until any signal is received.
			s := <-c
			fmt.Println("Got signal:", s)
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (total 4, none are exported)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort exporteds by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div></div><div>	<input type='checkbox' class="showhide" id="unexported-typenames-showhide"><i><label for="unexported-typenames-showhide" class="show-inline">/* 4 unexporteds ... */</label><label for="unexported-typenames-showhide" class="hide-inline">/* 4 unexporteds: */</label></i><div class="anchor type-res hidden" id="name-handler" data-popularity="150">	<input type='checkbox' class="fold" id="handler-fold-content"><label for="handler-fold-content"> type <a href="../../src/os/signal/signal.go.html#line-32">handler</a> <i>(struct)</i></label><span id='handler-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="handler-fold-fields"><label for="handler-fold-fields">Fields (<i>only one, which is unexported</i>)</label><span id='handler-fold-fields-items' class="fold-items">
			<input type='checkbox' checked class="showhide" id="handler-showhide-fields"><i><label for="handler-showhide-fields" class="show-inline">/* one unexported ... */</label><label for="handler-showhide-fields" class="hide-inline">/* one unexported: */</label></i><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-33">mask</a> <i>[3]<a href="../builtin.html#name-uint32">uint32</a></i></span></i></span></span>
		<input type='checkbox' class="fold" id="handler-fold-methods"><label for="handler-fold-methods">Methods (<i>total 3, none are exported</i>)</label><span id='handler-fold-methods-items' class="fold-items">
			<input type='checkbox' checked class="showhide" id="handler-showhide-methods"><i><label for="handler-showhide-methods" class="show-inline">/* 3 unexporteds ... */</label><label for="handler-showhide-methods" class="hide-inline">/* 3 unexporteds: */</label></i><span class="hidden"><i>
			<span class="nodocs">(*T) <a href="../../src/os/signal/signal.go.html#line-44">clear</a>(sig <a href="../builtin.html#name-int">int</a>)</span></i></span><span class="hidden"><i>
			<span class="nodocs">(*T) <a href="../../src/os/signal/signal.go.html#line-40">set</a>(sig <a href="../builtin.html#name-int">int</a>)</span></i></span><span class="hidden"><i>
			<span class="nodocs">(*T) <a href="../../src/os/signal/signal.go.html#line-36">want</a>(sig <a href="../builtin.html#name-int">int</a>) <a href="../builtin.html#name-bool">bool</a></span></i></span></span>

</span></div><div class="anchor type-res hidden" id="name-signalCtx" data-popularity="550">	<input type='checkbox' class="fold" id="signalCtx-fold-content"><label for="signalCtx-fold-content"> type <a href="../../src/os/signal/signal.go.html#line-298">signalCtx</a> <i>(struct)</i></label><span id='signalCtx-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="signalCtx-fold-fields"><label for="signalCtx-fold-fields">Fields (<i>total 4, in which 1 are exported</i>)</label><span id='signalCtx-fold-fields-items' class="fold-items"><span>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-299">Context</a> <i><a href="../context.html">context</a>.<a href="../context.html#name-Context">Context</a></i></span></span>
			<input type='checkbox' checked class="showhide" id="signalCtx-showhide-fields"><i><label for="signalCtx-showhide-fields" class="show-inline">/* 3 unexporteds ... */</label><label for="signalCtx-showhide-fields" class="hide-inline">/* 3 unexporteds: */</label></i><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-301">cancel</a> <i><a href="../context.html">context</a>.<a href="../context.html#name-CancelFunc">CancelFunc</a></i></span></i></span><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-303">ch</a> <i>chan <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a></i></span></i></span><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-302">signals</a> <i>[]<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a></i></span></i></span></span>
		<input type='checkbox' class="fold" id="signalCtx-fold-methods"><label for="signalCtx-fold-methods">Methods (<i>total 6, in which 5 are exported</i>)</label><span id='signalCtx-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="signalCtx-fold-method-Deadline"><label for="signalCtx-fold-method-Deadline">( T) <a href="../../src/context/context.go.html#line-66">Deadline</a>() (deadline <a href="../time.html">time</a>.<a href="../time.html#name-Time">Time</a>, ok <a href="../builtin.html#name-bool">bool</a>)</label><span id='signalCtx-fold-method-Deadline-docs' class="fold-docs">
				Deadline returns the time when work done on behalf of this context
				should be canceled. Deadline returns ok==false when no deadline is
				set. Successive calls to Deadline return the same results.
</span></span><span>
			<input type='checkbox' class="fold" id="signalCtx-fold-method-Done"><label for="signalCtx-fold-method-Done">( T) <a href="../../src/context/context.go.html#line-99">Done</a>() &lt;-chan struct{}</label><span id='signalCtx-fold-method-Done-docs' class="fold-docs">
				Done returns a channel that's closed when work done on behalf of this
				context should be canceled. Done may return nil if this context can
				never be canceled. Successive calls to Done return the same value.
				The close of the Done channel may happen asynchronously,
				after the cancel function returns.

				WithCancel arranges for Done to be closed when cancel is called;
				WithDeadline arranges for Done to be closed when the deadline
				expires; WithTimeout arranges for Done to be closed when the timeout
				elapses.

				Done is provided for use in select statements:

				 // Stream generates values with DoSomething and sends them to out
				 // until DoSomething returns an error or ctx.Done is closed.
				 func Stream(ctx context.Context, out chan&lt;- Value) error {
				 	for {
				 		v, err := DoSomething(ctx)
				 		if err != nil {
				 			return err
				 		}
				 		select {
				 		case &lt;-ctx.Done():
				 			return ctx.Err()
				 		case out &lt;- v:
				 		}
				 	}
				 }

				See https://blog.golang.org/pipelines for more examples of how to use
				a Done channel for cancellation.
</span></span><span>
			<input type='checkbox' class="fold" id="signalCtx-fold-method-Err"><label for="signalCtx-fold-method-Err">( T) <a href="../../src/context/context.go.html#line-106">Err</a>() <a href="../builtin.html#name-error">error</a></label><span id='signalCtx-fold-method-Err-docs' class="fold-docs">
				If Done is not yet closed, Err returns nil.
				If Done is closed, Err returns a non-nil error explaining why:
				Canceled if the context was canceled
				or DeadlineExceeded if the context's deadline passed.
				After Err returns a non-nil error, successive calls to Err return the same error.
</span></span><span>
			<span class="nodocs">(*T) <a href="../../src/os/signal/signal.go.html#line-315">String</a>() <a href="../builtin.html#name-string">string</a></span></span><span>
			<input type='checkbox' class="fold" id="signalCtx-fold-method-Value"><label for="signalCtx-fold-method-Value">( T) <a href="../../src/context/context.go.html#line-153">Value</a>(key interface{}) interface{}</label><span id='signalCtx-fold-method-Value-docs' class="fold-docs">
				Value returns the value associated with this context for key, or nil
				if no value is associated with key. Successive calls to Value with
				the same key returns the same result.

				Use context values only for request-scoped data that transits
				processes and API boundaries, not for passing optional parameters to
				functions.

				A key identifies a specific value in a Context. Functions that wish
				to store values in Context typically allocate a key in a global
				variable then use that key as the argument to context.WithValue and
				Context.Value. A key can be any type that supports equality;
				packages should define keys as an unexported type to avoid
				collisions.

				Packages that define a Context key should provide type-safe accessors
				for the values stored using that key:

					// Package user defines a User type that's stored in Contexts.
					package user

					import "context"

					// User is the type of value stored in the Contexts.
					type User struct {...}

					// key is an unexported type for keys defined in this package.
					// This prevents collisions with keys defined in other packages.
					type key int

					// userKey is the key for user.User values in Contexts. It is
					// unexported; clients use user.NewContext and user.FromContext
					// instead of using this key directly.
					var userKey key

					// NewContext returns a new Context that carries value u.
					func NewContext(ctx context.Context, u *User) context.Context {
						return context.WithValue(ctx, userKey, u)
					}

					// FromContext returns the User value stored in ctx, if any.
					func FromContext(ctx context.Context) (*User, bool) {
						u, ok := ctx.Value(userKey).(*User)
						return u, ok
					}
</span></span>
			<input type='checkbox' checked class="showhide" id="signalCtx-showhide-methods"><i><label for="signalCtx-showhide-methods" class="show-inline">/* one unexported ... */</label><label for="signalCtx-showhide-methods" class="hide-inline">/* one unexported: */</label></i><span class="hidden"><i>
			<span class="nodocs">(*T) <a href="../../src/os/signal/signal.go.html#line-306">stop</a>()</span></i></span></span>
		<input type='checkbox' class="fold" id="signalCtx-fold-impls"><label for="signalCtx-fold-impls">Implements (<i>at least 5, in which 2 are exported</i>)</label><span id='signalCtx-fold-impls-items' class="fold-items"><span>
			 T : context.<a href="../context.html#name-Context">Context</a></span><span>
			*T : fmt.<a href="../fmt.html#name-Stringer">Stringer</a></span>
			<input type='checkbox' checked class="showhide" id="signalCtx-showhide-impls"><i><label for="signalCtx-showhide-impls" class="show-inline">/* 3+ unexporteds ... */</label><label for="signalCtx-showhide-impls" class="hide-inline">/* 3+ unexporteds: */</label></i><span class="hidden"><i>
			*T : <a href="#name-stringer">stringer</a></i></span><span class="hidden"><i>
			*T : context.<a href="../context.html#name-stringer">stringer</a></i></span><span class="hidden"><i>
			*T : runtime.<a href="../runtime.html#name-stringer">stringer</a></i></span></span>

</span></div><div class="anchor type-res hidden" id="name-stopping" data-popularity="0">	<input type='checkbox' class="fold" id="stopping-fold-content"><label for="stopping-fold-content"> type <a href="../../src/os/signal/signal.go.html#line-27">stopping</a> <i>(struct)</i></label><span id='stopping-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="stopping-fold-fields"><label for="stopping-fold-fields">Fields (<i>total 2, neither is exported</i>)</label><span id='stopping-fold-fields-items' class="fold-items">
			<input type='checkbox' checked class="showhide" id="stopping-showhide-fields"><i><label for="stopping-showhide-fields" class="show-inline">/* 2 unexporteds ... */</label><label for="stopping-showhide-fields" class="hide-inline">/* 2 unexporteds: */</label></i><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-28">c</a> <i>chan&lt;- <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a></i></span></i></span><span class="hidden"><i>
			<span class="nodocs"><a href="../../src/os/signal/signal.go.html#line-29">h</a> <i>*<a href="#name-handler">handler</a></i></span></i></span></span>

</span></div><div class="anchor type-res hidden" id="name-stringer" data-popularity="9500">	<input type='checkbox' class="fold" id="stringer-fold-content"><label for="stringer-fold-content"> type <a href="../../src/os/signal/signal.go.html#line-311">stringer</a> <b><i>(interface)</i></b></label><span id='stringer-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="stringer-fold-methods"><label for="stringer-fold-methods">Methods (<i>only one, which is exported</i>)</label><span id='stringer-fold-methods-items' class="fold-items"><span>
			<span class="nodocs">( T) <a href="../../src/runtime/error.go.html#line-205">String</a>() <a href="../builtin.html#name-string">string</a></span></span></span>
		<input type='checkbox' class="fold" id="stringer-fold-impledby"><label for="stringer-fold-impledby">Implemented By (<i>at least 62, in which 23 are exported</i>)</label><span id='stringer-fold-impledby-items' class="fold-items"><span>
			*os.<a href="../os.html#name-ProcessState">ProcessState</a></span><span>
			 os.<a href="../os.html#name-Signal">Signal</a> <i>(interface)</i></span><span>
			*os/exec.<a href="exec.html#name-Cmd">Cmd</a></span><span>
			 os/exec.<a href="exec.html#name-ExitError">ExitError</a></span><span>
			*bytes.<a href="../bytes.html#name-Buffer">Buffer</a></span><span>
			 encoding/binary.<a href="../encoding/binary.html#name-ByteOrder">ByteOrder</a> <i>(interface)</i></span><span>
			 encoding/json.<a href="../encoding/json.html#name-Delim">Delim</a></span><span>
			 encoding/json.<a href="../encoding/json.html#name-Number">Number</a></span><span>
			 fmt.<a href="../fmt.html#name-Stringer">Stringer</a> <i>(interface)</i></span><span>
			 internal/reflectlite.<a href="../internal/reflectlite.html#name-Kind">Kind</a></span><span>
			 internal/reflectlite.<a href="../internal/reflectlite.html#name-Type">Type</a> <i>(interface)</i></span><span>
			 io/fs.<a href="../io/fs.html#name-FileMode">FileMode</a></span><span>
			 reflect.<a href="../reflect.html#name-ChanDir">ChanDir</a></span><span>
			 reflect.<a href="../reflect.html#name-Kind">Kind</a></span><span>
			 reflect.<a href="../reflect.html#name-Type">Type</a> <i>(interface)</i></span><span>
			 reflect.<a href="../reflect.html#name-Value">Value</a></span><span>
			*strings.<a href="../strings.html#name-Builder">Builder</a></span><span>
			 syscall.<a href="../syscall.html#name-Signal">Signal</a></span><span>
			 time.<a href="../time.html#name-Duration">Duration</a></span><span>
			*time.<a href="../time.html#name-Location">Location</a></span><span>
			 time.<a href="../time.html#name-Month">Month</a></span><span>
			 time.<a href="../time.html#name-Time">Time</a></span><span>
			 time.<a href="../time.html#name-Weekday">Weekday</a></span>
			<input type='checkbox' checked class="showhide" id="stringer-showhide-impedBys"><i><label for="stringer-showhide-impedBys" class="show-inline">/* 39+ unexporteds ... */</label><label for="stringer-showhide-impedBys" class="hide-inline">/* 39+ unexporteds: */</label></i><span class="hidden"><i>
			*<a href="#name-signalCtx">signalCtx</a></i></span><span class="hidden"><i>
			*context.<a href="../context.html#name-cancelCtx">cancelCtx</a></i></span><span class="hidden"><i>
			*context.<a href="../context.html#name-emptyCtx">emptyCtx</a></i></span><span class="hidden"><i>
			 context.<a href="../context.html#name-stringer">stringer</a> <i>(interface)</i></i></span><span class="hidden"><i>
			*context.<a href="../context.html#name-timerCtx">timerCtx</a></i></span><span class="hidden"><i>
			*context.<a href="../context.html#name-valueCtx">valueCtx</a></i></span><span class="hidden"><i>
			 encoding/binary.<a href="../encoding/binary.html#name-bigEndian">bigEndian</a></i></span><span class="hidden"><i>
			 encoding/binary.<a href="../encoding/binary.html#name-littleEndian">littleEndian</a></i></span><span class="hidden"><i>
			*encoding/json.<a href="../encoding/json.html#name-encodeState">encodeState</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-arrayType">arrayType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-chanType">chanType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-funcType">funcType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-interfaceType">interfaceType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-mapType">mapType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-ptrType">ptrType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-rtype">rtype</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-sliceType">sliceType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-structType">structType</a></i></span><span class="hidden"><i>
			*internal/reflectlite.<a href="../internal/reflectlite.html#name-structTypeUncommon">structTypeUncommon</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-arrayType">arrayType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-chanType">chanType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcType">funcType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed128">funcTypeFixed128</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed16">funcTypeFixed16</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed32">funcTypeFixed32</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed4">funcTypeFixed4</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed64">funcTypeFixed64</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-funcTypeFixed8">funcTypeFixed8</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-interfaceType">interfaceType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-mapType">mapType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-ptrType">ptrType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-rtype">rtype</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-sliceType">sliceType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-structType">structType</a></i></span><span class="hidden"><i>
			*reflect.<a href="../reflect.html#name-structTypeUncommon">structTypeUncommon</a></i></span><span class="hidden"><i>
			 runtime.<a href="../runtime.html#name-lockRank">lockRank</a></i></span><span class="hidden"><i>
			 runtime.<a href="../runtime.html#name-stringer">stringer</a> <i>(interface)</i></i></span><span class="hidden"><i>
			 runtime.<a href="../runtime.html#name-waitReason">waitReason</a></i></span><span class="hidden"><i>
			*strconv.<a href="../strconv.html#name-decimal">decimal</a></i></span></span>
		<input type='checkbox' class="fold" id="stringer-fold-impls"><label for="stringer-fold-impls">Implements (<i>at least 3, in which 1 are exported</i>)</label><span id='stringer-fold-impls-items' class="fold-items"><span>
			 T : fmt.<a href="../fmt.html#name-Stringer">Stringer</a></span>
			<input type='checkbox' checked class="showhide" id="stringer-showhide-impls"><i><label for="stringer-showhide-impls" class="show-inline">/* 2+ unexporteds ... */</label><label for="stringer-showhide-impls" class="hide-inline">/* 2+ unexporteds: */</label></i><span class="hidden"><i>
			 T : context.<a href="../context.html#name-stringer">stringer</a></i></span><span class="hidden"><i>
			 T : runtime.<a href="../runtime.html#name-stringer">stringer</a></i></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 21, in which 6 are exported)</i></span></span>

<div class="anchor value-res" id="name-Ignore">	<input type='checkbox' class="fold" id="Ignore-fold-content"><label for="Ignore-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-86">Ignore</a>(sig ...<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>)</label><span id='Ignore-fold-content-docs' class="fold-docs">
		Ignore causes the provided signals to be ignored. If they are received by
		the program, nothing will happen. Ignore undoes the effect of any prior
		calls to Notify for the provided signals.
		If no signals are provided, all incoming signals will be ignored.

</span></div><div class="anchor value-res" id="name-Ignored">	<input type='checkbox' class="fold" id="Ignored-fold-content"><label for="Ignored-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-91">Ignored</a>(sig <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>) <a href="../builtin.html#name-bool">bool</a></label><span id='Ignored-fold-content-docs' class="fold-docs">
		Ignored reports whether sig is currently ignored.

</span></div><div class="anchor value-res" id="name-Notify">	<input type='checkbox' class="fold" id="Notify-fold-content"><label for="Notify-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-121">Notify</a>(c chan&lt;- <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>, sig ...<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>)</label><span id='Notify-fold-content-docs' class="fold-docs">
		Notify causes package signal to relay incoming signals to c.
		If no signals are provided, all incoming signals will be relayed to c.
		Otherwise, just the provided signals will.

		Package signal will not block sending to c: the caller must ensure
		that c has sufficient buffer space to keep up with the expected
		signal rate. For a channel used for notification of just one signal value,
		a buffer of size 1 is sufficient.

		It is allowed to call Notify multiple times with the same channel:
		each call expands the set of signals sent to that channel.
		The only way to remove signals from the set is to call Stop.

		It is allowed to call Notify multiple times with different channels
		and the same signals: each channel receives copies of incoming
		signals independently.

</span></div><div class="anchor value-res" id="name-NotifyContext">	<input type='checkbox' class="fold" id="NotifyContext-fold-content"><label for="NotifyContext-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-277">NotifyContext</a>(parent <a href="../context.html">context</a>.<a href="../context.html#name-Context">Context</a>, signals ...<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>) (ctx <a href="../context.html">context</a>.<a href="../context.html#name-Context">Context</a>, stop <a href="../context.html">context</a>.<a href="../context.html#name-CancelFunc">CancelFunc</a>)</label><span id='NotifyContext-fold-content-docs' class="fold-docs">
		NotifyContext returns a copy of the parent context that is marked done
		(its Done channel is closed) when one of the listed signals arrives,
		when the returned stop function is called, or when the parent context's
		Done channel is closed, whichever happens first.

		The stop function unregisters the signal behavior, which, like signal.Reset,
		may restore the default behavior for a given signal. For example, the default
		behavior of a Go program receiving os.Interrupt is to exit. Calling
		NotifyContext(parent, os.Interrupt) will change the behavior to cancel
		the returned context. Future interrupts received will not trigger the default
		(exit) behavior until the returned stop function is called.

		The stop function releases resources associated with it, so code should
		call stop as soon as the operations running in this Context complete and
		signals no longer need to be diverted to the context.

</span></div><div class="anchor value-res" id="name-Reset">	<input type='checkbox' class="fold" id="Reset-fold-content"><label for="Reset-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-173">Reset</a>(sig ...<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>)</label><span id='Reset-fold-content-docs' class="fold-docs">
		Reset undoes the effect of any prior calls to Notify for the provided
		signals.
		If no signals are provided, all signal handlers will be reset.

</span></div><div class="anchor value-res" id="name-Stop">	<input type='checkbox' class="fold" id="Stop-fold-content"><label for="Stop-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-180">Stop</a>(c chan&lt;- <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>)</label><span id='Stop-fold-content-docs' class="fold-docs">
		Stop causes package signal to stop relaying incoming signals to c.
		It undoes the effect of all prior calls to Notify using c.
		When Stop returns, it is guaranteed that c will receive no more signals.

</span></div>	<input type='checkbox' class="showhide" id="unexported-functions-showhide"><i><label for="unexported-functions-showhide" class="show-inline">/* 15 unexporteds ... */</label><label for="unexported-functions-showhide" class="hide-inline">/* 15 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-cancel"><i>	<input type='checkbox' class="fold" id="cancel-fold-content"><label for="cancel-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-51">cancel</a>(sigs []<a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>, action func(<a href="../builtin.html#name-int">int</a>))</label><span id='cancel-fold-content-docs' class="fold-docs">
		Stop relaying the signals, sigs, to any channels previously registered to
		receive them and either reset the signal handlers to their original values
		(action=disableSignal) or ignore the signals (action=ignoreSignal).

</span></i></div><div class="anchor value-res hidden" id="name-disableSignal"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-52">disableSignal</a>(sig <a href="../builtin.html#name-int">int</a>)</span></i></div><div class="anchor value-res hidden" id="name-enableSignal"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-48">enableSignal</a>(sig <a href="../builtin.html#name-int">int</a>)</span></i></div><div class="anchor value-res hidden" id="name-ignoreSignal"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-56">ignoreSignal</a>(sig <a href="../builtin.html#name-int">int</a>)</span></i></div><div class="anchor value-res hidden" id="name-init"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-27">init</a>()</span></i></div><div class="anchor value-res hidden" id="name-loop"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-21">loop</a>()</span></i></div><div class="anchor value-res hidden" id="name-process"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal.go.html#line-232">process</a>(sig <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>)</span></i></div><div class="anchor value-res hidden" id="name-signal_disable"><i>	<input type='checkbox' class="fold" id="signal_disable-fold-content"><label for="signal_disable-fold-content"> func <a href="../../src/os/signal/signal_unix.go.html#line-15">signal_disable</a>(<a href="../builtin.html#name-uint32">uint32</a>)</label><span id='signal_disable-fold-content-docs' class="fold-docs">
		Defined by the runtime package.

</span></i></div><div class="anchor value-res hidden" id="name-signal_enable"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-16">signal_enable</a>(<a href="../builtin.html#name-uint32">uint32</a>)</span></i></div><div class="anchor value-res hidden" id="name-signal_ignore"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-17">signal_ignore</a>(<a href="../builtin.html#name-uint32">uint32</a>)</span></i></div><div class="anchor value-res hidden" id="name-signal_ignored"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-18">signal_ignored</a>(<a href="../builtin.html#name-uint32">uint32</a>) <a href="../builtin.html#name-bool">bool</a></span></i></div><div class="anchor value-res hidden" id="name-signal_recv"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-19">signal_recv</a>() <a href="../builtin.html#name-uint32">uint32</a></span></i></div><div class="anchor value-res hidden" id="name-signalIgnored"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-60">signalIgnored</a>(sig <a href="../builtin.html#name-int">int</a>) <a href="../builtin.html#name-bool">bool</a></span></i></div><div class="anchor value-res hidden" id="name-signalWaitUntilIdle"><i>	<input type='checkbox' class="fold" id="signalWaitUntilIdle-fold-content"><label for="signalWaitUntilIdle-fold-content"> func <a href="../../src/os/signal/signal.go.html#line-230">signalWaitUntilIdle</a>()</label><span id='signalWaitUntilIdle-fold-content-docs' class="fold-docs">
		Wait until there are no more signals waiting to be delivered.
		Defined by the runtime package.

</span></i></div><div class="anchor value-res hidden" id="name-signum"><i>	<span class="nodocs"> func <a href="../../src/os/signal/signal_unix.go.html#line-35">signum</a>(sig <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>) <a href="../builtin.html#name-int">int</a></span></i></div></div>
<div id="exported-variables"><span class="title">Package-Level Variables<span class="title-stat"><i> (total 3, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-variables-showhide"><i><label for="unexported-variables-showhide" class="show-inline">/* 3 unexporteds ... */</label><label for="unexported-variables-showhide" class="hide-inline">/* 3 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-handlers"><i>	<span class="nodocs">  var <a href="../../src/os/signal/signal.go.html#line-13">handlers</a> struct{<a href="../sync.html">sync</a>.<a href="../sync.html#name-Mutex">Mutex</a>; m map[chan&lt;- <a href="../os.html">os</a>.<a href="../os.html#name-Signal">Signal</a>]*<a href="#name-handler">handler</a>; ref [65]<a href="../builtin.html#name-int64">int64</a>; stopping []<a href="#name-stopping">stopping</a>}</span></i></div><div class="anchor value-res hidden" id="name-watchSignalLoop"><i>	<span class="nodocs">  var <a href="../../src/os/signal/signal.go.html#line-102">watchSignalLoop</a> ()</span></i></div><div class="anchor value-res hidden" id="name-watchSignalLoopOnce"><i>	<input type='checkbox' class="fold" id="watchSignalLoopOnce-fold-content"><label for="watchSignalLoopOnce-fold-content">  var <a href="../../src/os/signal/signal.go.html#line-101">watchSignalLoopOnce</a> <a href="../sync.html">sync</a>.<a href="../sync.html#name-Once">Once</a></label><span id='watchSignalLoopOnce-fold-content-docs' class="fold-docs">
		watchSignalLoopOnce guards calling the conditionally
		initialized watchSignalLoop. If watchSignalLoop is non-nil,
		it will be run in a goroutine lazily once Notify is invoked.
		See Issue 21576.

</span></i></div></div>
<div id="exported-constants"><span class="title">Package-Level Constants<span class="title-stat"><i> (only one, which is unexported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-constants-showhide"><i><label for="unexported-constants-showhide" class="show-inline">/* one unexported ... */</label><label for="unexported-constants-showhide" class="hide-inline">/* one unexported: */</label></i><div class="anchor value-res hidden" id="name-numSig"><i>	<span class="nodocs">const <a href="../../src/os/signal/signal_unix.go.html#line-32">numSig</a> = 65 // max across all systems</span></i></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>