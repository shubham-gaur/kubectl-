<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: scan.go in package fmt</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	scan.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/fmt.html">fmt</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2010 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package fmt</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"errors"</code></span>
<span class="codeline" id="line-9"><code>	"io"</code></span>
<span class="codeline" id="line-10"><code>	"math"</code></span>
<span class="codeline" id="line-11"><code>	"os"</code></span>
<span class="codeline" id="line-12"><code>	"reflect"</code></span>
<span class="codeline" id="line-13"><code>	"strconv"</code></span>
<span class="codeline" id="line-14"><code>	"sync"</code></span>
<span class="codeline" id="line-15"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// ScanState represents the scanner state passed to custom scanners.</code></span>
<span class="codeline" id="line-19"><code>// Scanners may do rune-at-a-time scanning or ask the ScanState</code></span>
<span class="codeline" id="line-20"><code>// to discover the next space-delimited token.</code></span>
<span class="codeline" id="line-21"><code>type ScanState interface {</code></span>
<span class="codeline" id="line-22"><code>	// ReadRune reads the next rune (Unicode code point) from the input.</code></span>
<span class="codeline" id="line-23"><code>	// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will</code></span>
<span class="codeline" id="line-24"><code>	// return EOF after returning the first '\n' or when reading beyond</code></span>
<span class="codeline" id="line-25"><code>	// the specified width.</code></span>
<span class="codeline" id="line-26"><code>	ReadRune() (r rune, size int, err error)</code></span>
<span class="codeline" id="line-27"><code>	// UnreadRune causes the next call to ReadRune to return the same rune.</code></span>
<span class="codeline" id="line-28"><code>	UnreadRune() error</code></span>
<span class="codeline" id="line-29"><code>	// SkipSpace skips space in the input. Newlines are treated appropriately</code></span>
<span class="codeline" id="line-30"><code>	// for the operation being performed; see the package documentation</code></span>
<span class="codeline" id="line-31"><code>	// for more information.</code></span>
<span class="codeline" id="line-32"><code>	SkipSpace()</code></span>
<span class="codeline" id="line-33"><code>	// Token skips space in the input if skipSpace is true, then returns the</code></span>
<span class="codeline" id="line-34"><code>	// run of Unicode code points c satisfying f(c).  If f is nil,</code></span>
<span class="codeline" id="line-35"><code>	// !unicode.IsSpace(c) is used; that is, the token will hold non-space</code></span>
<span class="codeline" id="line-36"><code>	// characters. Newlines are treated appropriately for the operation being</code></span>
<span class="codeline" id="line-37"><code>	// performed; see the package documentation for more information.</code></span>
<span class="codeline" id="line-38"><code>	// The returned slice points to shared data that may be overwritten</code></span>
<span class="codeline" id="line-39"><code>	// by the next call to Token, a call to a Scan function using the ScanState</code></span>
<span class="codeline" id="line-40"><code>	// as input, or when the calling Scan method returns.</code></span>
<span class="codeline" id="line-41"><code>	Token(skipSpace bool, f func(rune) bool) (token []byte, err error)</code></span>
<span class="codeline" id="line-42"><code>	// Width returns the value of the width option and whether it has been set.</code></span>
<span class="codeline" id="line-43"><code>	// The unit is Unicode code points.</code></span>
<span class="codeline" id="line-44"><code>	Width() (wid int, ok bool)</code></span>
<span class="codeline" id="line-45"><code>	// Because ReadRune is implemented by the interface, Read should never be</code></span>
<span class="codeline" id="line-46"><code>	// called by the scanning routines and a valid implementation of</code></span>
<span class="codeline" id="line-47"><code>	// ScanState may choose always to return an error from Read.</code></span>
<span class="codeline" id="line-48"><code>	Read(buf []byte) (n int, err error)</code></span>
<span class="codeline" id="line-49"><code>}</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// Scanner is implemented by any value that has a Scan method, which scans</code></span>
<span class="codeline" id="line-52"><code>// the input for the representation of a value and stores the result in the</code></span>
<span class="codeline" id="line-53"><code>// receiver, which must be a pointer to be useful. The Scan method is called</code></span>
<span class="codeline" id="line-54"><code>// for any argument to Scan, Scanf, or Scanln that implements it.</code></span>
<span class="codeline" id="line-55"><code>type Scanner interface {</code></span>
<span class="codeline" id="line-56"><code>	Scan(state ScanState, verb rune) error</code></span>
<span class="codeline" id="line-57"><code>}</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>// Scan scans text read from standard input, storing successive</code></span>
<span class="codeline" id="line-60"><code>// space-separated values into successive arguments. Newlines count</code></span>
<span class="codeline" id="line-61"><code>// as space. It returns the number of items successfully scanned.</code></span>
<span class="codeline" id="line-62"><code>// If that is less than the number of arguments, err will report why.</code></span>
<span class="codeline" id="line-63"><code>func Scan(a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-64"><code>	return Fscan(os.Stdin, a...)</code></span>
<span class="codeline" id="line-65"><code>}</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>// Scanln is similar to Scan, but stops scanning at a newline and</code></span>
<span class="codeline" id="line-68"><code>// after the final item there must be a newline or EOF.</code></span>
<span class="codeline" id="line-69"><code>func Scanln(a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-70"><code>	return Fscanln(os.Stdin, a...)</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// Scanf scans text read from standard input, storing successive</code></span>
<span class="codeline" id="line-74"><code>// space-separated values into successive arguments as determined by</code></span>
<span class="codeline" id="line-75"><code>// the format. It returns the number of items successfully scanned.</code></span>
<span class="codeline" id="line-76"><code>// If that is less than the number of arguments, err will report why.</code></span>
<span class="codeline" id="line-77"><code>// Newlines in the input must match newlines in the format.</code></span>
<span class="codeline" id="line-78"><code>// The one exception: the verb %c always scans the next rune in the</code></span>
<span class="codeline" id="line-79"><code>// input, even if it is a space (or tab etc.) or newline.</code></span>
<span class="codeline" id="line-80"><code>func Scanf(format string, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-81"><code>	return Fscanf(os.Stdin, format, a...)</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>type stringReader string</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>func (r *stringReader) Read(b []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-87"><code>	n = copy(b, *r)</code></span>
<span class="codeline" id="line-88"><code>	*r = (*r)[n:]</code></span>
<span class="codeline" id="line-89"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-90"><code>		err = io.EOF</code></span>
<span class="codeline" id="line-91"><code>	}</code></span>
<span class="codeline" id="line-92"><code>	return</code></span>
<span class="codeline" id="line-93"><code>}</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>// Sscan scans the argument string, storing successive space-separated</code></span>
<span class="codeline" id="line-96"><code>// values into successive arguments. Newlines count as space. It</code></span>
<span class="codeline" id="line-97"><code>// returns the number of items successfully scanned. If that is less</code></span>
<span class="codeline" id="line-98"><code>// than the number of arguments, err will report why.</code></span>
<span class="codeline" id="line-99"><code>func Sscan(str string, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-100"><code>	return Fscan((*stringReader)(&amp;str), a...)</code></span>
<span class="codeline" id="line-101"><code>}</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>// Sscanln is similar to Sscan, but stops scanning at a newline and</code></span>
<span class="codeline" id="line-104"><code>// after the final item there must be a newline or EOF.</code></span>
<span class="codeline" id="line-105"><code>func Sscanln(str string, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-106"><code>	return Fscanln((*stringReader)(&amp;str), a...)</code></span>
<span class="codeline" id="line-107"><code>}</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// Sscanf scans the argument string, storing successive space-separated</code></span>
<span class="codeline" id="line-110"><code>// values into successive arguments as determined by the format. It</code></span>
<span class="codeline" id="line-111"><code>// returns the number of items successfully parsed.</code></span>
<span class="codeline" id="line-112"><code>// Newlines in the input must match newlines in the format.</code></span>
<span class="codeline" id="line-113"><code>func Sscanf(str string, format string, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-114"><code>	return Fscanf((*stringReader)(&amp;str), format, a...)</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// Fscan scans text read from r, storing successive space-separated</code></span>
<span class="codeline" id="line-118"><code>// values into successive arguments. Newlines count as space. It</code></span>
<span class="codeline" id="line-119"><code>// returns the number of items successfully scanned. If that is less</code></span>
<span class="codeline" id="line-120"><code>// than the number of arguments, err will report why.</code></span>
<span class="codeline" id="line-121"><code>func Fscan(r io.Reader, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-122"><code>	s, old := newScanState(r, true, false)</code></span>
<span class="codeline" id="line-123"><code>	n, err = s.doScan(a)</code></span>
<span class="codeline" id="line-124"><code>	s.free(old)</code></span>
<span class="codeline" id="line-125"><code>	return</code></span>
<span class="codeline" id="line-126"><code>}</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>// Fscanln is similar to Fscan, but stops scanning at a newline and</code></span>
<span class="codeline" id="line-129"><code>// after the final item there must be a newline or EOF.</code></span>
<span class="codeline" id="line-130"><code>func Fscanln(r io.Reader, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-131"><code>	s, old := newScanState(r, false, true)</code></span>
<span class="codeline" id="line-132"><code>	n, err = s.doScan(a)</code></span>
<span class="codeline" id="line-133"><code>	s.free(old)</code></span>
<span class="codeline" id="line-134"><code>	return</code></span>
<span class="codeline" id="line-135"><code>}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>// Fscanf scans text read from r, storing successive space-separated</code></span>
<span class="codeline" id="line-138"><code>// values into successive arguments as determined by the format. It</code></span>
<span class="codeline" id="line-139"><code>// returns the number of items successfully parsed.</code></span>
<span class="codeline" id="line-140"><code>// Newlines in the input must match newlines in the format.</code></span>
<span class="codeline" id="line-141"><code>func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) {</code></span>
<span class="codeline" id="line-142"><code>	s, old := newScanState(r, false, false)</code></span>
<span class="codeline" id="line-143"><code>	n, err = s.doScanf(format, a)</code></span>
<span class="codeline" id="line-144"><code>	s.free(old)</code></span>
<span class="codeline" id="line-145"><code>	return</code></span>
<span class="codeline" id="line-146"><code>}</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>// scanError represents an error generated by the scanning software.</code></span>
<span class="codeline" id="line-149"><code>// It's used as a unique signature to identify such errors when recovering.</code></span>
<span class="codeline" id="line-150"><code>type scanError struct {</code></span>
<span class="codeline" id="line-151"><code>	err error</code></span>
<span class="codeline" id="line-152"><code>}</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>const eof = -1</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>// ss is the internal implementation of ScanState.</code></span>
<span class="codeline" id="line-157"><code>type ss struct {</code></span>
<span class="codeline" id="line-158"><code>	rs    io.RuneScanner // where to read input</code></span>
<span class="codeline" id="line-159"><code>	buf   buffer         // token accumulator</code></span>
<span class="codeline" id="line-160"><code>	count int            // runes consumed so far.</code></span>
<span class="codeline" id="line-161"><code>	atEOF bool           // already read EOF</code></span>
<span class="codeline" id="line-162"><code>	ssave</code></span>
<span class="codeline" id="line-163"><code>}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>// ssave holds the parts of ss that need to be</code></span>
<span class="codeline" id="line-166"><code>// saved and restored on recursive scans.</code></span>
<span class="codeline" id="line-167"><code>type ssave struct {</code></span>
<span class="codeline" id="line-168"><code>	validSave bool // is or was a part of an actual ss.</code></span>
<span class="codeline" id="line-169"><code>	nlIsEnd   bool // whether newline terminates scan</code></span>
<span class="codeline" id="line-170"><code>	nlIsSpace bool // whether newline counts as white space</code></span>
<span class="codeline" id="line-171"><code>	argLimit  int  // max value of ss.count for this arg; argLimit &lt;= limit</code></span>
<span class="codeline" id="line-172"><code>	limit     int  // max value of ss.count.</code></span>
<span class="codeline" id="line-173"><code>	maxWid    int  // width of this arg.</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// The Read method is only in ScanState so that ScanState</code></span>
<span class="codeline" id="line-177"><code>// satisfies io.Reader. It will never be called when used as</code></span>
<span class="codeline" id="line-178"><code>// intended, so there is no need to make it actually work.</code></span>
<span class="codeline" id="line-179"><code>func (s *ss) Read(buf []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-180"><code>	return 0, errors.New("ScanState's Read should not be called. Use ReadRune")</code></span>
<span class="codeline" id="line-181"><code>}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>func (s *ss) ReadRune() (r rune, size int, err error) {</code></span>
<span class="codeline" id="line-184"><code>	if s.atEOF || s.count &gt;= s.argLimit {</code></span>
<span class="codeline" id="line-185"><code>		err = io.EOF</code></span>
<span class="codeline" id="line-186"><code>		return</code></span>
<span class="codeline" id="line-187"><code>	}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	r, size, err = s.rs.ReadRune()</code></span>
<span class="codeline" id="line-190"><code>	if err == nil {</code></span>
<span class="codeline" id="line-191"><code>		s.count++</code></span>
<span class="codeline" id="line-192"><code>		if s.nlIsEnd &amp;&amp; r == '\n' {</code></span>
<span class="codeline" id="line-193"><code>			s.atEOF = true</code></span>
<span class="codeline" id="line-194"><code>		}</code></span>
<span class="codeline" id="line-195"><code>	} else if err == io.EOF {</code></span>
<span class="codeline" id="line-196"><code>		s.atEOF = true</code></span>
<span class="codeline" id="line-197"><code>	}</code></span>
<span class="codeline" id="line-198"><code>	return</code></span>
<span class="codeline" id="line-199"><code>}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>func (s *ss) Width() (wid int, ok bool) {</code></span>
<span class="codeline" id="line-202"><code>	if s.maxWid == hugeWid {</code></span>
<span class="codeline" id="line-203"><code>		return 0, false</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	return s.maxWid, true</code></span>
<span class="codeline" id="line-206"><code>}</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>// The public method returns an error; this private one panics.</code></span>
<span class="codeline" id="line-209"><code>// If getRune reaches EOF, the return value is EOF (-1).</code></span>
<span class="codeline" id="line-210"><code>func (s *ss) getRune() (r rune) {</code></span>
<span class="codeline" id="line-211"><code>	r, _, err := s.ReadRune()</code></span>
<span class="codeline" id="line-212"><code>	if err != nil {</code></span>
<span class="codeline" id="line-213"><code>		if err == io.EOF {</code></span>
<span class="codeline" id="line-214"><code>			return eof</code></span>
<span class="codeline" id="line-215"><code>		}</code></span>
<span class="codeline" id="line-216"><code>		s.error(err)</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	return</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>// mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF).</code></span>
<span class="codeline" id="line-222"><code>// It is called in cases such as string scanning where an EOF is a</code></span>
<span class="codeline" id="line-223"><code>// syntax error.</code></span>
<span class="codeline" id="line-224"><code>func (s *ss) mustReadRune() (r rune) {</code></span>
<span class="codeline" id="line-225"><code>	r = s.getRune()</code></span>
<span class="codeline" id="line-226"><code>	if r == eof {</code></span>
<span class="codeline" id="line-227"><code>		s.error(io.ErrUnexpectedEOF)</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	return</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>func (s *ss) UnreadRune() error {</code></span>
<span class="codeline" id="line-233"><code>	s.rs.UnreadRune()</code></span>
<span class="codeline" id="line-234"><code>	s.atEOF = false</code></span>
<span class="codeline" id="line-235"><code>	s.count--</code></span>
<span class="codeline" id="line-236"><code>	return nil</code></span>
<span class="codeline" id="line-237"><code>}</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>func (s *ss) error(err error) {</code></span>
<span class="codeline" id="line-240"><code>	panic(scanError{err})</code></span>
<span class="codeline" id="line-241"><code>}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>func (s *ss) errorString(err string) {</code></span>
<span class="codeline" id="line-244"><code>	panic(scanError{errors.New(err)})</code></span>
<span class="codeline" id="line-245"><code>}</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) {</code></span>
<span class="codeline" id="line-248"><code>	defer func() {</code></span>
<span class="codeline" id="line-249"><code>		if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-250"><code>			if se, ok := e.(scanError); ok {</code></span>
<span class="codeline" id="line-251"><code>				err = se.err</code></span>
<span class="codeline" id="line-252"><code>			} else {</code></span>
<span class="codeline" id="line-253"><code>				panic(e)</code></span>
<span class="codeline" id="line-254"><code>			}</code></span>
<span class="codeline" id="line-255"><code>		}</code></span>
<span class="codeline" id="line-256"><code>	}()</code></span>
<span class="codeline" id="line-257"><code>	if f == nil {</code></span>
<span class="codeline" id="line-258"><code>		f = notSpace</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	s.buf = s.buf[:0]</code></span>
<span class="codeline" id="line-261"><code>	tok = s.token(skipSpace, f)</code></span>
<span class="codeline" id="line-262"><code>	return</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// space is a copy of the unicode.White_Space ranges,</code></span>
<span class="codeline" id="line-266"><code>// to avoid depending on package unicode.</code></span>
<span class="codeline" id="line-267"><code>var space = [][2]uint16{</code></span>
<span class="codeline" id="line-268"><code>	{0x0009, 0x000d},</code></span>
<span class="codeline" id="line-269"><code>	{0x0020, 0x0020},</code></span>
<span class="codeline" id="line-270"><code>	{0x0085, 0x0085},</code></span>
<span class="codeline" id="line-271"><code>	{0x00a0, 0x00a0},</code></span>
<span class="codeline" id="line-272"><code>	{0x1680, 0x1680},</code></span>
<span class="codeline" id="line-273"><code>	{0x2000, 0x200a},</code></span>
<span class="codeline" id="line-274"><code>	{0x2028, 0x2029},</code></span>
<span class="codeline" id="line-275"><code>	{0x202f, 0x202f},</code></span>
<span class="codeline" id="line-276"><code>	{0x205f, 0x205f},</code></span>
<span class="codeline" id="line-277"><code>	{0x3000, 0x3000},</code></span>
<span class="codeline" id="line-278"><code>}</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>func isSpace(r rune) bool {</code></span>
<span class="codeline" id="line-281"><code>	if r &gt;= 1&lt;&lt;16 {</code></span>
<span class="codeline" id="line-282"><code>		return false</code></span>
<span class="codeline" id="line-283"><code>	}</code></span>
<span class="codeline" id="line-284"><code>	rx := uint16(r)</code></span>
<span class="codeline" id="line-285"><code>	for _, rng := range space {</code></span>
<span class="codeline" id="line-286"><code>		if rx &lt; rng[0] {</code></span>
<span class="codeline" id="line-287"><code>			return false</code></span>
<span class="codeline" id="line-288"><code>		}</code></span>
<span class="codeline" id="line-289"><code>		if rx &lt;= rng[1] {</code></span>
<span class="codeline" id="line-290"><code>			return true</code></span>
<span class="codeline" id="line-291"><code>		}</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	return false</code></span>
<span class="codeline" id="line-294"><code>}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>// notSpace is the default scanning function used in Token.</code></span>
<span class="codeline" id="line-297"><code>func notSpace(r rune) bool {</code></span>
<span class="codeline" id="line-298"><code>	return !isSpace(r)</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// readRune is a structure to enable reading UTF-8 encoded code points</code></span>
<span class="codeline" id="line-302"><code>// from an io.Reader. It is used if the Reader given to the scanner does</code></span>
<span class="codeline" id="line-303"><code>// not already implement io.RuneScanner.</code></span>
<span class="codeline" id="line-304"><code>type readRune struct {</code></span>
<span class="codeline" id="line-305"><code>	reader   io.Reader</code></span>
<span class="codeline" id="line-306"><code>	buf      [utf8.UTFMax]byte // used only inside ReadRune</code></span>
<span class="codeline" id="line-307"><code>	pending  int               // number of bytes in pendBuf; only &gt;0 for bad UTF-8</code></span>
<span class="codeline" id="line-308"><code>	pendBuf  [utf8.UTFMax]byte // bytes left over</code></span>
<span class="codeline" id="line-309"><code>	peekRune rune              // if &gt;=0 next rune; when &lt;0 is ^(previous Rune)</code></span>
<span class="codeline" id="line-310"><code>}</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// readByte returns the next byte from the input, which may be</code></span>
<span class="codeline" id="line-313"><code>// left over from a previous read if the UTF-8 was ill-formed.</code></span>
<span class="codeline" id="line-314"><code>func (r *readRune) readByte() (b byte, err error) {</code></span>
<span class="codeline" id="line-315"><code>	if r.pending &gt; 0 {</code></span>
<span class="codeline" id="line-316"><code>		b = r.pendBuf[0]</code></span>
<span class="codeline" id="line-317"><code>		copy(r.pendBuf[0:], r.pendBuf[1:])</code></span>
<span class="codeline" id="line-318"><code>		r.pending--</code></span>
<span class="codeline" id="line-319"><code>		return</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	n, err := io.ReadFull(r.reader, r.pendBuf[:1])</code></span>
<span class="codeline" id="line-322"><code>	if n != 1 {</code></span>
<span class="codeline" id="line-323"><code>		return 0, err</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code>	return r.pendBuf[0], err</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// ReadRune returns the next UTF-8 encoded code point from the</code></span>
<span class="codeline" id="line-329"><code>// io.Reader inside r.</code></span>
<span class="codeline" id="line-330"><code>func (r *readRune) ReadRune() (rr rune, size int, err error) {</code></span>
<span class="codeline" id="line-331"><code>	if r.peekRune &gt;= 0 {</code></span>
<span class="codeline" id="line-332"><code>		rr = r.peekRune</code></span>
<span class="codeline" id="line-333"><code>		r.peekRune = ^r.peekRune</code></span>
<span class="codeline" id="line-334"><code>		size = utf8.RuneLen(rr)</code></span>
<span class="codeline" id="line-335"><code>		return</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code>	r.buf[0], err = r.readByte()</code></span>
<span class="codeline" id="line-338"><code>	if err != nil {</code></span>
<span class="codeline" id="line-339"><code>		return</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code>	if r.buf[0] &lt; utf8.RuneSelf { // fast check for common ASCII case</code></span>
<span class="codeline" id="line-342"><code>		rr = rune(r.buf[0])</code></span>
<span class="codeline" id="line-343"><code>		size = 1 // Known to be 1.</code></span>
<span class="codeline" id="line-344"><code>		// Flip the bits of the rune so it's available to UnreadRune.</code></span>
<span class="codeline" id="line-345"><code>		r.peekRune = ^rr</code></span>
<span class="codeline" id="line-346"><code>		return</code></span>
<span class="codeline" id="line-347"><code>	}</code></span>
<span class="codeline" id="line-348"><code>	var n int</code></span>
<span class="codeline" id="line-349"><code>	for n = 1; !utf8.FullRune(r.buf[:n]); n++ {</code></span>
<span class="codeline" id="line-350"><code>		r.buf[n], err = r.readByte()</code></span>
<span class="codeline" id="line-351"><code>		if err != nil {</code></span>
<span class="codeline" id="line-352"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-353"><code>				err = nil</code></span>
<span class="codeline" id="line-354"><code>				break</code></span>
<span class="codeline" id="line-355"><code>			}</code></span>
<span class="codeline" id="line-356"><code>			return</code></span>
<span class="codeline" id="line-357"><code>		}</code></span>
<span class="codeline" id="line-358"><code>	}</code></span>
<span class="codeline" id="line-359"><code>	rr, size = utf8.DecodeRune(r.buf[:n])</code></span>
<span class="codeline" id="line-360"><code>	if size &lt; n { // an error, save the bytes for the next read</code></span>
<span class="codeline" id="line-361"><code>		copy(r.pendBuf[r.pending:], r.buf[size:n])</code></span>
<span class="codeline" id="line-362"><code>		r.pending += n - size</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>	// Flip the bits of the rune so it's available to UnreadRune.</code></span>
<span class="codeline" id="line-365"><code>	r.peekRune = ^rr</code></span>
<span class="codeline" id="line-366"><code>	return</code></span>
<span class="codeline" id="line-367"><code>}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>func (r *readRune) UnreadRune() error {</code></span>
<span class="codeline" id="line-370"><code>	if r.peekRune &gt;= 0 {</code></span>
<span class="codeline" id="line-371"><code>		return errors.New("fmt: scanning called UnreadRune with no rune available")</code></span>
<span class="codeline" id="line-372"><code>	}</code></span>
<span class="codeline" id="line-373"><code>	// Reverse bit flip of previously read rune to obtain valid &gt;=0 state.</code></span>
<span class="codeline" id="line-374"><code>	r.peekRune = ^r.peekRune</code></span>
<span class="codeline" id="line-375"><code>	return nil</code></span>
<span class="codeline" id="line-376"><code>}</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>var ssFree = sync.Pool{</code></span>
<span class="codeline" id="line-379"><code>	New: func() interface{} { return new(ss) },</code></span>
<span class="codeline" id="line-380"><code>}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>// newScanState allocates a new ss struct or grab a cached one.</code></span>
<span class="codeline" id="line-383"><code>func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) {</code></span>
<span class="codeline" id="line-384"><code>	s = ssFree.Get().(*ss)</code></span>
<span class="codeline" id="line-385"><code>	if rs, ok := r.(io.RuneScanner); ok {</code></span>
<span class="codeline" id="line-386"><code>		s.rs = rs</code></span>
<span class="codeline" id="line-387"><code>	} else {</code></span>
<span class="codeline" id="line-388"><code>		s.rs = &amp;readRune{reader: r, peekRune: -1}</code></span>
<span class="codeline" id="line-389"><code>	}</code></span>
<span class="codeline" id="line-390"><code>	s.nlIsSpace = nlIsSpace</code></span>
<span class="codeline" id="line-391"><code>	s.nlIsEnd = nlIsEnd</code></span>
<span class="codeline" id="line-392"><code>	s.atEOF = false</code></span>
<span class="codeline" id="line-393"><code>	s.limit = hugeWid</code></span>
<span class="codeline" id="line-394"><code>	s.argLimit = hugeWid</code></span>
<span class="codeline" id="line-395"><code>	s.maxWid = hugeWid</code></span>
<span class="codeline" id="line-396"><code>	s.validSave = true</code></span>
<span class="codeline" id="line-397"><code>	s.count = 0</code></span>
<span class="codeline" id="line-398"><code>	return</code></span>
<span class="codeline" id="line-399"><code>}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>// free saves used ss structs in ssFree; avoid an allocation per invocation.</code></span>
<span class="codeline" id="line-402"><code>func (s *ss) free(old ssave) {</code></span>
<span class="codeline" id="line-403"><code>	// If it was used recursively, just restore the old state.</code></span>
<span class="codeline" id="line-404"><code>	if old.validSave {</code></span>
<span class="codeline" id="line-405"><code>		s.ssave = old</code></span>
<span class="codeline" id="line-406"><code>		return</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code>	// Don't hold on to ss structs with large buffers.</code></span>
<span class="codeline" id="line-409"><code>	if cap(s.buf) &gt; 1024 {</code></span>
<span class="codeline" id="line-410"><code>		return</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code>	s.buf = s.buf[:0]</code></span>
<span class="codeline" id="line-413"><code>	s.rs = nil</code></span>
<span class="codeline" id="line-414"><code>	ssFree.Put(s)</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>// SkipSpace provides Scan methods the ability to skip space and newline</code></span>
<span class="codeline" id="line-418"><code>// characters in keeping with the current scanning mode set by format strings</code></span>
<span class="codeline" id="line-419"><code>// and Scan/Scanln.</code></span>
<span class="codeline" id="line-420"><code>func (s *ss) SkipSpace() {</code></span>
<span class="codeline" id="line-421"><code>	for {</code></span>
<span class="codeline" id="line-422"><code>		r := s.getRune()</code></span>
<span class="codeline" id="line-423"><code>		if r == eof {</code></span>
<span class="codeline" id="line-424"><code>			return</code></span>
<span class="codeline" id="line-425"><code>		}</code></span>
<span class="codeline" id="line-426"><code>		if r == '\r' &amp;&amp; s.peek("\n") {</code></span>
<span class="codeline" id="line-427"><code>			continue</code></span>
<span class="codeline" id="line-428"><code>		}</code></span>
<span class="codeline" id="line-429"><code>		if r == '\n' {</code></span>
<span class="codeline" id="line-430"><code>			if s.nlIsSpace {</code></span>
<span class="codeline" id="line-431"><code>				continue</code></span>
<span class="codeline" id="line-432"><code>			}</code></span>
<span class="codeline" id="line-433"><code>			s.errorString("unexpected newline")</code></span>
<span class="codeline" id="line-434"><code>			return</code></span>
<span class="codeline" id="line-435"><code>		}</code></span>
<span class="codeline" id="line-436"><code>		if !isSpace(r) {</code></span>
<span class="codeline" id="line-437"><code>			s.UnreadRune()</code></span>
<span class="codeline" id="line-438"><code>			break</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>	}</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>// token returns the next space-delimited string from the input. It</code></span>
<span class="codeline" id="line-444"><code>// skips white space. For Scanln, it stops at newlines. For Scan,</code></span>
<span class="codeline" id="line-445"><code>// newlines are treated as spaces.</code></span>
<span class="codeline" id="line-446"><code>func (s *ss) token(skipSpace bool, f func(rune) bool) []byte {</code></span>
<span class="codeline" id="line-447"><code>	if skipSpace {</code></span>
<span class="codeline" id="line-448"><code>		s.SkipSpace()</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code>	// read until white space or newline</code></span>
<span class="codeline" id="line-451"><code>	for {</code></span>
<span class="codeline" id="line-452"><code>		r := s.getRune()</code></span>
<span class="codeline" id="line-453"><code>		if r == eof {</code></span>
<span class="codeline" id="line-454"><code>			break</code></span>
<span class="codeline" id="line-455"><code>		}</code></span>
<span class="codeline" id="line-456"><code>		if !f(r) {</code></span>
<span class="codeline" id="line-457"><code>			s.UnreadRune()</code></span>
<span class="codeline" id="line-458"><code>			break</code></span>
<span class="codeline" id="line-459"><code>		}</code></span>
<span class="codeline" id="line-460"><code>		s.buf.writeRune(r)</code></span>
<span class="codeline" id="line-461"><code>	}</code></span>
<span class="codeline" id="line-462"><code>	return s.buf</code></span>
<span class="codeline" id="line-463"><code>}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>var complexError = errors.New("syntax error scanning complex number")</code></span>
<span class="codeline" id="line-466"><code>var boolError = errors.New("syntax error scanning boolean")</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>func indexRune(s string, r rune) int {</code></span>
<span class="codeline" id="line-469"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-470"><code>		if c == r {</code></span>
<span class="codeline" id="line-471"><code>			return i</code></span>
<span class="codeline" id="line-472"><code>		}</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code>	return -1</code></span>
<span class="codeline" id="line-475"><code>}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>// consume reads the next rune in the input and reports whether it is in the ok string.</code></span>
<span class="codeline" id="line-478"><code>// If accept is true, it puts the character into the input token.</code></span>
<span class="codeline" id="line-479"><code>func (s *ss) consume(ok string, accept bool) bool {</code></span>
<span class="codeline" id="line-480"><code>	r := s.getRune()</code></span>
<span class="codeline" id="line-481"><code>	if r == eof {</code></span>
<span class="codeline" id="line-482"><code>		return false</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code>	if indexRune(ok, r) &gt;= 0 {</code></span>
<span class="codeline" id="line-485"><code>		if accept {</code></span>
<span class="codeline" id="line-486"><code>			s.buf.writeRune(r)</code></span>
<span class="codeline" id="line-487"><code>		}</code></span>
<span class="codeline" id="line-488"><code>		return true</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code>	if r != eof &amp;&amp; accept {</code></span>
<span class="codeline" id="line-491"><code>		s.UnreadRune()</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code>	return false</code></span>
<span class="codeline" id="line-494"><code>}</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>// peek reports whether the next character is in the ok string, without consuming it.</code></span>
<span class="codeline" id="line-497"><code>func (s *ss) peek(ok string) bool {</code></span>
<span class="codeline" id="line-498"><code>	r := s.getRune()</code></span>
<span class="codeline" id="line-499"><code>	if r != eof {</code></span>
<span class="codeline" id="line-500"><code>		s.UnreadRune()</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code>	return indexRune(ok, r) &gt;= 0</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>func (s *ss) notEOF() {</code></span>
<span class="codeline" id="line-506"><code>	// Guarantee there is data to be read.</code></span>
<span class="codeline" id="line-507"><code>	if r := s.getRune(); r == eof {</code></span>
<span class="codeline" id="line-508"><code>		panic(io.EOF)</code></span>
<span class="codeline" id="line-509"><code>	}</code></span>
<span class="codeline" id="line-510"><code>	s.UnreadRune()</code></span>
<span class="codeline" id="line-511"><code>}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>// accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the</code></span>
<span class="codeline" id="line-514"><code>// buffer and returns true. Otherwise it return false.</code></span>
<span class="codeline" id="line-515"><code>func (s *ss) accept(ok string) bool {</code></span>
<span class="codeline" id="line-516"><code>	return s.consume(ok, true)</code></span>
<span class="codeline" id="line-517"><code>}</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>// okVerb verifies that the verb is present in the list, setting s.err appropriately if not.</code></span>
<span class="codeline" id="line-520"><code>func (s *ss) okVerb(verb rune, okVerbs, typ string) bool {</code></span>
<span class="codeline" id="line-521"><code>	for _, v := range okVerbs {</code></span>
<span class="codeline" id="line-522"><code>		if v == verb {</code></span>
<span class="codeline" id="line-523"><code>			return true</code></span>
<span class="codeline" id="line-524"><code>		}</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code>	s.errorString("bad verb '%" + string(verb) + "' for " + typ)</code></span>
<span class="codeline" id="line-527"><code>	return false</code></span>
<span class="codeline" id="line-528"><code>}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>// scanBool returns the value of the boolean represented by the next token.</code></span>
<span class="codeline" id="line-531"><code>func (s *ss) scanBool(verb rune) bool {</code></span>
<span class="codeline" id="line-532"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-533"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-534"><code>	if !s.okVerb(verb, "tv", "boolean") {</code></span>
<span class="codeline" id="line-535"><code>		return false</code></span>
<span class="codeline" id="line-536"><code>	}</code></span>
<span class="codeline" id="line-537"><code>	// Syntax-checking a boolean is annoying. We're not fastidious about case.</code></span>
<span class="codeline" id="line-538"><code>	switch s.getRune() {</code></span>
<span class="codeline" id="line-539"><code>	case '0':</code></span>
<span class="codeline" id="line-540"><code>		return false</code></span>
<span class="codeline" id="line-541"><code>	case '1':</code></span>
<span class="codeline" id="line-542"><code>		return true</code></span>
<span class="codeline" id="line-543"><code>	case 't', 'T':</code></span>
<span class="codeline" id="line-544"><code>		if s.accept("rR") &amp;&amp; (!s.accept("uU") || !s.accept("eE")) {</code></span>
<span class="codeline" id="line-545"><code>			s.error(boolError)</code></span>
<span class="codeline" id="line-546"><code>		}</code></span>
<span class="codeline" id="line-547"><code>		return true</code></span>
<span class="codeline" id="line-548"><code>	case 'f', 'F':</code></span>
<span class="codeline" id="line-549"><code>		if s.accept("aA") &amp;&amp; (!s.accept("lL") || !s.accept("sS") || !s.accept("eE")) {</code></span>
<span class="codeline" id="line-550"><code>			s.error(boolError)</code></span>
<span class="codeline" id="line-551"><code>		}</code></span>
<span class="codeline" id="line-552"><code>		return false</code></span>
<span class="codeline" id="line-553"><code>	}</code></span>
<span class="codeline" id="line-554"><code>	return false</code></span>
<span class="codeline" id="line-555"><code>}</code></span>
<span class="codeline" id="line-556"><code></code></span>
<span class="codeline" id="line-557"><code>// Numerical elements</code></span>
<span class="codeline" id="line-558"><code>const (</code></span>
<span class="codeline" id="line-559"><code>	binaryDigits      = "01"</code></span>
<span class="codeline" id="line-560"><code>	octalDigits       = "01234567"</code></span>
<span class="codeline" id="line-561"><code>	decimalDigits     = "0123456789"</code></span>
<span class="codeline" id="line-562"><code>	hexadecimalDigits = "0123456789aAbBcCdDeEfF"</code></span>
<span class="codeline" id="line-563"><code>	sign              = "+-"</code></span>
<span class="codeline" id="line-564"><code>	period            = "."</code></span>
<span class="codeline" id="line-565"><code>	exponent          = "eEpP"</code></span>
<span class="codeline" id="line-566"><code>)</code></span>
<span class="codeline" id="line-567"><code></code></span>
<span class="codeline" id="line-568"><code>// getBase returns the numeric base represented by the verb and its digit string.</code></span>
<span class="codeline" id="line-569"><code>func (s *ss) getBase(verb rune) (base int, digits string) {</code></span>
<span class="codeline" id="line-570"><code>	s.okVerb(verb, "bdoUxXv", "integer") // sets s.err</code></span>
<span class="codeline" id="line-571"><code>	base = 10</code></span>
<span class="codeline" id="line-572"><code>	digits = decimalDigits</code></span>
<span class="codeline" id="line-573"><code>	switch verb {</code></span>
<span class="codeline" id="line-574"><code>	case 'b':</code></span>
<span class="codeline" id="line-575"><code>		base = 2</code></span>
<span class="codeline" id="line-576"><code>		digits = binaryDigits</code></span>
<span class="codeline" id="line-577"><code>	case 'o':</code></span>
<span class="codeline" id="line-578"><code>		base = 8</code></span>
<span class="codeline" id="line-579"><code>		digits = octalDigits</code></span>
<span class="codeline" id="line-580"><code>	case 'x', 'X', 'U':</code></span>
<span class="codeline" id="line-581"><code>		base = 16</code></span>
<span class="codeline" id="line-582"><code>		digits = hexadecimalDigits</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code>	return</code></span>
<span class="codeline" id="line-585"><code>}</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>// scanNumber returns the numerical string with specified digits starting here.</code></span>
<span class="codeline" id="line-588"><code>func (s *ss) scanNumber(digits string, haveDigits bool) string {</code></span>
<span class="codeline" id="line-589"><code>	if !haveDigits {</code></span>
<span class="codeline" id="line-590"><code>		s.notEOF()</code></span>
<span class="codeline" id="line-591"><code>		if !s.accept(digits) {</code></span>
<span class="codeline" id="line-592"><code>			s.errorString("expected integer")</code></span>
<span class="codeline" id="line-593"><code>		}</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code>	for s.accept(digits) {</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code>	return string(s.buf)</code></span>
<span class="codeline" id="line-598"><code>}</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>// scanRune returns the next rune value in the input.</code></span>
<span class="codeline" id="line-601"><code>func (s *ss) scanRune(bitSize int) int64 {</code></span>
<span class="codeline" id="line-602"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-603"><code>	r := s.getRune()</code></span>
<span class="codeline" id="line-604"><code>	n := uint(bitSize)</code></span>
<span class="codeline" id="line-605"><code>	x := (int64(r) &lt;&lt; (64 - n)) &gt;&gt; (64 - n)</code></span>
<span class="codeline" id="line-606"><code>	if x != int64(r) {</code></span>
<span class="codeline" id="line-607"><code>		s.errorString("overflow on character value " + string(r))</code></span>
<span class="codeline" id="line-608"><code>	}</code></span>
<span class="codeline" id="line-609"><code>	return int64(r)</code></span>
<span class="codeline" id="line-610"><code>}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>// scanBasePrefix reports whether the integer begins with a base prefix</code></span>
<span class="codeline" id="line-613"><code>// and returns the base, digit string, and whether a zero was found.</code></span>
<span class="codeline" id="line-614"><code>// It is called only if the verb is %v.</code></span>
<span class="codeline" id="line-615"><code>func (s *ss) scanBasePrefix() (base int, digits string, zeroFound bool) {</code></span>
<span class="codeline" id="line-616"><code>	if !s.peek("0") {</code></span>
<span class="codeline" id="line-617"><code>		return 0, decimalDigits + "_", false</code></span>
<span class="codeline" id="line-618"><code>	}</code></span>
<span class="codeline" id="line-619"><code>	s.accept("0")</code></span>
<span class="codeline" id="line-620"><code>	// Special cases for 0, 0b, 0o, 0x.</code></span>
<span class="codeline" id="line-621"><code>	switch {</code></span>
<span class="codeline" id="line-622"><code>	case s.peek("bB"):</code></span>
<span class="codeline" id="line-623"><code>		s.consume("bB", true)</code></span>
<span class="codeline" id="line-624"><code>		return 0, binaryDigits + "_", true</code></span>
<span class="codeline" id="line-625"><code>	case s.peek("oO"):</code></span>
<span class="codeline" id="line-626"><code>		s.consume("oO", true)</code></span>
<span class="codeline" id="line-627"><code>		return 0, octalDigits + "_", true</code></span>
<span class="codeline" id="line-628"><code>	case s.peek("xX"):</code></span>
<span class="codeline" id="line-629"><code>		s.consume("xX", true)</code></span>
<span class="codeline" id="line-630"><code>		return 0, hexadecimalDigits + "_", true</code></span>
<span class="codeline" id="line-631"><code>	default:</code></span>
<span class="codeline" id="line-632"><code>		return 0, octalDigits + "_", true</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>// scanInt returns the value of the integer represented by the next</code></span>
<span class="codeline" id="line-637"><code>// token, checking for overflow. Any error is stored in s.err.</code></span>
<span class="codeline" id="line-638"><code>func (s *ss) scanInt(verb rune, bitSize int) int64 {</code></span>
<span class="codeline" id="line-639"><code>	if verb == 'c' {</code></span>
<span class="codeline" id="line-640"><code>		return s.scanRune(bitSize)</code></span>
<span class="codeline" id="line-641"><code>	}</code></span>
<span class="codeline" id="line-642"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-643"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-644"><code>	base, digits := s.getBase(verb)</code></span>
<span class="codeline" id="line-645"><code>	haveDigits := false</code></span>
<span class="codeline" id="line-646"><code>	if verb == 'U' {</code></span>
<span class="codeline" id="line-647"><code>		if !s.consume("U", false) || !s.consume("+", false) {</code></span>
<span class="codeline" id="line-648"><code>			s.errorString("bad unicode format ")</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>	} else {</code></span>
<span class="codeline" id="line-651"><code>		s.accept(sign) // If there's a sign, it will be left in the token buffer.</code></span>
<span class="codeline" id="line-652"><code>		if verb == 'v' {</code></span>
<span class="codeline" id="line-653"><code>			base, digits, haveDigits = s.scanBasePrefix()</code></span>
<span class="codeline" id="line-654"><code>		}</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code>	tok := s.scanNumber(digits, haveDigits)</code></span>
<span class="codeline" id="line-657"><code>	i, err := strconv.ParseInt(tok, base, 64)</code></span>
<span class="codeline" id="line-658"><code>	if err != nil {</code></span>
<span class="codeline" id="line-659"><code>		s.error(err)</code></span>
<span class="codeline" id="line-660"><code>	}</code></span>
<span class="codeline" id="line-661"><code>	n := uint(bitSize)</code></span>
<span class="codeline" id="line-662"><code>	x := (i &lt;&lt; (64 - n)) &gt;&gt; (64 - n)</code></span>
<span class="codeline" id="line-663"><code>	if x != i {</code></span>
<span class="codeline" id="line-664"><code>		s.errorString("integer overflow on token " + tok)</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>	return i</code></span>
<span class="codeline" id="line-667"><code>}</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>// scanUint returns the value of the unsigned integer represented</code></span>
<span class="codeline" id="line-670"><code>// by the next token, checking for overflow. Any error is stored in s.err.</code></span>
<span class="codeline" id="line-671"><code>func (s *ss) scanUint(verb rune, bitSize int) uint64 {</code></span>
<span class="codeline" id="line-672"><code>	if verb == 'c' {</code></span>
<span class="codeline" id="line-673"><code>		return uint64(s.scanRune(bitSize))</code></span>
<span class="codeline" id="line-674"><code>	}</code></span>
<span class="codeline" id="line-675"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-676"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-677"><code>	base, digits := s.getBase(verb)</code></span>
<span class="codeline" id="line-678"><code>	haveDigits := false</code></span>
<span class="codeline" id="line-679"><code>	if verb == 'U' {</code></span>
<span class="codeline" id="line-680"><code>		if !s.consume("U", false) || !s.consume("+", false) {</code></span>
<span class="codeline" id="line-681"><code>			s.errorString("bad unicode format ")</code></span>
<span class="codeline" id="line-682"><code>		}</code></span>
<span class="codeline" id="line-683"><code>	} else if verb == 'v' {</code></span>
<span class="codeline" id="line-684"><code>		base, digits, haveDigits = s.scanBasePrefix()</code></span>
<span class="codeline" id="line-685"><code>	}</code></span>
<span class="codeline" id="line-686"><code>	tok := s.scanNumber(digits, haveDigits)</code></span>
<span class="codeline" id="line-687"><code>	i, err := strconv.ParseUint(tok, base, 64)</code></span>
<span class="codeline" id="line-688"><code>	if err != nil {</code></span>
<span class="codeline" id="line-689"><code>		s.error(err)</code></span>
<span class="codeline" id="line-690"><code>	}</code></span>
<span class="codeline" id="line-691"><code>	n := uint(bitSize)</code></span>
<span class="codeline" id="line-692"><code>	x := (i &lt;&lt; (64 - n)) &gt;&gt; (64 - n)</code></span>
<span class="codeline" id="line-693"><code>	if x != i {</code></span>
<span class="codeline" id="line-694"><code>		s.errorString("unsigned integer overflow on token " + tok)</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code>	return i</code></span>
<span class="codeline" id="line-697"><code>}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// floatToken returns the floating-point number starting here, no longer than swid</code></span>
<span class="codeline" id="line-700"><code>// if the width is specified. It's not rigorous about syntax because it doesn't check that</code></span>
<span class="codeline" id="line-701"><code>// we have at least some digits, but Atof will do that.</code></span>
<span class="codeline" id="line-702"><code>func (s *ss) floatToken() string {</code></span>
<span class="codeline" id="line-703"><code>	s.buf = s.buf[:0]</code></span>
<span class="codeline" id="line-704"><code>	// NaN?</code></span>
<span class="codeline" id="line-705"><code>	if s.accept("nN") &amp;&amp; s.accept("aA") &amp;&amp; s.accept("nN") {</code></span>
<span class="codeline" id="line-706"><code>		return string(s.buf)</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	// leading sign?</code></span>
<span class="codeline" id="line-709"><code>	s.accept(sign)</code></span>
<span class="codeline" id="line-710"><code>	// Inf?</code></span>
<span class="codeline" id="line-711"><code>	if s.accept("iI") &amp;&amp; s.accept("nN") &amp;&amp; s.accept("fF") {</code></span>
<span class="codeline" id="line-712"><code>		return string(s.buf)</code></span>
<span class="codeline" id="line-713"><code>	}</code></span>
<span class="codeline" id="line-714"><code>	digits := decimalDigits + "_"</code></span>
<span class="codeline" id="line-715"><code>	exp := exponent</code></span>
<span class="codeline" id="line-716"><code>	if s.accept("0") &amp;&amp; s.accept("xX") {</code></span>
<span class="codeline" id="line-717"><code>		digits = hexadecimalDigits + "_"</code></span>
<span class="codeline" id="line-718"><code>		exp = "pP"</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code>	// digits?</code></span>
<span class="codeline" id="line-721"><code>	for s.accept(digits) {</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code>	// decimal point?</code></span>
<span class="codeline" id="line-724"><code>	if s.accept(period) {</code></span>
<span class="codeline" id="line-725"><code>		// fraction?</code></span>
<span class="codeline" id="line-726"><code>		for s.accept(digits) {</code></span>
<span class="codeline" id="line-727"><code>		}</code></span>
<span class="codeline" id="line-728"><code>	}</code></span>
<span class="codeline" id="line-729"><code>	// exponent?</code></span>
<span class="codeline" id="line-730"><code>	if s.accept(exp) {</code></span>
<span class="codeline" id="line-731"><code>		// leading sign?</code></span>
<span class="codeline" id="line-732"><code>		s.accept(sign)</code></span>
<span class="codeline" id="line-733"><code>		// digits?</code></span>
<span class="codeline" id="line-734"><code>		for s.accept(decimalDigits + "_") {</code></span>
<span class="codeline" id="line-735"><code>		}</code></span>
<span class="codeline" id="line-736"><code>	}</code></span>
<span class="codeline" id="line-737"><code>	return string(s.buf)</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>// complexTokens returns the real and imaginary parts of the complex number starting here.</code></span>
<span class="codeline" id="line-741"><code>// The number might be parenthesized and has the format (N+Ni) where N is a floating-point</code></span>
<span class="codeline" id="line-742"><code>// number and there are no spaces within.</code></span>
<span class="codeline" id="line-743"><code>func (s *ss) complexTokens() (real, imag string) {</code></span>
<span class="codeline" id="line-744"><code>	// TODO: accept N and Ni independently?</code></span>
<span class="codeline" id="line-745"><code>	parens := s.accept("(")</code></span>
<span class="codeline" id="line-746"><code>	real = s.floatToken()</code></span>
<span class="codeline" id="line-747"><code>	s.buf = s.buf[:0]</code></span>
<span class="codeline" id="line-748"><code>	// Must now have a sign.</code></span>
<span class="codeline" id="line-749"><code>	if !s.accept("+-") {</code></span>
<span class="codeline" id="line-750"><code>		s.error(complexError)</code></span>
<span class="codeline" id="line-751"><code>	}</code></span>
<span class="codeline" id="line-752"><code>	// Sign is now in buffer</code></span>
<span class="codeline" id="line-753"><code>	imagSign := string(s.buf)</code></span>
<span class="codeline" id="line-754"><code>	imag = s.floatToken()</code></span>
<span class="codeline" id="line-755"><code>	if !s.accept("i") {</code></span>
<span class="codeline" id="line-756"><code>		s.error(complexError)</code></span>
<span class="codeline" id="line-757"><code>	}</code></span>
<span class="codeline" id="line-758"><code>	if parens &amp;&amp; !s.accept(")") {</code></span>
<span class="codeline" id="line-759"><code>		s.error(complexError)</code></span>
<span class="codeline" id="line-760"><code>	}</code></span>
<span class="codeline" id="line-761"><code>	return real, imagSign + imag</code></span>
<span class="codeline" id="line-762"><code>}</code></span>
<span class="codeline" id="line-763"><code></code></span>
<span class="codeline" id="line-764"><code>func hasX(s string) bool {</code></span>
<span class="codeline" id="line-765"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-766"><code>		if s[i] == 'x' || s[i] == 'X' {</code></span>
<span class="codeline" id="line-767"><code>			return true</code></span>
<span class="codeline" id="line-768"><code>		}</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code>	return false</code></span>
<span class="codeline" id="line-771"><code>}</code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>// convertFloat converts the string to a float64value.</code></span>
<span class="codeline" id="line-774"><code>func (s *ss) convertFloat(str string, n int) float64 {</code></span>
<span class="codeline" id="line-775"><code>	// strconv.ParseFloat will handle "+0x1.fp+2",</code></span>
<span class="codeline" id="line-776"><code>	// but we have to implement our non-standard</code></span>
<span class="codeline" id="line-777"><code>	// decimal+binary exponent mix (1.2p4) ourselves.</code></span>
<span class="codeline" id="line-778"><code>	if p := indexRune(str, 'p'); p &gt;= 0 &amp;&amp; !hasX(str) {</code></span>
<span class="codeline" id="line-779"><code>		// Atof doesn't handle power-of-2 exponents,</code></span>
<span class="codeline" id="line-780"><code>		// but they're easy to evaluate.</code></span>
<span class="codeline" id="line-781"><code>		f, err := strconv.ParseFloat(str[:p], n)</code></span>
<span class="codeline" id="line-782"><code>		if err != nil {</code></span>
<span class="codeline" id="line-783"><code>			// Put full string into error.</code></span>
<span class="codeline" id="line-784"><code>			if e, ok := err.(*strconv.NumError); ok {</code></span>
<span class="codeline" id="line-785"><code>				e.Num = str</code></span>
<span class="codeline" id="line-786"><code>			}</code></span>
<span class="codeline" id="line-787"><code>			s.error(err)</code></span>
<span class="codeline" id="line-788"><code>		}</code></span>
<span class="codeline" id="line-789"><code>		m, err := strconv.Atoi(str[p+1:])</code></span>
<span class="codeline" id="line-790"><code>		if err != nil {</code></span>
<span class="codeline" id="line-791"><code>			// Put full string into error.</code></span>
<span class="codeline" id="line-792"><code>			if e, ok := err.(*strconv.NumError); ok {</code></span>
<span class="codeline" id="line-793"><code>				e.Num = str</code></span>
<span class="codeline" id="line-794"><code>			}</code></span>
<span class="codeline" id="line-795"><code>			s.error(err)</code></span>
<span class="codeline" id="line-796"><code>		}</code></span>
<span class="codeline" id="line-797"><code>		return math.Ldexp(f, m)</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code>	f, err := strconv.ParseFloat(str, n)</code></span>
<span class="codeline" id="line-800"><code>	if err != nil {</code></span>
<span class="codeline" id="line-801"><code>		s.error(err)</code></span>
<span class="codeline" id="line-802"><code>	}</code></span>
<span class="codeline" id="line-803"><code>	return f</code></span>
<span class="codeline" id="line-804"><code>}</code></span>
<span class="codeline" id="line-805"><code></code></span>
<span class="codeline" id="line-806"><code>// convertComplex converts the next token to a complex128 value.</code></span>
<span class="codeline" id="line-807"><code>// The atof argument is a type-specific reader for the underlying type.</code></span>
<span class="codeline" id="line-808"><code>// If we're reading complex64, atof will parse float32s and convert them</code></span>
<span class="codeline" id="line-809"><code>// to float64's to avoid reproducing this code for each complex type.</code></span>
<span class="codeline" id="line-810"><code>func (s *ss) scanComplex(verb rune, n int) complex128 {</code></span>
<span class="codeline" id="line-811"><code>	if !s.okVerb(verb, floatVerbs, "complex") {</code></span>
<span class="codeline" id="line-812"><code>		return 0</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-815"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-816"><code>	sreal, simag := s.complexTokens()</code></span>
<span class="codeline" id="line-817"><code>	real := s.convertFloat(sreal, n/2)</code></span>
<span class="codeline" id="line-818"><code>	imag := s.convertFloat(simag, n/2)</code></span>
<span class="codeline" id="line-819"><code>	return complex(real, imag)</code></span>
<span class="codeline" id="line-820"><code>}</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>// convertString returns the string represented by the next input characters.</code></span>
<span class="codeline" id="line-823"><code>// The format of the input is determined by the verb.</code></span>
<span class="codeline" id="line-824"><code>func (s *ss) convertString(verb rune) (str string) {</code></span>
<span class="codeline" id="line-825"><code>	if !s.okVerb(verb, "svqxX", "string") {</code></span>
<span class="codeline" id="line-826"><code>		return ""</code></span>
<span class="codeline" id="line-827"><code>	}</code></span>
<span class="codeline" id="line-828"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-829"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-830"><code>	switch verb {</code></span>
<span class="codeline" id="line-831"><code>	case 'q':</code></span>
<span class="codeline" id="line-832"><code>		str = s.quotedString()</code></span>
<span class="codeline" id="line-833"><code>	case 'x', 'X':</code></span>
<span class="codeline" id="line-834"><code>		str = s.hexString()</code></span>
<span class="codeline" id="line-835"><code>	default:</code></span>
<span class="codeline" id="line-836"><code>		str = string(s.token(true, notSpace)) // %s and %v just return the next word</code></span>
<span class="codeline" id="line-837"><code>	}</code></span>
<span class="codeline" id="line-838"><code>	return</code></span>
<span class="codeline" id="line-839"><code>}</code></span>
<span class="codeline" id="line-840"><code></code></span>
<span class="codeline" id="line-841"><code>// quotedString returns the double- or back-quoted string represented by the next input characters.</code></span>
<span class="codeline" id="line-842"><code>func (s *ss) quotedString() string {</code></span>
<span class="codeline" id="line-843"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-844"><code>	quote := s.getRune()</code></span>
<span class="codeline" id="line-845"><code>	switch quote {</code></span>
<span class="codeline" id="line-846"><code>	case '`':</code></span>
<span class="codeline" id="line-847"><code>		// Back-quoted: Anything goes until EOF or back quote.</code></span>
<span class="codeline" id="line-848"><code>		for {</code></span>
<span class="codeline" id="line-849"><code>			r := s.mustReadRune()</code></span>
<span class="codeline" id="line-850"><code>			if r == quote {</code></span>
<span class="codeline" id="line-851"><code>				break</code></span>
<span class="codeline" id="line-852"><code>			}</code></span>
<span class="codeline" id="line-853"><code>			s.buf.writeRune(r)</code></span>
<span class="codeline" id="line-854"><code>		}</code></span>
<span class="codeline" id="line-855"><code>		return string(s.buf)</code></span>
<span class="codeline" id="line-856"><code>	case '"':</code></span>
<span class="codeline" id="line-857"><code>		// Double-quoted: Include the quotes and let strconv.Unquote do the backslash escapes.</code></span>
<span class="codeline" id="line-858"><code>		s.buf.writeByte('"')</code></span>
<span class="codeline" id="line-859"><code>		for {</code></span>
<span class="codeline" id="line-860"><code>			r := s.mustReadRune()</code></span>
<span class="codeline" id="line-861"><code>			s.buf.writeRune(r)</code></span>
<span class="codeline" id="line-862"><code>			if r == '\\' {</code></span>
<span class="codeline" id="line-863"><code>				// In a legal backslash escape, no matter how long, only the character</code></span>
<span class="codeline" id="line-864"><code>				// immediately after the escape can itself be a backslash or quote.</code></span>
<span class="codeline" id="line-865"><code>				// Thus we only need to protect the first character after the backslash.</code></span>
<span class="codeline" id="line-866"><code>				s.buf.writeRune(s.mustReadRune())</code></span>
<span class="codeline" id="line-867"><code>			} else if r == '"' {</code></span>
<span class="codeline" id="line-868"><code>				break</code></span>
<span class="codeline" id="line-869"><code>			}</code></span>
<span class="codeline" id="line-870"><code>		}</code></span>
<span class="codeline" id="line-871"><code>		result, err := strconv.Unquote(string(s.buf))</code></span>
<span class="codeline" id="line-872"><code>		if err != nil {</code></span>
<span class="codeline" id="line-873"><code>			s.error(err)</code></span>
<span class="codeline" id="line-874"><code>		}</code></span>
<span class="codeline" id="line-875"><code>		return result</code></span>
<span class="codeline" id="line-876"><code>	default:</code></span>
<span class="codeline" id="line-877"><code>		s.errorString("expected quoted string")</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code>	return ""</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>// hexDigit returns the value of the hexadecimal digit.</code></span>
<span class="codeline" id="line-883"><code>func hexDigit(d rune) (int, bool) {</code></span>
<span class="codeline" id="line-884"><code>	digit := int(d)</code></span>
<span class="codeline" id="line-885"><code>	switch digit {</code></span>
<span class="codeline" id="line-886"><code>	case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':</code></span>
<span class="codeline" id="line-887"><code>		return digit - '0', true</code></span>
<span class="codeline" id="line-888"><code>	case 'a', 'b', 'c', 'd', 'e', 'f':</code></span>
<span class="codeline" id="line-889"><code>		return 10 + digit - 'a', true</code></span>
<span class="codeline" id="line-890"><code>	case 'A', 'B', 'C', 'D', 'E', 'F':</code></span>
<span class="codeline" id="line-891"><code>		return 10 + digit - 'A', true</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code>	return -1, false</code></span>
<span class="codeline" id="line-894"><code>}</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>// hexByte returns the next hex-encoded (two-character) byte from the input.</code></span>
<span class="codeline" id="line-897"><code>// It returns ok==false if the next bytes in the input do not encode a hex byte.</code></span>
<span class="codeline" id="line-898"><code>// If the first byte is hex and the second is not, processing stops.</code></span>
<span class="codeline" id="line-899"><code>func (s *ss) hexByte() (b byte, ok bool) {</code></span>
<span class="codeline" id="line-900"><code>	rune1 := s.getRune()</code></span>
<span class="codeline" id="line-901"><code>	if rune1 == eof {</code></span>
<span class="codeline" id="line-902"><code>		return</code></span>
<span class="codeline" id="line-903"><code>	}</code></span>
<span class="codeline" id="line-904"><code>	value1, ok := hexDigit(rune1)</code></span>
<span class="codeline" id="line-905"><code>	if !ok {</code></span>
<span class="codeline" id="line-906"><code>		s.UnreadRune()</code></span>
<span class="codeline" id="line-907"><code>		return</code></span>
<span class="codeline" id="line-908"><code>	}</code></span>
<span class="codeline" id="line-909"><code>	value2, ok := hexDigit(s.mustReadRune())</code></span>
<span class="codeline" id="line-910"><code>	if !ok {</code></span>
<span class="codeline" id="line-911"><code>		s.errorString("illegal hex digit")</code></span>
<span class="codeline" id="line-912"><code>		return</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code>	return byte(value1&lt;&lt;4 | value2), true</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>// hexString returns the space-delimited hexpair-encoded string.</code></span>
<span class="codeline" id="line-918"><code>func (s *ss) hexString() string {</code></span>
<span class="codeline" id="line-919"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-920"><code>	for {</code></span>
<span class="codeline" id="line-921"><code>		b, ok := s.hexByte()</code></span>
<span class="codeline" id="line-922"><code>		if !ok {</code></span>
<span class="codeline" id="line-923"><code>			break</code></span>
<span class="codeline" id="line-924"><code>		}</code></span>
<span class="codeline" id="line-925"><code>		s.buf.writeByte(b)</code></span>
<span class="codeline" id="line-926"><code>	}</code></span>
<span class="codeline" id="line-927"><code>	if len(s.buf) == 0 {</code></span>
<span class="codeline" id="line-928"><code>		s.errorString("no hex data for %x string")</code></span>
<span class="codeline" id="line-929"><code>		return ""</code></span>
<span class="codeline" id="line-930"><code>	}</code></span>
<span class="codeline" id="line-931"><code>	return string(s.buf)</code></span>
<span class="codeline" id="line-932"><code>}</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>const (</code></span>
<span class="codeline" id="line-935"><code>	floatVerbs = "beEfFgGv"</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>	hugeWid = 1 &lt;&lt; 30</code></span>
<span class="codeline" id="line-938"><code></code></span>
<span class="codeline" id="line-939"><code>	intBits     = 32 &lt;&lt; (^uint(0) &gt;&gt; 63)</code></span>
<span class="codeline" id="line-940"><code>	uintptrBits = 32 &lt;&lt; (^uintptr(0) &gt;&gt; 63)</code></span>
<span class="codeline" id="line-941"><code>)</code></span>
<span class="codeline" id="line-942"><code></code></span>
<span class="codeline" id="line-943"><code>// scanPercent scans a literal percent character.</code></span>
<span class="codeline" id="line-944"><code>func (s *ss) scanPercent() {</code></span>
<span class="codeline" id="line-945"><code>	s.SkipSpace()</code></span>
<span class="codeline" id="line-946"><code>	s.notEOF()</code></span>
<span class="codeline" id="line-947"><code>	if !s.accept("%") {</code></span>
<span class="codeline" id="line-948"><code>		s.errorString("missing literal %")</code></span>
<span class="codeline" id="line-949"><code>	}</code></span>
<span class="codeline" id="line-950"><code>}</code></span>
<span class="codeline" id="line-951"><code></code></span>
<span class="codeline" id="line-952"><code>// scanOne scans a single value, deriving the scanner from the type of the argument.</code></span>
<span class="codeline" id="line-953"><code>func (s *ss) scanOne(verb rune, arg interface{}) {</code></span>
<span class="codeline" id="line-954"><code>	s.buf = s.buf[:0]</code></span>
<span class="codeline" id="line-955"><code>	var err error</code></span>
<span class="codeline" id="line-956"><code>	// If the parameter has its own Scan method, use that.</code></span>
<span class="codeline" id="line-957"><code>	if v, ok := arg.(Scanner); ok {</code></span>
<span class="codeline" id="line-958"><code>		err = v.Scan(s, verb)</code></span>
<span class="codeline" id="line-959"><code>		if err != nil {</code></span>
<span class="codeline" id="line-960"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-961"><code>				err = io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-962"><code>			}</code></span>
<span class="codeline" id="line-963"><code>			s.error(err)</code></span>
<span class="codeline" id="line-964"><code>		}</code></span>
<span class="codeline" id="line-965"><code>		return</code></span>
<span class="codeline" id="line-966"><code>	}</code></span>
<span class="codeline" id="line-967"><code></code></span>
<span class="codeline" id="line-968"><code>	switch v := arg.(type) {</code></span>
<span class="codeline" id="line-969"><code>	case *bool:</code></span>
<span class="codeline" id="line-970"><code>		*v = s.scanBool(verb)</code></span>
<span class="codeline" id="line-971"><code>	case *complex64:</code></span>
<span class="codeline" id="line-972"><code>		*v = complex64(s.scanComplex(verb, 64))</code></span>
<span class="codeline" id="line-973"><code>	case *complex128:</code></span>
<span class="codeline" id="line-974"><code>		*v = s.scanComplex(verb, 128)</code></span>
<span class="codeline" id="line-975"><code>	case *int:</code></span>
<span class="codeline" id="line-976"><code>		*v = int(s.scanInt(verb, intBits))</code></span>
<span class="codeline" id="line-977"><code>	case *int8:</code></span>
<span class="codeline" id="line-978"><code>		*v = int8(s.scanInt(verb, 8))</code></span>
<span class="codeline" id="line-979"><code>	case *int16:</code></span>
<span class="codeline" id="line-980"><code>		*v = int16(s.scanInt(verb, 16))</code></span>
<span class="codeline" id="line-981"><code>	case *int32:</code></span>
<span class="codeline" id="line-982"><code>		*v = int32(s.scanInt(verb, 32))</code></span>
<span class="codeline" id="line-983"><code>	case *int64:</code></span>
<span class="codeline" id="line-984"><code>		*v = s.scanInt(verb, 64)</code></span>
<span class="codeline" id="line-985"><code>	case *uint:</code></span>
<span class="codeline" id="line-986"><code>		*v = uint(s.scanUint(verb, intBits))</code></span>
<span class="codeline" id="line-987"><code>	case *uint8:</code></span>
<span class="codeline" id="line-988"><code>		*v = uint8(s.scanUint(verb, 8))</code></span>
<span class="codeline" id="line-989"><code>	case *uint16:</code></span>
<span class="codeline" id="line-990"><code>		*v = uint16(s.scanUint(verb, 16))</code></span>
<span class="codeline" id="line-991"><code>	case *uint32:</code></span>
<span class="codeline" id="line-992"><code>		*v = uint32(s.scanUint(verb, 32))</code></span>
<span class="codeline" id="line-993"><code>	case *uint64:</code></span>
<span class="codeline" id="line-994"><code>		*v = s.scanUint(verb, 64)</code></span>
<span class="codeline" id="line-995"><code>	case *uintptr:</code></span>
<span class="codeline" id="line-996"><code>		*v = uintptr(s.scanUint(verb, uintptrBits))</code></span>
<span class="codeline" id="line-997"><code>	// Floats are tricky because you want to scan in the precision of the result, not</code></span>
<span class="codeline" id="line-998"><code>	// scan in high precision and convert, in order to preserve the correct error condition.</code></span>
<span class="codeline" id="line-999"><code>	case *float32:</code></span>
<span class="codeline" id="line-1000"><code>		if s.okVerb(verb, floatVerbs, "float32") {</code></span>
<span class="codeline" id="line-1001"><code>			s.SkipSpace()</code></span>
<span class="codeline" id="line-1002"><code>			s.notEOF()</code></span>
<span class="codeline" id="line-1003"><code>			*v = float32(s.convertFloat(s.floatToken(), 32))</code></span>
<span class="codeline" id="line-1004"><code>		}</code></span>
<span class="codeline" id="line-1005"><code>	case *float64:</code></span>
<span class="codeline" id="line-1006"><code>		if s.okVerb(verb, floatVerbs, "float64") {</code></span>
<span class="codeline" id="line-1007"><code>			s.SkipSpace()</code></span>
<span class="codeline" id="line-1008"><code>			s.notEOF()</code></span>
<span class="codeline" id="line-1009"><code>			*v = s.convertFloat(s.floatToken(), 64)</code></span>
<span class="codeline" id="line-1010"><code>		}</code></span>
<span class="codeline" id="line-1011"><code>	case *string:</code></span>
<span class="codeline" id="line-1012"><code>		*v = s.convertString(verb)</code></span>
<span class="codeline" id="line-1013"><code>	case *[]byte:</code></span>
<span class="codeline" id="line-1014"><code>		// We scan to string and convert so we get a copy of the data.</code></span>
<span class="codeline" id="line-1015"><code>		// If we scanned to bytes, the slice would point at the buffer.</code></span>
<span class="codeline" id="line-1016"><code>		*v = []byte(s.convertString(verb))</code></span>
<span class="codeline" id="line-1017"><code>	default:</code></span>
<span class="codeline" id="line-1018"><code>		val := reflect.ValueOf(v)</code></span>
<span class="codeline" id="line-1019"><code>		ptr := val</code></span>
<span class="codeline" id="line-1020"><code>		if ptr.Kind() != reflect.Ptr {</code></span>
<span class="codeline" id="line-1021"><code>			s.errorString("type not a pointer: " + val.Type().String())</code></span>
<span class="codeline" id="line-1022"><code>			return</code></span>
<span class="codeline" id="line-1023"><code>		}</code></span>
<span class="codeline" id="line-1024"><code>		switch v := ptr.Elem(); v.Kind() {</code></span>
<span class="codeline" id="line-1025"><code>		case reflect.Bool:</code></span>
<span class="codeline" id="line-1026"><code>			v.SetBool(s.scanBool(verb))</code></span>
<span class="codeline" id="line-1027"><code>		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-1028"><code>			v.SetInt(s.scanInt(verb, v.Type().Bits()))</code></span>
<span class="codeline" id="line-1029"><code>		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-1030"><code>			v.SetUint(s.scanUint(verb, v.Type().Bits()))</code></span>
<span class="codeline" id="line-1031"><code>		case reflect.String:</code></span>
<span class="codeline" id="line-1032"><code>			v.SetString(s.convertString(verb))</code></span>
<span class="codeline" id="line-1033"><code>		case reflect.Slice:</code></span>
<span class="codeline" id="line-1034"><code>			// For now, can only handle (renamed) []byte.</code></span>
<span class="codeline" id="line-1035"><code>			typ := v.Type()</code></span>
<span class="codeline" id="line-1036"><code>			if typ.Elem().Kind() != reflect.Uint8 {</code></span>
<span class="codeline" id="line-1037"><code>				s.errorString("can't scan type: " + val.Type().String())</code></span>
<span class="codeline" id="line-1038"><code>			}</code></span>
<span class="codeline" id="line-1039"><code>			str := s.convertString(verb)</code></span>
<span class="codeline" id="line-1040"><code>			v.Set(reflect.MakeSlice(typ, len(str), len(str)))</code></span>
<span class="codeline" id="line-1041"><code>			for i := 0; i &lt; len(str); i++ {</code></span>
<span class="codeline" id="line-1042"><code>				v.Index(i).SetUint(uint64(str[i]))</code></span>
<span class="codeline" id="line-1043"><code>			}</code></span>
<span class="codeline" id="line-1044"><code>		case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-1045"><code>			s.SkipSpace()</code></span>
<span class="codeline" id="line-1046"><code>			s.notEOF()</code></span>
<span class="codeline" id="line-1047"><code>			v.SetFloat(s.convertFloat(s.floatToken(), v.Type().Bits()))</code></span>
<span class="codeline" id="line-1048"><code>		case reflect.Complex64, reflect.Complex128:</code></span>
<span class="codeline" id="line-1049"><code>			v.SetComplex(s.scanComplex(verb, v.Type().Bits()))</code></span>
<span class="codeline" id="line-1050"><code>		default:</code></span>
<span class="codeline" id="line-1051"><code>			s.errorString("can't scan type: " + val.Type().String())</code></span>
<span class="codeline" id="line-1052"><code>		}</code></span>
<span class="codeline" id="line-1053"><code>	}</code></span>
<span class="codeline" id="line-1054"><code>}</code></span>
<span class="codeline" id="line-1055"><code></code></span>
<span class="codeline" id="line-1056"><code>// errorHandler turns local panics into error returns.</code></span>
<span class="codeline" id="line-1057"><code>func errorHandler(errp *error) {</code></span>
<span class="codeline" id="line-1058"><code>	if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-1059"><code>		if se, ok := e.(scanError); ok { // catch local error</code></span>
<span class="codeline" id="line-1060"><code>			*errp = se.err</code></span>
<span class="codeline" id="line-1061"><code>		} else if eof, ok := e.(error); ok &amp;&amp; eof == io.EOF { // out of input</code></span>
<span class="codeline" id="line-1062"><code>			*errp = eof</code></span>
<span class="codeline" id="line-1063"><code>		} else {</code></span>
<span class="codeline" id="line-1064"><code>			panic(e)</code></span>
<span class="codeline" id="line-1065"><code>		}</code></span>
<span class="codeline" id="line-1066"><code>	}</code></span>
<span class="codeline" id="line-1067"><code>}</code></span>
<span class="codeline" id="line-1068"><code></code></span>
<span class="codeline" id="line-1069"><code>// doScan does the real work for scanning without a format string.</code></span>
<span class="codeline" id="line-1070"><code>func (s *ss) doScan(a []interface{}) (numProcessed int, err error) {</code></span>
<span class="codeline" id="line-1071"><code>	defer errorHandler(&amp;err)</code></span>
<span class="codeline" id="line-1072"><code>	for _, arg := range a {</code></span>
<span class="codeline" id="line-1073"><code>		s.scanOne('v', arg)</code></span>
<span class="codeline" id="line-1074"><code>		numProcessed++</code></span>
<span class="codeline" id="line-1075"><code>	}</code></span>
<span class="codeline" id="line-1076"><code>	// Check for newline (or EOF) if required (Scanln etc.).</code></span>
<span class="codeline" id="line-1077"><code>	if s.nlIsEnd {</code></span>
<span class="codeline" id="line-1078"><code>		for {</code></span>
<span class="codeline" id="line-1079"><code>			r := s.getRune()</code></span>
<span class="codeline" id="line-1080"><code>			if r == '\n' || r == eof {</code></span>
<span class="codeline" id="line-1081"><code>				break</code></span>
<span class="codeline" id="line-1082"><code>			}</code></span>
<span class="codeline" id="line-1083"><code>			if !isSpace(r) {</code></span>
<span class="codeline" id="line-1084"><code>				s.errorString("expected newline")</code></span>
<span class="codeline" id="line-1085"><code>				break</code></span>
<span class="codeline" id="line-1086"><code>			}</code></span>
<span class="codeline" id="line-1087"><code>		}</code></span>
<span class="codeline" id="line-1088"><code>	}</code></span>
<span class="codeline" id="line-1089"><code>	return</code></span>
<span class="codeline" id="line-1090"><code>}</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>// advance determines whether the next characters in the input match</code></span>
<span class="codeline" id="line-1093"><code>// those of the format. It returns the number of bytes (sic) consumed</code></span>
<span class="codeline" id="line-1094"><code>// in the format. All runs of space characters in either input or</code></span>
<span class="codeline" id="line-1095"><code>// format behave as a single space. Newlines are special, though:</code></span>
<span class="codeline" id="line-1096"><code>// newlines in the format must match those in the input and vice versa.</code></span>
<span class="codeline" id="line-1097"><code>// This routine also handles the %% case. If the return value is zero,</code></span>
<span class="codeline" id="line-1098"><code>// either format starts with a % (with no following %) or the input</code></span>
<span class="codeline" id="line-1099"><code>// is empty. If it is negative, the input did not match the string.</code></span>
<span class="codeline" id="line-1100"><code>func (s *ss) advance(format string) (i int) {</code></span>
<span class="codeline" id="line-1101"><code>	for i &lt; len(format) {</code></span>
<span class="codeline" id="line-1102"><code>		fmtc, w := utf8.DecodeRuneInString(format[i:])</code></span>
<span class="codeline" id="line-1103"><code></code></span>
<span class="codeline" id="line-1104"><code>		// Space processing.</code></span>
<span class="codeline" id="line-1105"><code>		// In the rest of this comment "space" means spaces other than newline.</code></span>
<span class="codeline" id="line-1106"><code>		// Newline in the format matches input of zero or more spaces and then newline or end-of-input.</code></span>
<span class="codeline" id="line-1107"><code>		// Spaces in the format before the newline are collapsed into the newline.</code></span>
<span class="codeline" id="line-1108"><code>		// Spaces in the format after the newline match zero or more spaces after the corresponding input newline.</code></span>
<span class="codeline" id="line-1109"><code>		// Other spaces in the format match input of one or more spaces or end-of-input.</code></span>
<span class="codeline" id="line-1110"><code>		if isSpace(fmtc) {</code></span>
<span class="codeline" id="line-1111"><code>			newlines := 0</code></span>
<span class="codeline" id="line-1112"><code>			trailingSpace := false</code></span>
<span class="codeline" id="line-1113"><code>			for isSpace(fmtc) &amp;&amp; i &lt; len(format) {</code></span>
<span class="codeline" id="line-1114"><code>				if fmtc == '\n' {</code></span>
<span class="codeline" id="line-1115"><code>					newlines++</code></span>
<span class="codeline" id="line-1116"><code>					trailingSpace = false</code></span>
<span class="codeline" id="line-1117"><code>				} else {</code></span>
<span class="codeline" id="line-1118"><code>					trailingSpace = true</code></span>
<span class="codeline" id="line-1119"><code>				}</code></span>
<span class="codeline" id="line-1120"><code>				i += w</code></span>
<span class="codeline" id="line-1121"><code>				fmtc, w = utf8.DecodeRuneInString(format[i:])</code></span>
<span class="codeline" id="line-1122"><code>			}</code></span>
<span class="codeline" id="line-1123"><code>			for j := 0; j &lt; newlines; j++ {</code></span>
<span class="codeline" id="line-1124"><code>				inputc := s.getRune()</code></span>
<span class="codeline" id="line-1125"><code>				for isSpace(inputc) &amp;&amp; inputc != '\n' {</code></span>
<span class="codeline" id="line-1126"><code>					inputc = s.getRune()</code></span>
<span class="codeline" id="line-1127"><code>				}</code></span>
<span class="codeline" id="line-1128"><code>				if inputc != '\n' &amp;&amp; inputc != eof {</code></span>
<span class="codeline" id="line-1129"><code>					s.errorString("newline in format does not match input")</code></span>
<span class="codeline" id="line-1130"><code>				}</code></span>
<span class="codeline" id="line-1131"><code>			}</code></span>
<span class="codeline" id="line-1132"><code>			if trailingSpace {</code></span>
<span class="codeline" id="line-1133"><code>				inputc := s.getRune()</code></span>
<span class="codeline" id="line-1134"><code>				if newlines == 0 {</code></span>
<span class="codeline" id="line-1135"><code>					// If the trailing space stood alone (did not follow a newline),</code></span>
<span class="codeline" id="line-1136"><code>					// it must find at least one space to consume.</code></span>
<span class="codeline" id="line-1137"><code>					if !isSpace(inputc) &amp;&amp; inputc != eof {</code></span>
<span class="codeline" id="line-1138"><code>						s.errorString("expected space in input to match format")</code></span>
<span class="codeline" id="line-1139"><code>					}</code></span>
<span class="codeline" id="line-1140"><code>					if inputc == '\n' {</code></span>
<span class="codeline" id="line-1141"><code>						s.errorString("newline in input does not match format")</code></span>
<span class="codeline" id="line-1142"><code>					}</code></span>
<span class="codeline" id="line-1143"><code>				}</code></span>
<span class="codeline" id="line-1144"><code>				for isSpace(inputc) &amp;&amp; inputc != '\n' {</code></span>
<span class="codeline" id="line-1145"><code>					inputc = s.getRune()</code></span>
<span class="codeline" id="line-1146"><code>				}</code></span>
<span class="codeline" id="line-1147"><code>				if inputc != eof {</code></span>
<span class="codeline" id="line-1148"><code>					s.UnreadRune()</code></span>
<span class="codeline" id="line-1149"><code>				}</code></span>
<span class="codeline" id="line-1150"><code>			}</code></span>
<span class="codeline" id="line-1151"><code>			continue</code></span>
<span class="codeline" id="line-1152"><code>		}</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>		// Verbs.</code></span>
<span class="codeline" id="line-1155"><code>		if fmtc == '%' {</code></span>
<span class="codeline" id="line-1156"><code>			// % at end of string is an error.</code></span>
<span class="codeline" id="line-1157"><code>			if i+w == len(format) {</code></span>
<span class="codeline" id="line-1158"><code>				s.errorString("missing verb: % at end of format string")</code></span>
<span class="codeline" id="line-1159"><code>			}</code></span>
<span class="codeline" id="line-1160"><code>			// %% acts like a real percent</code></span>
<span class="codeline" id="line-1161"><code>			nextc, _ := utf8.DecodeRuneInString(format[i+w:]) // will not match % if string is empty</code></span>
<span class="codeline" id="line-1162"><code>			if nextc != '%' {</code></span>
<span class="codeline" id="line-1163"><code>				return</code></span>
<span class="codeline" id="line-1164"><code>			}</code></span>
<span class="codeline" id="line-1165"><code>			i += w // skip the first %</code></span>
<span class="codeline" id="line-1166"><code>		}</code></span>
<span class="codeline" id="line-1167"><code></code></span>
<span class="codeline" id="line-1168"><code>		// Literals.</code></span>
<span class="codeline" id="line-1169"><code>		inputc := s.mustReadRune()</code></span>
<span class="codeline" id="line-1170"><code>		if fmtc != inputc {</code></span>
<span class="codeline" id="line-1171"><code>			s.UnreadRune()</code></span>
<span class="codeline" id="line-1172"><code>			return -1</code></span>
<span class="codeline" id="line-1173"><code>		}</code></span>
<span class="codeline" id="line-1174"><code>		i += w</code></span>
<span class="codeline" id="line-1175"><code>	}</code></span>
<span class="codeline" id="line-1176"><code>	return</code></span>
<span class="codeline" id="line-1177"><code>}</code></span>
<span class="codeline" id="line-1178"><code></code></span>
<span class="codeline" id="line-1179"><code>// doScanf does the real work when scanning with a format string.</code></span>
<span class="codeline" id="line-1180"><code>// At the moment, it handles only pointers to basic types.</code></span>
<span class="codeline" id="line-1181"><code>func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err error) {</code></span>
<span class="codeline" id="line-1182"><code>	defer errorHandler(&amp;err)</code></span>
<span class="codeline" id="line-1183"><code>	end := len(format) - 1</code></span>
<span class="codeline" id="line-1184"><code>	// We process one item per non-trivial format</code></span>
<span class="codeline" id="line-1185"><code>	for i := 0; i &lt;= end; {</code></span>
<span class="codeline" id="line-1186"><code>		w := s.advance(format[i:])</code></span>
<span class="codeline" id="line-1187"><code>		if w &gt; 0 {</code></span>
<span class="codeline" id="line-1188"><code>			i += w</code></span>
<span class="codeline" id="line-1189"><code>			continue</code></span>
<span class="codeline" id="line-1190"><code>		}</code></span>
<span class="codeline" id="line-1191"><code>		// Either we failed to advance, we have a percent character, or we ran out of input.</code></span>
<span class="codeline" id="line-1192"><code>		if format[i] != '%' {</code></span>
<span class="codeline" id="line-1193"><code>			// Can't advance format. Why not?</code></span>
<span class="codeline" id="line-1194"><code>			if w &lt; 0 {</code></span>
<span class="codeline" id="line-1195"><code>				s.errorString("input does not match format")</code></span>
<span class="codeline" id="line-1196"><code>			}</code></span>
<span class="codeline" id="line-1197"><code>			// Otherwise at EOF; "too many operands" error handled below</code></span>
<span class="codeline" id="line-1198"><code>			break</code></span>
<span class="codeline" id="line-1199"><code>		}</code></span>
<span class="codeline" id="line-1200"><code>		i++ // % is one byte</code></span>
<span class="codeline" id="line-1201"><code></code></span>
<span class="codeline" id="line-1202"><code>		// do we have 20 (width)?</code></span>
<span class="codeline" id="line-1203"><code>		var widPresent bool</code></span>
<span class="codeline" id="line-1204"><code>		s.maxWid, widPresent, i = parsenum(format, i, end)</code></span>
<span class="codeline" id="line-1205"><code>		if !widPresent {</code></span>
<span class="codeline" id="line-1206"><code>			s.maxWid = hugeWid</code></span>
<span class="codeline" id="line-1207"><code>		}</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>		c, w := utf8.DecodeRuneInString(format[i:])</code></span>
<span class="codeline" id="line-1210"><code>		i += w</code></span>
<span class="codeline" id="line-1211"><code></code></span>
<span class="codeline" id="line-1212"><code>		if c != 'c' {</code></span>
<span class="codeline" id="line-1213"><code>			s.SkipSpace()</code></span>
<span class="codeline" id="line-1214"><code>		}</code></span>
<span class="codeline" id="line-1215"><code>		if c == '%' {</code></span>
<span class="codeline" id="line-1216"><code>			s.scanPercent()</code></span>
<span class="codeline" id="line-1217"><code>			continue // Do not consume an argument.</code></span>
<span class="codeline" id="line-1218"><code>		}</code></span>
<span class="codeline" id="line-1219"><code>		s.argLimit = s.limit</code></span>
<span class="codeline" id="line-1220"><code>		if f := s.count + s.maxWid; f &lt; s.argLimit {</code></span>
<span class="codeline" id="line-1221"><code>			s.argLimit = f</code></span>
<span class="codeline" id="line-1222"><code>		}</code></span>
<span class="codeline" id="line-1223"><code></code></span>
<span class="codeline" id="line-1224"><code>		if numProcessed &gt;= len(a) { // out of operands</code></span>
<span class="codeline" id="line-1225"><code>			s.errorString("too few operands for format '%" + format[i-w:] + "'")</code></span>
<span class="codeline" id="line-1226"><code>			break</code></span>
<span class="codeline" id="line-1227"><code>		}</code></span>
<span class="codeline" id="line-1228"><code>		arg := a[numProcessed]</code></span>
<span class="codeline" id="line-1229"><code></code></span>
<span class="codeline" id="line-1230"><code>		s.scanOne(c, arg)</code></span>
<span class="codeline" id="line-1231"><code>		numProcessed++</code></span>
<span class="codeline" id="line-1232"><code>		s.argLimit = s.limit</code></span>
<span class="codeline" id="line-1233"><code>	}</code></span>
<span class="codeline" id="line-1234"><code>	if numProcessed &lt; len(a) {</code></span>
<span class="codeline" id="line-1235"><code>		s.errorString("too many operands")</code></span>
<span class="codeline" id="line-1236"><code>	}</code></span>
<span class="codeline" id="line-1237"><code>	return</code></span>
<span class="codeline" id="line-1238"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>