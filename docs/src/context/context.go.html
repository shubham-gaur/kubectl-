<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: context.go in package context</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	context.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/context.html">context</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package context defines the Context type, which carries deadlines,</code></span>
<span class="codeline" id="line-6"><code>// cancellation signals, and other request-scoped values across API boundaries</code></span>
<span class="codeline" id="line-7"><code>// and between processes.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// Incoming requests to a server should create a Context, and outgoing</code></span>
<span class="codeline" id="line-10"><code>// calls to servers should accept a Context. The chain of function</code></span>
<span class="codeline" id="line-11"><code>// calls between them must propagate the Context, optionally replacing</code></span>
<span class="codeline" id="line-12"><code>// it with a derived Context created using WithCancel, WithDeadline,</code></span>
<span class="codeline" id="line-13"><code>// WithTimeout, or WithValue. When a Context is canceled, all</code></span>
<span class="codeline" id="line-14"><code>// Contexts derived from it are also canceled.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// The WithCancel, WithDeadline, and WithTimeout functions take a</code></span>
<span class="codeline" id="line-17"><code>// Context (the parent) and return a derived Context (the child) and a</code></span>
<span class="codeline" id="line-18"><code>// CancelFunc. Calling the CancelFunc cancels the child and its</code></span>
<span class="codeline" id="line-19"><code>// children, removes the parent's reference to the child, and stops</code></span>
<span class="codeline" id="line-20"><code>// any associated timers. Failing to call the CancelFunc leaks the</code></span>
<span class="codeline" id="line-21"><code>// child and its children until the parent is canceled or the timer</code></span>
<span class="codeline" id="line-22"><code>// fires. The go vet tool checks that CancelFuncs are used on all</code></span>
<span class="codeline" id="line-23"><code>// control-flow paths.</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// Programs that use Contexts should follow these rules to keep interfaces</code></span>
<span class="codeline" id="line-26"><code>// consistent across packages and enable static analysis tools to check context</code></span>
<span class="codeline" id="line-27"><code>// propagation:</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// Do not store Contexts inside a struct type; instead, pass a Context</code></span>
<span class="codeline" id="line-30"><code>// explicitly to each function that needs it. The Context should be the first</code></span>
<span class="codeline" id="line-31"><code>// parameter, typically named ctx:</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// 	func DoSomething(ctx context.Context, arg Arg) error {</code></span>
<span class="codeline" id="line-34"><code>// 		// ... use ctx ...</code></span>
<span class="codeline" id="line-35"><code>// 	}</code></span>
<span class="codeline" id="line-36"><code>//</code></span>
<span class="codeline" id="line-37"><code>// Do not pass a nil Context, even if a function permits it. Pass context.TODO</code></span>
<span class="codeline" id="line-38"><code>// if you are unsure about which Context to use.</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// Use context Values only for request-scoped data that transits processes and</code></span>
<span class="codeline" id="line-41"><code>// APIs, not for passing optional parameters to functions.</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>// The same Context may be passed to functions running in different goroutines;</code></span>
<span class="codeline" id="line-44"><code>// Contexts are safe for simultaneous use by multiple goroutines.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>// See https://blog.golang.org/context for example code for a server that uses</code></span>
<span class="codeline" id="line-47"><code>// Contexts.</code></span></div><span class="codeline" id="line-48"><code>package context</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>import (</code></span>
<span class="codeline" id="line-51"><code>	"errors"</code></span>
<span class="codeline" id="line-52"><code>	"internal/reflectlite"</code></span>
<span class="codeline" id="line-53"><code>	"sync"</code></span>
<span class="codeline" id="line-54"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-55"><code>	"time"</code></span>
<span class="codeline" id="line-56"><code>)</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>// A Context carries a deadline, a cancellation signal, and other values across</code></span>
<span class="codeline" id="line-59"><code>// API boundaries.</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// Context's methods may be called by multiple goroutines simultaneously.</code></span>
<span class="codeline" id="line-62"><code>type Context interface {</code></span>
<span class="codeline" id="line-63"><code>	// Deadline returns the time when work done on behalf of this context</code></span>
<span class="codeline" id="line-64"><code>	// should be canceled. Deadline returns ok==false when no deadline is</code></span>
<span class="codeline" id="line-65"><code>	// set. Successive calls to Deadline return the same results.</code></span>
<span class="codeline" id="line-66"><code>	Deadline() (deadline time.Time, ok bool)</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>	// Done returns a channel that's closed when work done on behalf of this</code></span>
<span class="codeline" id="line-69"><code>	// context should be canceled. Done may return nil if this context can</code></span>
<span class="codeline" id="line-70"><code>	// never be canceled. Successive calls to Done return the same value.</code></span>
<span class="codeline" id="line-71"><code>	// The close of the Done channel may happen asynchronously,</code></span>
<span class="codeline" id="line-72"><code>	// after the cancel function returns.</code></span>
<span class="codeline" id="line-73"><code>	//</code></span>
<span class="codeline" id="line-74"><code>	// WithCancel arranges for Done to be closed when cancel is called;</code></span>
<span class="codeline" id="line-75"><code>	// WithDeadline arranges for Done to be closed when the deadline</code></span>
<span class="codeline" id="line-76"><code>	// expires; WithTimeout arranges for Done to be closed when the timeout</code></span>
<span class="codeline" id="line-77"><code>	// elapses.</code></span>
<span class="codeline" id="line-78"><code>	//</code></span>
<span class="codeline" id="line-79"><code>	// Done is provided for use in select statements:</code></span>
<span class="codeline" id="line-80"><code>	//</code></span>
<span class="codeline" id="line-81"><code>	//  // Stream generates values with DoSomething and sends them to out</code></span>
<span class="codeline" id="line-82"><code>	//  // until DoSomething returns an error or ctx.Done is closed.</code></span>
<span class="codeline" id="line-83"><code>	//  func Stream(ctx context.Context, out chan&lt;- Value) error {</code></span>
<span class="codeline" id="line-84"><code>	//  	for {</code></span>
<span class="codeline" id="line-85"><code>	//  		v, err := DoSomething(ctx)</code></span>
<span class="codeline" id="line-86"><code>	//  		if err != nil {</code></span>
<span class="codeline" id="line-87"><code>	//  			return err</code></span>
<span class="codeline" id="line-88"><code>	//  		}</code></span>
<span class="codeline" id="line-89"><code>	//  		select {</code></span>
<span class="codeline" id="line-90"><code>	//  		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-91"><code>	//  			return ctx.Err()</code></span>
<span class="codeline" id="line-92"><code>	//  		case out &lt;- v:</code></span>
<span class="codeline" id="line-93"><code>	//  		}</code></span>
<span class="codeline" id="line-94"><code>	//  	}</code></span>
<span class="codeline" id="line-95"><code>	//  }</code></span>
<span class="codeline" id="line-96"><code>	//</code></span>
<span class="codeline" id="line-97"><code>	// See https://blog.golang.org/pipelines for more examples of how to use</code></span>
<span class="codeline" id="line-98"><code>	// a Done channel for cancellation.</code></span>
<span class="codeline" id="line-99"><code>	Done() &lt;-chan struct{}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>	// If Done is not yet closed, Err returns nil.</code></span>
<span class="codeline" id="line-102"><code>	// If Done is closed, Err returns a non-nil error explaining why:</code></span>
<span class="codeline" id="line-103"><code>	// Canceled if the context was canceled</code></span>
<span class="codeline" id="line-104"><code>	// or DeadlineExceeded if the context's deadline passed.</code></span>
<span class="codeline" id="line-105"><code>	// After Err returns a non-nil error, successive calls to Err return the same error.</code></span>
<span class="codeline" id="line-106"><code>	Err() error</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>	// Value returns the value associated with this context for key, or nil</code></span>
<span class="codeline" id="line-109"><code>	// if no value is associated with key. Successive calls to Value with</code></span>
<span class="codeline" id="line-110"><code>	// the same key returns the same result.</code></span>
<span class="codeline" id="line-111"><code>	//</code></span>
<span class="codeline" id="line-112"><code>	// Use context values only for request-scoped data that transits</code></span>
<span class="codeline" id="line-113"><code>	// processes and API boundaries, not for passing optional parameters to</code></span>
<span class="codeline" id="line-114"><code>	// functions.</code></span>
<span class="codeline" id="line-115"><code>	//</code></span>
<span class="codeline" id="line-116"><code>	// A key identifies a specific value in a Context. Functions that wish</code></span>
<span class="codeline" id="line-117"><code>	// to store values in Context typically allocate a key in a global</code></span>
<span class="codeline" id="line-118"><code>	// variable then use that key as the argument to context.WithValue and</code></span>
<span class="codeline" id="line-119"><code>	// Context.Value. A key can be any type that supports equality;</code></span>
<span class="codeline" id="line-120"><code>	// packages should define keys as an unexported type to avoid</code></span>
<span class="codeline" id="line-121"><code>	// collisions.</code></span>
<span class="codeline" id="line-122"><code>	//</code></span>
<span class="codeline" id="line-123"><code>	// Packages that define a Context key should provide type-safe accessors</code></span>
<span class="codeline" id="line-124"><code>	// for the values stored using that key:</code></span>
<span class="codeline" id="line-125"><code>	//</code></span>
<span class="codeline" id="line-126"><code>	// 	// Package user defines a User type that's stored in Contexts.</code></span>
<span class="codeline" id="line-127"><code>	// 	package user</code></span>
<span class="codeline" id="line-128"><code>	//</code></span>
<span class="codeline" id="line-129"><code>	// 	import "context"</code></span>
<span class="codeline" id="line-130"><code>	//</code></span>
<span class="codeline" id="line-131"><code>	// 	// User is the type of value stored in the Contexts.</code></span>
<span class="codeline" id="line-132"><code>	// 	type User struct {...}</code></span>
<span class="codeline" id="line-133"><code>	//</code></span>
<span class="codeline" id="line-134"><code>	// 	// key is an unexported type for keys defined in this package.</code></span>
<span class="codeline" id="line-135"><code>	// 	// This prevents collisions with keys defined in other packages.</code></span>
<span class="codeline" id="line-136"><code>	// 	type key int</code></span>
<span class="codeline" id="line-137"><code>	//</code></span>
<span class="codeline" id="line-138"><code>	// 	// userKey is the key for user.User values in Contexts. It is</code></span>
<span class="codeline" id="line-139"><code>	// 	// unexported; clients use user.NewContext and user.FromContext</code></span>
<span class="codeline" id="line-140"><code>	// 	// instead of using this key directly.</code></span>
<span class="codeline" id="line-141"><code>	// 	var userKey key</code></span>
<span class="codeline" id="line-142"><code>	//</code></span>
<span class="codeline" id="line-143"><code>	// 	// NewContext returns a new Context that carries value u.</code></span>
<span class="codeline" id="line-144"><code>	// 	func NewContext(ctx context.Context, u *User) context.Context {</code></span>
<span class="codeline" id="line-145"><code>	// 		return context.WithValue(ctx, userKey, u)</code></span>
<span class="codeline" id="line-146"><code>	// 	}</code></span>
<span class="codeline" id="line-147"><code>	//</code></span>
<span class="codeline" id="line-148"><code>	// 	// FromContext returns the User value stored in ctx, if any.</code></span>
<span class="codeline" id="line-149"><code>	// 	func FromContext(ctx context.Context) (*User, bool) {</code></span>
<span class="codeline" id="line-150"><code>	// 		u, ok := ctx.Value(userKey).(*User)</code></span>
<span class="codeline" id="line-151"><code>	// 		return u, ok</code></span>
<span class="codeline" id="line-152"><code>	// 	}</code></span>
<span class="codeline" id="line-153"><code>	Value(key interface{}) interface{}</code></span>
<span class="codeline" id="line-154"><code>}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>// Canceled is the error returned by Context.Err when the context is canceled.</code></span>
<span class="codeline" id="line-157"><code>var Canceled = errors.New("context canceled")</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>// DeadlineExceeded is the error returned by Context.Err when the context's</code></span>
<span class="codeline" id="line-160"><code>// deadline passes.</code></span>
<span class="codeline" id="line-161"><code>var DeadlineExceeded error = deadlineExceededError{}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>type deadlineExceededError struct{}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>func (deadlineExceededError) Error() string   { return "context deadline exceeded" }</code></span>
<span class="codeline" id="line-166"><code>func (deadlineExceededError) Timeout() bool   { return true }</code></span>
<span class="codeline" id="line-167"><code>func (deadlineExceededError) Temporary() bool { return true }</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>// An emptyCtx is never canceled, has no values, and has no deadline. It is not</code></span>
<span class="codeline" id="line-170"><code>// struct{}, since vars of this type must have distinct addresses.</code></span>
<span class="codeline" id="line-171"><code>type emptyCtx int</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-174"><code>	return</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>func (*emptyCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-178"><code>	return nil</code></span>
<span class="codeline" id="line-179"><code>}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>func (*emptyCtx) Err() error {</code></span>
<span class="codeline" id="line-182"><code>	return nil</code></span>
<span class="codeline" id="line-183"><code>}</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>func (*emptyCtx) Value(key interface{}) interface{} {</code></span>
<span class="codeline" id="line-186"><code>	return nil</code></span>
<span class="codeline" id="line-187"><code>}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>func (e *emptyCtx) String() string {</code></span>
<span class="codeline" id="line-190"><code>	switch e {</code></span>
<span class="codeline" id="line-191"><code>	case background:</code></span>
<span class="codeline" id="line-192"><code>		return "context.Background"</code></span>
<span class="codeline" id="line-193"><code>	case todo:</code></span>
<span class="codeline" id="line-194"><code>		return "context.TODO"</code></span>
<span class="codeline" id="line-195"><code>	}</code></span>
<span class="codeline" id="line-196"><code>	return "unknown empty Context"</code></span>
<span class="codeline" id="line-197"><code>}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>var (</code></span>
<span class="codeline" id="line-200"><code>	background = new(emptyCtx)</code></span>
<span class="codeline" id="line-201"><code>	todo       = new(emptyCtx)</code></span>
<span class="codeline" id="line-202"><code>)</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>// Background returns a non-nil, empty Context. It is never canceled, has no</code></span>
<span class="codeline" id="line-205"><code>// values, and has no deadline. It is typically used by the main function,</code></span>
<span class="codeline" id="line-206"><code>// initialization, and tests, and as the top-level Context for incoming</code></span>
<span class="codeline" id="line-207"><code>// requests.</code></span>
<span class="codeline" id="line-208"><code>func Background() Context {</code></span>
<span class="codeline" id="line-209"><code>	return background</code></span>
<span class="codeline" id="line-210"><code>}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>// TODO returns a non-nil, empty Context. Code should use context.TODO when</code></span>
<span class="codeline" id="line-213"><code>// it's unclear which Context to use or it is not yet available (because the</code></span>
<span class="codeline" id="line-214"><code>// surrounding function has not yet been extended to accept a Context</code></span>
<span class="codeline" id="line-215"><code>// parameter).</code></span>
<span class="codeline" id="line-216"><code>func TODO() Context {</code></span>
<span class="codeline" id="line-217"><code>	return todo</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// A CancelFunc tells an operation to abandon its work.</code></span>
<span class="codeline" id="line-221"><code>// A CancelFunc does not wait for the work to stop.</code></span>
<span class="codeline" id="line-222"><code>// A CancelFunc may be called by multiple goroutines simultaneously.</code></span>
<span class="codeline" id="line-223"><code>// After the first call, subsequent calls to a CancelFunc do nothing.</code></span>
<span class="codeline" id="line-224"><code>type CancelFunc func()</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// WithCancel returns a copy of parent with a new Done channel. The returned</code></span>
<span class="codeline" id="line-227"><code>// context's Done channel is closed when the returned cancel function is called</code></span>
<span class="codeline" id="line-228"><code>// or when the parent context's Done channel is closed, whichever happens first.</code></span>
<span class="codeline" id="line-229"><code>//</code></span>
<span class="codeline" id="line-230"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-231"><code>// call cancel as soon as the operations running in this Context complete.</code></span>
<span class="codeline" id="line-232"><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {</code></span>
<span class="codeline" id="line-233"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-234"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-235"><code>	}</code></span>
<span class="codeline" id="line-236"><code>	c := newCancelCtx(parent)</code></span>
<span class="codeline" id="line-237"><code>	propagateCancel(parent, &amp;c)</code></span>
<span class="codeline" id="line-238"><code>	return &amp;c, func() { c.cancel(true, Canceled) }</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>// newCancelCtx returns an initialized cancelCtx.</code></span>
<span class="codeline" id="line-242"><code>func newCancelCtx(parent Context) cancelCtx {</code></span>
<span class="codeline" id="line-243"><code>	return cancelCtx{Context: parent}</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>// goroutines counts the number of goroutines ever created; for testing.</code></span>
<span class="codeline" id="line-247"><code>var goroutines int32</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>// propagateCancel arranges for child to be canceled when parent is.</code></span>
<span class="codeline" id="line-250"><code>func propagateCancel(parent Context, child canceler) {</code></span>
<span class="codeline" id="line-251"><code>	done := parent.Done()</code></span>
<span class="codeline" id="line-252"><code>	if done == nil {</code></span>
<span class="codeline" id="line-253"><code>		return // parent is never canceled</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>	select {</code></span>
<span class="codeline" id="line-257"><code>	case &lt;-done:</code></span>
<span class="codeline" id="line-258"><code>		// parent is already canceled</code></span>
<span class="codeline" id="line-259"><code>		child.cancel(false, parent.Err())</code></span>
<span class="codeline" id="line-260"><code>		return</code></span>
<span class="codeline" id="line-261"><code>	default:</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>	if p, ok := parentCancelCtx(parent); ok {</code></span>
<span class="codeline" id="line-265"><code>		p.mu.Lock()</code></span>
<span class="codeline" id="line-266"><code>		if p.err != nil {</code></span>
<span class="codeline" id="line-267"><code>			// parent has already been canceled</code></span>
<span class="codeline" id="line-268"><code>			child.cancel(false, p.err)</code></span>
<span class="codeline" id="line-269"><code>		} else {</code></span>
<span class="codeline" id="line-270"><code>			if p.children == nil {</code></span>
<span class="codeline" id="line-271"><code>				p.children = make(map[canceler]struct{})</code></span>
<span class="codeline" id="line-272"><code>			}</code></span>
<span class="codeline" id="line-273"><code>			p.children[child] = struct{}{}</code></span>
<span class="codeline" id="line-274"><code>		}</code></span>
<span class="codeline" id="line-275"><code>		p.mu.Unlock()</code></span>
<span class="codeline" id="line-276"><code>	} else {</code></span>
<span class="codeline" id="line-277"><code>		atomic.AddInt32(&amp;goroutines, +1)</code></span>
<span class="codeline" id="line-278"><code>		go func() {</code></span>
<span class="codeline" id="line-279"><code>			select {</code></span>
<span class="codeline" id="line-280"><code>			case &lt;-parent.Done():</code></span>
<span class="codeline" id="line-281"><code>				child.cancel(false, parent.Err())</code></span>
<span class="codeline" id="line-282"><code>			case &lt;-child.Done():</code></span>
<span class="codeline" id="line-283"><code>			}</code></span>
<span class="codeline" id="line-284"><code>		}()</code></span>
<span class="codeline" id="line-285"><code>	}</code></span>
<span class="codeline" id="line-286"><code>}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</code></span>
<span class="codeline" id="line-289"><code>var cancelCtxKey int</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>// parentCancelCtx returns the underlying *cancelCtx for parent.</code></span>
<span class="codeline" id="line-292"><code>// It does this by looking up parent.Value(&amp;cancelCtxKey) to find</code></span>
<span class="codeline" id="line-293"><code>// the innermost enclosing *cancelCtx and then checking whether</code></span>
<span class="codeline" id="line-294"><code>// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx</code></span>
<span class="codeline" id="line-295"><code>// has been wrapped in a custom implementation providing a</code></span>
<span class="codeline" id="line-296"><code>// different done channel, in which case we should not bypass it.)</code></span>
<span class="codeline" id="line-297"><code>func parentCancelCtx(parent Context) (*cancelCtx, bool) {</code></span>
<span class="codeline" id="line-298"><code>	done := parent.Done()</code></span>
<span class="codeline" id="line-299"><code>	if done == closedchan || done == nil {</code></span>
<span class="codeline" id="line-300"><code>		return nil, false</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code>	p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</code></span>
<span class="codeline" id="line-303"><code>	if !ok {</code></span>
<span class="codeline" id="line-304"><code>		return nil, false</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-307"><code>	ok = p.done == done</code></span>
<span class="codeline" id="line-308"><code>	p.mu.Unlock()</code></span>
<span class="codeline" id="line-309"><code>	if !ok {</code></span>
<span class="codeline" id="line-310"><code>		return nil, false</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code>	return p, true</code></span>
<span class="codeline" id="line-313"><code>}</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>// removeChild removes a context from its parent.</code></span>
<span class="codeline" id="line-316"><code>func removeChild(parent Context, child canceler) {</code></span>
<span class="codeline" id="line-317"><code>	p, ok := parentCancelCtx(parent)</code></span>
<span class="codeline" id="line-318"><code>	if !ok {</code></span>
<span class="codeline" id="line-319"><code>		return</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-322"><code>	if p.children != nil {</code></span>
<span class="codeline" id="line-323"><code>		delete(p.children, child)</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code>	p.mu.Unlock()</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// A canceler is a context type that can be canceled directly. The</code></span>
<span class="codeline" id="line-329"><code>// implementations are *cancelCtx and *timerCtx.</code></span>
<span class="codeline" id="line-330"><code>type canceler interface {</code></span>
<span class="codeline" id="line-331"><code>	cancel(removeFromParent bool, err error)</code></span>
<span class="codeline" id="line-332"><code>	Done() &lt;-chan struct{}</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// closedchan is a reusable closed channel.</code></span>
<span class="codeline" id="line-336"><code>var closedchan = make(chan struct{})</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>func init() {</code></span>
<span class="codeline" id="line-339"><code>	close(closedchan)</code></span>
<span class="codeline" id="line-340"><code>}</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>// A cancelCtx can be canceled. When canceled, it also cancels any children</code></span>
<span class="codeline" id="line-343"><code>// that implement canceler.</code></span>
<span class="codeline" id="line-344"><code>type cancelCtx struct {</code></span>
<span class="codeline" id="line-345"><code>	Context</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>	mu       sync.Mutex            // protects following fields</code></span>
<span class="codeline" id="line-348"><code>	done     chan struct{}         // created lazily, closed by first cancel call</code></span>
<span class="codeline" id="line-349"><code>	children map[canceler]struct{} // set to nil by the first cancel call</code></span>
<span class="codeline" id="line-350"><code>	err      error                 // set to non-nil by the first cancel call</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>func (c *cancelCtx) Value(key interface{}) interface{} {</code></span>
<span class="codeline" id="line-354"><code>	if key == &amp;cancelCtxKey {</code></span>
<span class="codeline" id="line-355"><code>		return c</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code>	return c.Context.Value(key)</code></span>
<span class="codeline" id="line-358"><code>}</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>func (c *cancelCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-361"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-362"><code>	if c.done == nil {</code></span>
<span class="codeline" id="line-363"><code>		c.done = make(chan struct{})</code></span>
<span class="codeline" id="line-364"><code>	}</code></span>
<span class="codeline" id="line-365"><code>	d := c.done</code></span>
<span class="codeline" id="line-366"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-367"><code>	return d</code></span>
<span class="codeline" id="line-368"><code>}</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>func (c *cancelCtx) Err() error {</code></span>
<span class="codeline" id="line-371"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-372"><code>	err := c.err</code></span>
<span class="codeline" id="line-373"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-374"><code>	return err</code></span>
<span class="codeline" id="line-375"><code>}</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>type stringer interface {</code></span>
<span class="codeline" id="line-378"><code>	String() string</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>func contextName(c Context) string {</code></span>
<span class="codeline" id="line-382"><code>	if s, ok := c.(stringer); ok {</code></span>
<span class="codeline" id="line-383"><code>		return s.String()</code></span>
<span class="codeline" id="line-384"><code>	}</code></span>
<span class="codeline" id="line-385"><code>	return reflectlite.TypeOf(c).String()</code></span>
<span class="codeline" id="line-386"><code>}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>func (c *cancelCtx) String() string {</code></span>
<span class="codeline" id="line-389"><code>	return contextName(c.Context) + ".WithCancel"</code></span>
<span class="codeline" id="line-390"><code>}</code></span>
<span class="codeline" id="line-391"><code></code></span>
<span class="codeline" id="line-392"><code>// cancel closes c.done, cancels each of c's children, and, if</code></span>
<span class="codeline" id="line-393"><code>// removeFromParent is true, removes c from its parent's children.</code></span>
<span class="codeline" id="line-394"><code>func (c *cancelCtx) cancel(removeFromParent bool, err error) {</code></span>
<span class="codeline" id="line-395"><code>	if err == nil {</code></span>
<span class="codeline" id="line-396"><code>		panic("context: internal error: missing cancel error")</code></span>
<span class="codeline" id="line-397"><code>	}</code></span>
<span class="codeline" id="line-398"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-399"><code>	if c.err != nil {</code></span>
<span class="codeline" id="line-400"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-401"><code>		return // already canceled</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code>	c.err = err</code></span>
<span class="codeline" id="line-404"><code>	if c.done == nil {</code></span>
<span class="codeline" id="line-405"><code>		c.done = closedchan</code></span>
<span class="codeline" id="line-406"><code>	} else {</code></span>
<span class="codeline" id="line-407"><code>		close(c.done)</code></span>
<span class="codeline" id="line-408"><code>	}</code></span>
<span class="codeline" id="line-409"><code>	for child := range c.children {</code></span>
<span class="codeline" id="line-410"><code>		// NOTE: acquiring the child's lock while holding parent's lock.</code></span>
<span class="codeline" id="line-411"><code>		child.cancel(false, err)</code></span>
<span class="codeline" id="line-412"><code>	}</code></span>
<span class="codeline" id="line-413"><code>	c.children = nil</code></span>
<span class="codeline" id="line-414"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>	if removeFromParent {</code></span>
<span class="codeline" id="line-417"><code>		removeChild(c.Context, c)</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code>}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>// WithDeadline returns a copy of the parent context with the deadline adjusted</code></span>
<span class="codeline" id="line-422"><code>// to be no later than d. If the parent's deadline is already earlier than d,</code></span>
<span class="codeline" id="line-423"><code>// WithDeadline(parent, d) is semantically equivalent to parent. The returned</code></span>
<span class="codeline" id="line-424"><code>// context's Done channel is closed when the deadline expires, when the returned</code></span>
<span class="codeline" id="line-425"><code>// cancel function is called, or when the parent context's Done channel is</code></span>
<span class="codeline" id="line-426"><code>// closed, whichever happens first.</code></span>
<span class="codeline" id="line-427"><code>//</code></span>
<span class="codeline" id="line-428"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-429"><code>// call cancel as soon as the operations running in this Context complete.</code></span>
<span class="codeline" id="line-430"><code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-431"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-432"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-433"><code>	}</code></span>
<span class="codeline" id="line-434"><code>	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) {</code></span>
<span class="codeline" id="line-435"><code>		// The current deadline is already sooner than the new one.</code></span>
<span class="codeline" id="line-436"><code>		return WithCancel(parent)</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>	c := &amp;timerCtx{</code></span>
<span class="codeline" id="line-439"><code>		cancelCtx: newCancelCtx(parent),</code></span>
<span class="codeline" id="line-440"><code>		deadline:  d,</code></span>
<span class="codeline" id="line-441"><code>	}</code></span>
<span class="codeline" id="line-442"><code>	propagateCancel(parent, c)</code></span>
<span class="codeline" id="line-443"><code>	dur := time.Until(d)</code></span>
<span class="codeline" id="line-444"><code>	if dur &lt;= 0 {</code></span>
<span class="codeline" id="line-445"><code>		c.cancel(true, DeadlineExceeded) // deadline has already passed</code></span>
<span class="codeline" id="line-446"><code>		return c, func() { c.cancel(false, Canceled) }</code></span>
<span class="codeline" id="line-447"><code>	}</code></span>
<span class="codeline" id="line-448"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-449"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-450"><code>	if c.err == nil {</code></span>
<span class="codeline" id="line-451"><code>		c.timer = time.AfterFunc(dur, func() {</code></span>
<span class="codeline" id="line-452"><code>			c.cancel(true, DeadlineExceeded)</code></span>
<span class="codeline" id="line-453"><code>		})</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	return c, func() { c.cancel(true, Canceled) }</code></span>
<span class="codeline" id="line-456"><code>}</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</code></span>
<span class="codeline" id="line-459"><code>// implement Done and Err. It implements cancel by stopping its timer then</code></span>
<span class="codeline" id="line-460"><code>// delegating to cancelCtx.cancel.</code></span>
<span class="codeline" id="line-461"><code>type timerCtx struct {</code></span>
<span class="codeline" id="line-462"><code>	cancelCtx</code></span>
<span class="codeline" id="line-463"><code>	timer *time.Timer // Under cancelCtx.mu.</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	deadline time.Time</code></span>
<span class="codeline" id="line-466"><code>}</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-469"><code>	return c.deadline, true</code></span>
<span class="codeline" id="line-470"><code>}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>func (c *timerCtx) String() string {</code></span>
<span class="codeline" id="line-473"><code>	return contextName(c.cancelCtx.Context) + ".WithDeadline(" +</code></span>
<span class="codeline" id="line-474"><code>		c.deadline.String() + " [" +</code></span>
<span class="codeline" id="line-475"><code>		time.Until(c.deadline).String() + "])"</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>func (c *timerCtx) cancel(removeFromParent bool, err error) {</code></span>
<span class="codeline" id="line-479"><code>	c.cancelCtx.cancel(false, err)</code></span>
<span class="codeline" id="line-480"><code>	if removeFromParent {</code></span>
<span class="codeline" id="line-481"><code>		// Remove this timerCtx from its parent cancelCtx's children.</code></span>
<span class="codeline" id="line-482"><code>		removeChild(c.cancelCtx.Context, c)</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-485"><code>	if c.timer != nil {</code></span>
<span class="codeline" id="line-486"><code>		c.timer.Stop()</code></span>
<span class="codeline" id="line-487"><code>		c.timer = nil</code></span>
<span class="codeline" id="line-488"><code>	}</code></span>
<span class="codeline" id="line-489"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-490"><code>}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</code></span>
<span class="codeline" id="line-493"><code>//</code></span>
<span class="codeline" id="line-494"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-495"><code>// call cancel as soon as the operations running in this Context complete:</code></span>
<span class="codeline" id="line-496"><code>//</code></span>
<span class="codeline" id="line-497"><code>// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {</code></span>
<span class="codeline" id="line-498"><code>// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</code></span>
<span class="codeline" id="line-499"><code>// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses</code></span>
<span class="codeline" id="line-500"><code>// 		return slowOperation(ctx)</code></span>
<span class="codeline" id="line-501"><code>// 	}</code></span>
<span class="codeline" id="line-502"><code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-503"><code>	return WithDeadline(parent, time.Now().Add(timeout))</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>// WithValue returns a copy of parent in which the value associated with key is</code></span>
<span class="codeline" id="line-507"><code>// val.</code></span>
<span class="codeline" id="line-508"><code>//</code></span>
<span class="codeline" id="line-509"><code>// Use context Values only for request-scoped data that transits processes and</code></span>
<span class="codeline" id="line-510"><code>// APIs, not for passing optional parameters to functions.</code></span>
<span class="codeline" id="line-511"><code>//</code></span>
<span class="codeline" id="line-512"><code>// The provided key must be comparable and should not be of type</code></span>
<span class="codeline" id="line-513"><code>// string or any other built-in type to avoid collisions between</code></span>
<span class="codeline" id="line-514"><code>// packages using context. Users of WithValue should define their own</code></span>
<span class="codeline" id="line-515"><code>// types for keys. To avoid allocating when assigning to an</code></span>
<span class="codeline" id="line-516"><code>// interface{}, context keys often have concrete type</code></span>
<span class="codeline" id="line-517"><code>// struct{}. Alternatively, exported context key variables' static</code></span>
<span class="codeline" id="line-518"><code>// type should be a pointer or interface.</code></span>
<span class="codeline" id="line-519"><code>func WithValue(parent Context, key, val interface{}) Context {</code></span>
<span class="codeline" id="line-520"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-521"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code>	if key == nil {</code></span>
<span class="codeline" id="line-524"><code>		panic("nil key")</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code>	if !reflectlite.TypeOf(key).Comparable() {</code></span>
<span class="codeline" id="line-527"><code>		panic("key is not comparable")</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code>	return &amp;valueCtx{parent, key, val}</code></span>
<span class="codeline" id="line-530"><code>}</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>// A valueCtx carries a key-value pair. It implements Value for that key and</code></span>
<span class="codeline" id="line-533"><code>// delegates all other calls to the embedded Context.</code></span>
<span class="codeline" id="line-534"><code>type valueCtx struct {</code></span>
<span class="codeline" id="line-535"><code>	Context</code></span>
<span class="codeline" id="line-536"><code>	key, val interface{}</code></span>
<span class="codeline" id="line-537"><code>}</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>// stringify tries a bit to stringify v, without using fmt, since we don't</code></span>
<span class="codeline" id="line-540"><code>// want context depending on the unicode tables. This is only used by</code></span>
<span class="codeline" id="line-541"><code>// *valueCtx.String().</code></span>
<span class="codeline" id="line-542"><code>func stringify(v interface{}) string {</code></span>
<span class="codeline" id="line-543"><code>	switch s := v.(type) {</code></span>
<span class="codeline" id="line-544"><code>	case stringer:</code></span>
<span class="codeline" id="line-545"><code>		return s.String()</code></span>
<span class="codeline" id="line-546"><code>	case string:</code></span>
<span class="codeline" id="line-547"><code>		return s</code></span>
<span class="codeline" id="line-548"><code>	}</code></span>
<span class="codeline" id="line-549"><code>	return "&lt;not Stringer&gt;"</code></span>
<span class="codeline" id="line-550"><code>}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>func (c *valueCtx) String() string {</code></span>
<span class="codeline" id="line-553"><code>	return contextName(c.Context) + ".WithValue(type " +</code></span>
<span class="codeline" id="line-554"><code>		reflectlite.TypeOf(c.key).String() +</code></span>
<span class="codeline" id="line-555"><code>		", val " + stringify(c.val) + ")"</code></span>
<span class="codeline" id="line-556"><code>}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>func (c *valueCtx) Value(key interface{}) interface{} {</code></span>
<span class="codeline" id="line-559"><code>	if c.key == key {</code></span>
<span class="codeline" id="line-560"><code>		return c.val</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code>	return c.Context.Value(key)</code></span>
<span class="codeline" id="line-563"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>