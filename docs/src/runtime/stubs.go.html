<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: stubs.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	stubs.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import "unsafe"</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>// Should be a built-in for unsafe.Pointer?</code></span>
<span class="codeline" id="line-10"><code>//go:nosplit</code></span>
<span class="codeline" id="line-11"><code>func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {</code></span>
<span class="codeline" id="line-12"><code>	return unsafe.Pointer(uintptr(p) + x)</code></span>
<span class="codeline" id="line-13"><code>}</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// getg returns the pointer to the current g.</code></span>
<span class="codeline" id="line-16"><code>// The compiler rewrites calls to this function into instructions</code></span>
<span class="codeline" id="line-17"><code>// that fetch the g directly (from TLS or from the dedicated register).</code></span>
<span class="codeline" id="line-18"><code>func getg() *g</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>// mcall switches from the g to the g0 stack and invokes fn(g),</code></span>
<span class="codeline" id="line-21"><code>// where g is the goroutine that made the call.</code></span>
<span class="codeline" id="line-22"><code>// mcall saves g's current PC/SP in g-&gt;sched so that it can be restored later.</code></span>
<span class="codeline" id="line-23"><code>// It is up to fn to arrange for that later execution, typically by recording</code></span>
<span class="codeline" id="line-24"><code>// g in a data structure, causing something to call ready(g) later.</code></span>
<span class="codeline" id="line-25"><code>// mcall returns to the original goroutine g later, when g has been rescheduled.</code></span>
<span class="codeline" id="line-26"><code>// fn must not return at all; typically it ends by calling schedule, to let the m</code></span>
<span class="codeline" id="line-27"><code>// run other goroutines.</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// mcall can only be called from g stacks (not g0, not gsignal).</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// This must NOT be go:noescape: if fn is a stack-allocated closure,</code></span>
<span class="codeline" id="line-32"><code>// fn puts g on a run queue, and g executes before fn returns, the</code></span>
<span class="codeline" id="line-33"><code>// closure will be invalidated while it is still executing.</code></span>
<span class="codeline" id="line-34"><code>func mcall(fn func(*g))</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// systemstack runs fn on a system stack.</code></span>
<span class="codeline" id="line-37"><code>// If systemstack is called from the per-OS-thread (g0) stack, or</code></span>
<span class="codeline" id="line-38"><code>// if systemstack is called from the signal handling (gsignal) stack,</code></span>
<span class="codeline" id="line-39"><code>// systemstack calls fn directly and returns.</code></span>
<span class="codeline" id="line-40"><code>// Otherwise, systemstack is being called from the limited stack</code></span>
<span class="codeline" id="line-41"><code>// of an ordinary goroutine. In this case, systemstack switches</code></span>
<span class="codeline" id="line-42"><code>// to the per-OS-thread stack, calls fn, and switches back.</code></span>
<span class="codeline" id="line-43"><code>// It is common to use a func literal as the argument, in order</code></span>
<span class="codeline" id="line-44"><code>// to share inputs and outputs with the code around the call</code></span>
<span class="codeline" id="line-45"><code>// to system stack:</code></span>
<span class="codeline" id="line-46"><code>//</code></span>
<span class="codeline" id="line-47"><code>//	... set up y ...</code></span>
<span class="codeline" id="line-48"><code>//	systemstack(func() {</code></span>
<span class="codeline" id="line-49"><code>//		x = bigcall(y)</code></span>
<span class="codeline" id="line-50"><code>//	})</code></span>
<span class="codeline" id="line-51"><code>//	... use x ...</code></span>
<span class="codeline" id="line-52"><code>//</code></span>
<span class="codeline" id="line-53"><code>//go:noescape</code></span>
<span class="codeline" id="line-54"><code>func systemstack(fn func())</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>var badsystemstackMsg = "fatal: systemstack called from unexpected goroutine"</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>//go:nosplit</code></span>
<span class="codeline" id="line-59"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-60"><code>func badsystemstack() {</code></span>
<span class="codeline" id="line-61"><code>	sp := stringStructOf(&amp;badsystemstackMsg)</code></span>
<span class="codeline" id="line-62"><code>	write(2, sp.str, int32(sp.len))</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// memclrNoHeapPointers clears n bytes starting at ptr.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// Usually you should use typedmemclr. memclrNoHeapPointers should be</code></span>
<span class="codeline" id="line-68"><code>// used only when the caller knows that *ptr contains no heap pointers</code></span>
<span class="codeline" id="line-69"><code>// because either:</code></span>
<span class="codeline" id="line-70"><code>//</code></span>
<span class="codeline" id="line-71"><code>// *ptr is initialized memory and its type is pointer-free, or</code></span>
<span class="codeline" id="line-72"><code>//</code></span>
<span class="codeline" id="line-73"><code>// *ptr is uninitialized memory (e.g., memory that's being reused</code></span>
<span class="codeline" id="line-74"><code>// for a new allocation) and hence contains only "junk".</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>// memclrNoHeapPointers ensures that if ptr is pointer-aligned, and n</code></span>
<span class="codeline" id="line-77"><code>// is a multiple of the pointer size, then any pointer-aligned,</code></span>
<span class="codeline" id="line-78"><code>// pointer-sized portion is cleared atomically. Despite the function</code></span>
<span class="codeline" id="line-79"><code>// name, this is necessary because this function is the underlying</code></span>
<span class="codeline" id="line-80"><code>// implementation of typedmemclr and memclrHasPointers. See the doc of</code></span>
<span class="codeline" id="line-81"><code>// memmove for more details.</code></span>
<span class="codeline" id="line-82"><code>//</code></span>
<span class="codeline" id="line-83"><code>// The (CPU-specific) implementations of this function are in memclr_*.s.</code></span>
<span class="codeline" id="line-84"><code>//</code></span>
<span class="codeline" id="line-85"><code>//go:noescape</code></span>
<span class="codeline" id="line-86"><code>func memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>//go:linkname reflect_memclrNoHeapPointers reflect.memclrNoHeapPointers</code></span>
<span class="codeline" id="line-89"><code>func reflect_memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr) {</code></span>
<span class="codeline" id="line-90"><code>	memclrNoHeapPointers(ptr, n)</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>// memmove copies n bytes from "from" to "to".</code></span>
<span class="codeline" id="line-94"><code>//</code></span>
<span class="codeline" id="line-95"><code>// memmove ensures that any pointer in "from" is written to "to" with</code></span>
<span class="codeline" id="line-96"><code>// an indivisible write, so that racy reads cannot observe a</code></span>
<span class="codeline" id="line-97"><code>// half-written pointer. This is necessary to prevent the garbage</code></span>
<span class="codeline" id="line-98"><code>// collector from observing invalid pointers, and differs from memmove</code></span>
<span class="codeline" id="line-99"><code>// in unmanaged languages. However, memmove is only required to do</code></span>
<span class="codeline" id="line-100"><code>// this if "from" and "to" may contain pointers, which can only be the</code></span>
<span class="codeline" id="line-101"><code>// case if "from", "to", and "n" are all be word-aligned.</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>// Implementations are in memmove_*.s.</code></span>
<span class="codeline" id="line-104"><code>//</code></span>
<span class="codeline" id="line-105"><code>//go:noescape</code></span>
<span class="codeline" id="line-106"><code>func memmove(to, from unsafe.Pointer, n uintptr)</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>//go:linkname reflect_memmove reflect.memmove</code></span>
<span class="codeline" id="line-109"><code>func reflect_memmove(to, from unsafe.Pointer, n uintptr) {</code></span>
<span class="codeline" id="line-110"><code>	memmove(to, from, n)</code></span>
<span class="codeline" id="line-111"><code>}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>// exported value for testing</code></span>
<span class="codeline" id="line-114"><code>var hashLoad = float32(loadFactorNum) / float32(loadFactorDen)</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>//go:nosplit</code></span>
<span class="codeline" id="line-117"><code>func fastrand() uint32 {</code></span>
<span class="codeline" id="line-118"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-119"><code>	// Implement xorshift64+: 2 32-bit xorshift sequences added together.</code></span>
<span class="codeline" id="line-120"><code>	// Shift triplet [17,7,16] was calculated as indicated in Marsaglia's</code></span>
<span class="codeline" id="line-121"><code>	// Xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf</code></span>
<span class="codeline" id="line-122"><code>	// This generator passes the SmallCrush suite, part of TestU01 framework:</code></span>
<span class="codeline" id="line-123"><code>	// http://simul.iro.umontreal.ca/testu01/tu01.html</code></span>
<span class="codeline" id="line-124"><code>	s1, s0 := mp.fastrand[0], mp.fastrand[1]</code></span>
<span class="codeline" id="line-125"><code>	s1 ^= s1 &lt;&lt; 17</code></span>
<span class="codeline" id="line-126"><code>	s1 = s1 ^ s0 ^ s1&gt;&gt;7 ^ s0&gt;&gt;16</code></span>
<span class="codeline" id="line-127"><code>	mp.fastrand[0], mp.fastrand[1] = s0, s1</code></span>
<span class="codeline" id="line-128"><code>	return s0 + s1</code></span>
<span class="codeline" id="line-129"><code>}</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>//go:nosplit</code></span>
<span class="codeline" id="line-132"><code>func fastrandn(n uint32) uint32 {</code></span>
<span class="codeline" id="line-133"><code>	// This is similar to fastrand() % n, but faster.</code></span>
<span class="codeline" id="line-134"><code>	// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/</code></span>
<span class="codeline" id="line-135"><code>	return uint32(uint64(fastrand()) * uint64(n) &gt;&gt; 32)</code></span>
<span class="codeline" id="line-136"><code>}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>//go:linkname sync_fastrand sync.fastrand</code></span>
<span class="codeline" id="line-139"><code>func sync_fastrand() uint32 { return fastrand() }</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>//go:linkname net_fastrand net.fastrand</code></span>
<span class="codeline" id="line-142"><code>func net_fastrand() uint32 { return fastrand() }</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>//go:linkname os_fastrand os.fastrand</code></span>
<span class="codeline" id="line-145"><code>func os_fastrand() uint32 { return fastrand() }</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// in internal/bytealg/equal_*.s</code></span>
<span class="codeline" id="line-148"><code>//go:noescape</code></span>
<span class="codeline" id="line-149"><code>func memequal(a, b unsafe.Pointer, size uintptr) bool</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// noescape hides a pointer from escape analysis.  noescape is</code></span>
<span class="codeline" id="line-152"><code>// the identity function but escape analysis doesn't think the</code></span>
<span class="codeline" id="line-153"><code>// output depends on the input.  noescape is inlined and currently</code></span>
<span class="codeline" id="line-154"><code>// compiles down to zero instructions.</code></span>
<span class="codeline" id="line-155"><code>// USE CAREFULLY!</code></span>
<span class="codeline" id="line-156"><code>//go:nosplit</code></span>
<span class="codeline" id="line-157"><code>func noescape(p unsafe.Pointer) unsafe.Pointer {</code></span>
<span class="codeline" id="line-158"><code>	x := uintptr(p)</code></span>
<span class="codeline" id="line-159"><code>	return unsafe.Pointer(x ^ 0)</code></span>
<span class="codeline" id="line-160"><code>}</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>// Not all cgocallback frames are actually cgocallback,</code></span>
<span class="codeline" id="line-163"><code>// so not all have these arguments. Mark them uintptr so that the GC</code></span>
<span class="codeline" id="line-164"><code>// does not misinterpret memory when the arguments are not present.</code></span>
<span class="codeline" id="line-165"><code>// cgocallback is not called from Go, only from crosscall2.</code></span>
<span class="codeline" id="line-166"><code>// This in turn calls cgocallbackg, which is where we'll find</code></span>
<span class="codeline" id="line-167"><code>// pointer-declared arguments.</code></span>
<span class="codeline" id="line-168"><code>func cgocallback(fn, frame, ctxt uintptr)</code></span>
<span class="codeline" id="line-169"><code>func gogo(buf *gobuf)</code></span>
<span class="codeline" id="line-170"><code>func gosave(buf *gobuf)</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>//go:noescape</code></span>
<span class="codeline" id="line-173"><code>func jmpdefer(fv *funcval, argp uintptr)</code></span>
<span class="codeline" id="line-174"><code>func asminit()</code></span>
<span class="codeline" id="line-175"><code>func setg(gg *g)</code></span>
<span class="codeline" id="line-176"><code>func breakpoint()</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// reflectcall calls fn with a copy of the n argument bytes pointed at by arg.</code></span>
<span class="codeline" id="line-179"><code>// After fn returns, reflectcall copies n-retoffset result bytes</code></span>
<span class="codeline" id="line-180"><code>// back into arg+retoffset before returning. If copying result bytes back,</code></span>
<span class="codeline" id="line-181"><code>// the caller should pass the argument frame type as argtype, so that</code></span>
<span class="codeline" id="line-182"><code>// call can execute appropriate write barriers during the copy.</code></span>
<span class="codeline" id="line-183"><code>//</code></span>
<span class="codeline" id="line-184"><code>// Package reflect always passes a frame type. In package runtime,</code></span>
<span class="codeline" id="line-185"><code>// Windows callbacks are the only use of this that copies results</code></span>
<span class="codeline" id="line-186"><code>// back, and those cannot have pointers in their results, so runtime</code></span>
<span class="codeline" id="line-187"><code>// passes nil for the frame type.</code></span>
<span class="codeline" id="line-188"><code>//</code></span>
<span class="codeline" id="line-189"><code>// Package reflect accesses this symbol through a linkname.</code></span>
<span class="codeline" id="line-190"><code>func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32)</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>func procyield(cycles uint32)</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>type neverCallThisFunction struct{}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// goexit is the return stub at the top of every goroutine call stack.</code></span>
<span class="codeline" id="line-197"><code>// Each goroutine stack is constructed as if goexit called the</code></span>
<span class="codeline" id="line-198"><code>// goroutine's entry point function, so that when the entry point</code></span>
<span class="codeline" id="line-199"><code>// function returns, it will return to goexit, which will call goexit1</code></span>
<span class="codeline" id="line-200"><code>// to perform the actual exit.</code></span>
<span class="codeline" id="line-201"><code>//</code></span>
<span class="codeline" id="line-202"><code>// This function must never be called directly. Call goexit1 instead.</code></span>
<span class="codeline" id="line-203"><code>// gentraceback assumes that goexit terminates the stack. A direct</code></span>
<span class="codeline" id="line-204"><code>// call on the stack will cause gentraceback to stop walking the stack</code></span>
<span class="codeline" id="line-205"><code>// prematurely and if there is leftover state it may panic.</code></span>
<span class="codeline" id="line-206"><code>func goexit(neverCallThisFunction)</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>// publicationBarrier performs a store/store barrier (a "publication"</code></span>
<span class="codeline" id="line-209"><code>// or "export" barrier). Some form of synchronization is required</code></span>
<span class="codeline" id="line-210"><code>// between initializing an object and making that object accessible to</code></span>
<span class="codeline" id="line-211"><code>// another processor. Without synchronization, the initialization</code></span>
<span class="codeline" id="line-212"><code>// writes and the "publication" write may be reordered, allowing the</code></span>
<span class="codeline" id="line-213"><code>// other processor to follow the pointer and observe an uninitialized</code></span>
<span class="codeline" id="line-214"><code>// object. In general, higher-level synchronization should be used,</code></span>
<span class="codeline" id="line-215"><code>// such as locking or an atomic pointer write. publicationBarrier is</code></span>
<span class="codeline" id="line-216"><code>// for when those aren't an option, such as in the implementation of</code></span>
<span class="codeline" id="line-217"><code>// the memory manager.</code></span>
<span class="codeline" id="line-218"><code>//</code></span>
<span class="codeline" id="line-219"><code>// There's no corresponding barrier for the read side because the read</code></span>
<span class="codeline" id="line-220"><code>// side naturally has a data dependency order. All architectures that</code></span>
<span class="codeline" id="line-221"><code>// Go supports or seems likely to ever support automatically enforce</code></span>
<span class="codeline" id="line-222"><code>// data dependency ordering.</code></span>
<span class="codeline" id="line-223"><code>func publicationBarrier()</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>// getcallerpc returns the program counter (PC) of its caller's caller.</code></span>
<span class="codeline" id="line-226"><code>// getcallersp returns the stack pointer (SP) of its caller's caller.</code></span>
<span class="codeline" id="line-227"><code>// The implementation may be a compiler intrinsic; there is not</code></span>
<span class="codeline" id="line-228"><code>// necessarily code implementing this on every platform.</code></span>
<span class="codeline" id="line-229"><code>//</code></span>
<span class="codeline" id="line-230"><code>// For example:</code></span>
<span class="codeline" id="line-231"><code>//</code></span>
<span class="codeline" id="line-232"><code>//	func f(arg1, arg2, arg3 int) {</code></span>
<span class="codeline" id="line-233"><code>//		pc := getcallerpc()</code></span>
<span class="codeline" id="line-234"><code>//		sp := getcallersp()</code></span>
<span class="codeline" id="line-235"><code>//	}</code></span>
<span class="codeline" id="line-236"><code>//</code></span>
<span class="codeline" id="line-237"><code>// These two lines find the PC and SP immediately following</code></span>
<span class="codeline" id="line-238"><code>// the call to f (where f will return).</code></span>
<span class="codeline" id="line-239"><code>//</code></span>
<span class="codeline" id="line-240"><code>// The call to getcallerpc and getcallersp must be done in the</code></span>
<span class="codeline" id="line-241"><code>// frame being asked about.</code></span>
<span class="codeline" id="line-242"><code>//</code></span>
<span class="codeline" id="line-243"><code>// The result of getcallersp is correct at the time of the return,</code></span>
<span class="codeline" id="line-244"><code>// but it may be invalidated by any subsequent call to a function</code></span>
<span class="codeline" id="line-245"><code>// that might relocate the stack in order to grow or shrink it.</code></span>
<span class="codeline" id="line-246"><code>// A general rule is that the result of getcallersp should be used</code></span>
<span class="codeline" id="line-247"><code>// immediately and can only be passed to nosplit functions.</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>//go:noescape</code></span>
<span class="codeline" id="line-250"><code>func getcallerpc() uintptr</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>//go:noescape</code></span>
<span class="codeline" id="line-253"><code>func getcallersp() uintptr // implemented as an intrinsic on all platforms</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>// getclosureptr returns the pointer to the current closure.</code></span>
<span class="codeline" id="line-256"><code>// getclosureptr can only be used in an assignment statement</code></span>
<span class="codeline" id="line-257"><code>// at the entry of a function. Moreover, go:nosplit directive</code></span>
<span class="codeline" id="line-258"><code>// must be specified at the declaration of caller function,</code></span>
<span class="codeline" id="line-259"><code>// so that the function prolog does not clobber the closure register.</code></span>
<span class="codeline" id="line-260"><code>// for example:</code></span>
<span class="codeline" id="line-261"><code>//</code></span>
<span class="codeline" id="line-262"><code>//	//go:nosplit</code></span>
<span class="codeline" id="line-263"><code>//	func f(arg1, arg2, arg3 int) {</code></span>
<span class="codeline" id="line-264"><code>//		dx := getclosureptr()</code></span>
<span class="codeline" id="line-265"><code>//	}</code></span>
<span class="codeline" id="line-266"><code>//</code></span>
<span class="codeline" id="line-267"><code>// The compiler rewrites calls to this function into instructions that fetch the</code></span>
<span class="codeline" id="line-268"><code>// pointer from a well-known register (DX on x86 architecture, etc.) directly.</code></span>
<span class="codeline" id="line-269"><code>func getclosureptr() uintptr</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>//go:noescape</code></span>
<span class="codeline" id="line-272"><code>func asmcgocall(fn, arg unsafe.Pointer) int32</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>func morestack()</code></span>
<span class="codeline" id="line-275"><code>func morestack_noctxt()</code></span>
<span class="codeline" id="line-276"><code>func rt0_go()</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>// return0 is a stub used to return 0 from deferproc.</code></span>
<span class="codeline" id="line-279"><code>// It is called at the very end of deferproc to signal</code></span>
<span class="codeline" id="line-280"><code>// the calling Go function that it should not jump</code></span>
<span class="codeline" id="line-281"><code>// to deferreturn.</code></span>
<span class="codeline" id="line-282"><code>// in asm_*.s</code></span>
<span class="codeline" id="line-283"><code>func return0()</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// in asm_*.s</code></span>
<span class="codeline" id="line-286"><code>// not called directly; definitions here supply type information for traceback.</code></span>
<span class="codeline" id="line-287"><code>func call16(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-288"><code>func call32(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-289"><code>func call64(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-290"><code>func call128(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-291"><code>func call256(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-292"><code>func call512(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-293"><code>func call1024(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-294"><code>func call2048(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-295"><code>func call4096(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-296"><code>func call8192(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-297"><code>func call16384(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-298"><code>func call32768(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-299"><code>func call65536(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-300"><code>func call131072(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-301"><code>func call262144(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-302"><code>func call524288(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-303"><code>func call1048576(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-304"><code>func call2097152(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-305"><code>func call4194304(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-306"><code>func call8388608(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-307"><code>func call16777216(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-308"><code>func call33554432(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-309"><code>func call67108864(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-310"><code>func call134217728(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-311"><code>func call268435456(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-312"><code>func call536870912(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-313"><code>func call1073741824(typ, fn, arg unsafe.Pointer, n, retoffset uint32)</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>func systemstack_switch()</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// alignUp rounds n up to a multiple of a. a must be a power of 2.</code></span>
<span class="codeline" id="line-318"><code>func alignUp(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-319"><code>	return (n + a - 1) &amp;^ (a - 1)</code></span>
<span class="codeline" id="line-320"><code>}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>// alignDown rounds n down to a multiple of a. a must be a power of 2.</code></span>
<span class="codeline" id="line-323"><code>func alignDown(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-324"><code>	return n &amp;^ (a - 1)</code></span>
<span class="codeline" id="line-325"><code>}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>// divRoundUp returns ceil(n / a).</code></span>
<span class="codeline" id="line-328"><code>func divRoundUp(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-329"><code>	// a is generally a power of two. This will get inlined and</code></span>
<span class="codeline" id="line-330"><code>	// the compiler will optimize the division.</code></span>
<span class="codeline" id="line-331"><code>	return (n + a - 1) / a</code></span>
<span class="codeline" id="line-332"><code>}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>// checkASM reports whether assembly runtime checks have passed.</code></span>
<span class="codeline" id="line-335"><code>func checkASM() bool</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>func memequal_varlen(a, b unsafe.Pointer) bool</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// bool2int returns 0 if x is false or 1 if x is true.</code></span>
<span class="codeline" id="line-340"><code>func bool2int(x bool) int {</code></span>
<span class="codeline" id="line-341"><code>	// Avoid branches. In the SSA compiler, this compiles to</code></span>
<span class="codeline" id="line-342"><code>	// exactly what you would want it to.</code></span>
<span class="codeline" id="line-343"><code>	return int(uint8(*(*uint8)(unsafe.Pointer(&amp;x))))</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>// abort crashes the runtime in situations where even throw might not</code></span>
<span class="codeline" id="line-347"><code>// work. In general it should do something a debugger will recognize</code></span>
<span class="codeline" id="line-348"><code>// (e.g., an INT3 on x86). A crash in abort is recognized by the</code></span>
<span class="codeline" id="line-349"><code>// signal handler, which will attempt to tear down the runtime</code></span>
<span class="codeline" id="line-350"><code>// immediately.</code></span>
<span class="codeline" id="line-351"><code>func abort()</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>// Called from compiled code; declared for vet; do NOT call from Go.</code></span>
<span class="codeline" id="line-354"><code>func gcWriteBarrier()</code></span>
<span class="codeline" id="line-355"><code>func duffzero()</code></span>
<span class="codeline" id="line-356"><code>func duffcopy()</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>// Called from linker-generated .initarray; declared for go vet; do NOT call from Go.</code></span>
<span class="codeline" id="line-359"><code>func addmoduledata()</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>