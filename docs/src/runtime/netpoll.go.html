<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: netpoll.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	netpoll.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris windows</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"unsafe"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// Integrated network poller (platform-independent part).</code></span>
<span class="codeline" id="line-15"><code>// A particular implementation (epoll/kqueue/port/AIX/Windows)</code></span>
<span class="codeline" id="line-16"><code>// must define the following functions:</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// func netpollinit()</code></span>
<span class="codeline" id="line-19"><code>//     Initialize the poller. Only called once.</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>// func netpollopen(fd uintptr, pd *pollDesc) int32</code></span>
<span class="codeline" id="line-22"><code>//     Arm edge-triggered notifications for fd. The pd argument is to pass</code></span>
<span class="codeline" id="line-23"><code>//     back to netpollready when fd is ready. Return an errno value.</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// func netpoll(delta int64) gList</code></span>
<span class="codeline" id="line-26"><code>//     Poll the network. If delta &lt; 0, block indefinitely. If delta == 0,</code></span>
<span class="codeline" id="line-27"><code>//     poll without blocking. If delta &gt; 0, block for up to delta nanoseconds.</code></span>
<span class="codeline" id="line-28"><code>//     Return a list of goroutines built by calling netpollready.</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// func netpollBreak()</code></span>
<span class="codeline" id="line-31"><code>//     Wake up the network poller, assumed to be blocked in netpoll.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// func netpollIsPollDescriptor(fd uintptr) bool</code></span>
<span class="codeline" id="line-34"><code>//     Reports whether fd is a file descriptor used by the poller.</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// Error codes returned by runtime_pollReset and runtime_pollWait.</code></span>
<span class="codeline" id="line-37"><code>// These must match the values in internal/poll/fd_poll_runtime.go.</code></span>
<span class="codeline" id="line-38"><code>const (</code></span>
<span class="codeline" id="line-39"><code>	pollNoError        = 0 // no error</code></span>
<span class="codeline" id="line-40"><code>	pollErrClosing     = 1 // descriptor is closed</code></span>
<span class="codeline" id="line-41"><code>	pollErrTimeout     = 2 // I/O timeout</code></span>
<span class="codeline" id="line-42"><code>	pollErrNotPollable = 3 // general error polling descriptor</code></span>
<span class="codeline" id="line-43"><code>)</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>// pollDesc contains 2 binary semaphores, rg and wg, to park reader and writer</code></span>
<span class="codeline" id="line-46"><code>// goroutines respectively. The semaphore can be in the following states:</code></span>
<span class="codeline" id="line-47"><code>// pdReady - io readiness notification is pending;</code></span>
<span class="codeline" id="line-48"><code>//           a goroutine consumes the notification by changing the state to nil.</code></span>
<span class="codeline" id="line-49"><code>// pdWait - a goroutine prepares to park on the semaphore, but not yet parked;</code></span>
<span class="codeline" id="line-50"><code>//          the goroutine commits to park by changing the state to G pointer,</code></span>
<span class="codeline" id="line-51"><code>//          or, alternatively, concurrent io notification changes the state to pdReady,</code></span>
<span class="codeline" id="line-52"><code>//          or, alternatively, concurrent timeout/close changes the state to nil.</code></span>
<span class="codeline" id="line-53"><code>// G pointer - the goroutine is blocked on the semaphore;</code></span>
<span class="codeline" id="line-54"><code>//             io notification or timeout/close changes the state to pdReady or nil respectively</code></span>
<span class="codeline" id="line-55"><code>//             and unparks the goroutine.</code></span>
<span class="codeline" id="line-56"><code>// nil - none of the above.</code></span>
<span class="codeline" id="line-57"><code>const (</code></span>
<span class="codeline" id="line-58"><code>	pdReady uintptr = 1</code></span>
<span class="codeline" id="line-59"><code>	pdWait  uintptr = 2</code></span>
<span class="codeline" id="line-60"><code>)</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>const pollBlockSize = 4 * 1024</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// Network poller descriptor.</code></span>
<span class="codeline" id="line-65"><code>//</code></span>
<span class="codeline" id="line-66"><code>// No heap pointers.</code></span>
<span class="codeline" id="line-67"><code>//</code></span>
<span class="codeline" id="line-68"><code>//go:notinheap</code></span>
<span class="codeline" id="line-69"><code>type pollDesc struct {</code></span>
<span class="codeline" id="line-70"><code>	link *pollDesc // in pollcache, protected by pollcache.lock</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>	// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.</code></span>
<span class="codeline" id="line-73"><code>	// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.</code></span>
<span class="codeline" id="line-74"><code>	// pollReset, pollWait, pollWaitCanceled and runtimeÂ·netpollready (IO readiness notification)</code></span>
<span class="codeline" id="line-75"><code>	// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated</code></span>
<span class="codeline" id="line-76"><code>	// in a lock-free way by all operations.</code></span>
<span class="codeline" id="line-77"><code>	// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),</code></span>
<span class="codeline" id="line-78"><code>	// that will blow up when GC starts moving objects.</code></span>
<span class="codeline" id="line-79"><code>	lock    mutex // protects the following fields</code></span>
<span class="codeline" id="line-80"><code>	fd      uintptr</code></span>
<span class="codeline" id="line-81"><code>	closing bool</code></span>
<span class="codeline" id="line-82"><code>	everr   bool      // marks event scanning error happened</code></span>
<span class="codeline" id="line-83"><code>	user    uint32    // user settable cookie</code></span>
<span class="codeline" id="line-84"><code>	rseq    uintptr   // protects from stale read timers</code></span>
<span class="codeline" id="line-85"><code>	rg      uintptr   // pdReady, pdWait, G waiting for read or nil</code></span>
<span class="codeline" id="line-86"><code>	rt      timer     // read deadline timer (set if rt.f != nil)</code></span>
<span class="codeline" id="line-87"><code>	rd      int64     // read deadline</code></span>
<span class="codeline" id="line-88"><code>	wseq    uintptr   // protects from stale write timers</code></span>
<span class="codeline" id="line-89"><code>	wg      uintptr   // pdReady, pdWait, G waiting for write or nil</code></span>
<span class="codeline" id="line-90"><code>	wt      timer     // write deadline timer</code></span>
<span class="codeline" id="line-91"><code>	wd      int64     // write deadline</code></span>
<span class="codeline" id="line-92"><code>	self    *pollDesc // storage for indirect interface. See (*pollDesc).makeArg.</code></span>
<span class="codeline" id="line-93"><code>}</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>type pollCache struct {</code></span>
<span class="codeline" id="line-96"><code>	lock  mutex</code></span>
<span class="codeline" id="line-97"><code>	first *pollDesc</code></span>
<span class="codeline" id="line-98"><code>	// PollDesc objects must be type-stable,</code></span>
<span class="codeline" id="line-99"><code>	// because we can get ready notification from epoll/kqueue</code></span>
<span class="codeline" id="line-100"><code>	// after the descriptor is closed/reused.</code></span>
<span class="codeline" id="line-101"><code>	// Stale notifications are detected using seq variable,</code></span>
<span class="codeline" id="line-102"><code>	// seq is incremented when deadlines are changed or descriptor is reused.</code></span>
<span class="codeline" id="line-103"><code>}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>var (</code></span>
<span class="codeline" id="line-106"><code>	netpollInitLock mutex</code></span>
<span class="codeline" id="line-107"><code>	netpollInited   uint32</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>	pollcache      pollCache</code></span>
<span class="codeline" id="line-110"><code>	netpollWaiters uint32</code></span>
<span class="codeline" id="line-111"><code>)</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</code></span>
<span class="codeline" id="line-114"><code>func poll_runtime_pollServerInit() {</code></span>
<span class="codeline" id="line-115"><code>	netpollGenericInit()</code></span>
<span class="codeline" id="line-116"><code>}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>func netpollGenericInit() {</code></span>
<span class="codeline" id="line-119"><code>	if atomic.Load(&amp;netpollInited) == 0 {</code></span>
<span class="codeline" id="line-120"><code>		lockInit(&amp;netpollInitLock, lockRankNetpollInit)</code></span>
<span class="codeline" id="line-121"><code>		lock(&amp;netpollInitLock)</code></span>
<span class="codeline" id="line-122"><code>		if netpollInited == 0 {</code></span>
<span class="codeline" id="line-123"><code>			netpollinit()</code></span>
<span class="codeline" id="line-124"><code>			atomic.Store(&amp;netpollInited, 1)</code></span>
<span class="codeline" id="line-125"><code>		}</code></span>
<span class="codeline" id="line-126"><code>		unlock(&amp;netpollInitLock)</code></span>
<span class="codeline" id="line-127"><code>	}</code></span>
<span class="codeline" id="line-128"><code>}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>func netpollinited() bool {</code></span>
<span class="codeline" id="line-131"><code>	return atomic.Load(&amp;netpollInited) != 0</code></span>
<span class="codeline" id="line-132"><code>}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>//go:linkname poll_runtime_isPollServerDescriptor internal/poll.runtime_isPollServerDescriptor</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// poll_runtime_isPollServerDescriptor reports whether fd is a</code></span>
<span class="codeline" id="line-137"><code>// descriptor being used by netpoll.</code></span>
<span class="codeline" id="line-138"><code>func poll_runtime_isPollServerDescriptor(fd uintptr) bool {</code></span>
<span class="codeline" id="line-139"><code>	return netpollIsPollDescriptor(fd)</code></span>
<span class="codeline" id="line-140"><code>}</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</code></span>
<span class="codeline" id="line-143"><code>func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {</code></span>
<span class="codeline" id="line-144"><code>	pd := pollcache.alloc()</code></span>
<span class="codeline" id="line-145"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-146"><code>	if pd.wg != 0 &amp;&amp; pd.wg != pdReady {</code></span>
<span class="codeline" id="line-147"><code>		throw("runtime: blocked write on free polldesc")</code></span>
<span class="codeline" id="line-148"><code>	}</code></span>
<span class="codeline" id="line-149"><code>	if pd.rg != 0 &amp;&amp; pd.rg != pdReady {</code></span>
<span class="codeline" id="line-150"><code>		throw("runtime: blocked read on free polldesc")</code></span>
<span class="codeline" id="line-151"><code>	}</code></span>
<span class="codeline" id="line-152"><code>	pd.fd = fd</code></span>
<span class="codeline" id="line-153"><code>	pd.closing = false</code></span>
<span class="codeline" id="line-154"><code>	pd.everr = false</code></span>
<span class="codeline" id="line-155"><code>	pd.rseq++</code></span>
<span class="codeline" id="line-156"><code>	pd.rg = 0</code></span>
<span class="codeline" id="line-157"><code>	pd.rd = 0</code></span>
<span class="codeline" id="line-158"><code>	pd.wseq++</code></span>
<span class="codeline" id="line-159"><code>	pd.wg = 0</code></span>
<span class="codeline" id="line-160"><code>	pd.wd = 0</code></span>
<span class="codeline" id="line-161"><code>	pd.self = pd</code></span>
<span class="codeline" id="line-162"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	var errno int32</code></span>
<span class="codeline" id="line-165"><code>	errno = netpollopen(fd, pd)</code></span>
<span class="codeline" id="line-166"><code>	return pd, int(errno)</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>//go:linkname poll_runtime_pollClose internal/poll.runtime_pollClose</code></span>
<span class="codeline" id="line-170"><code>func poll_runtime_pollClose(pd *pollDesc) {</code></span>
<span class="codeline" id="line-171"><code>	if !pd.closing {</code></span>
<span class="codeline" id="line-172"><code>		throw("runtime: close polldesc w/o unblock")</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code>	if pd.wg != 0 &amp;&amp; pd.wg != pdReady {</code></span>
<span class="codeline" id="line-175"><code>		throw("runtime: blocked write on closing polldesc")</code></span>
<span class="codeline" id="line-176"><code>	}</code></span>
<span class="codeline" id="line-177"><code>	if pd.rg != 0 &amp;&amp; pd.rg != pdReady {</code></span>
<span class="codeline" id="line-178"><code>		throw("runtime: blocked read on closing polldesc")</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>	netpollclose(pd.fd)</code></span>
<span class="codeline" id="line-181"><code>	pollcache.free(pd)</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>func (c *pollCache) free(pd *pollDesc) {</code></span>
<span class="codeline" id="line-185"><code>	lock(&amp;c.lock)</code></span>
<span class="codeline" id="line-186"><code>	pd.link = c.first</code></span>
<span class="codeline" id="line-187"><code>	c.first = pd</code></span>
<span class="codeline" id="line-188"><code>	unlock(&amp;c.lock)</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// poll_runtime_pollReset, which is internal/poll.runtime_pollReset,</code></span>
<span class="codeline" id="line-192"><code>// prepares a descriptor for polling in mode, which is 'r' or 'w'.</code></span>
<span class="codeline" id="line-193"><code>// This returns an error code; the codes are defined above.</code></span>
<span class="codeline" id="line-194"><code>//go:linkname poll_runtime_pollReset internal/poll.runtime_pollReset</code></span>
<span class="codeline" id="line-195"><code>func poll_runtime_pollReset(pd *pollDesc, mode int) int {</code></span>
<span class="codeline" id="line-196"><code>	errcode := netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-197"><code>	if errcode != pollNoError {</code></span>
<span class="codeline" id="line-198"><code>		return errcode</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	if mode == 'r' {</code></span>
<span class="codeline" id="line-201"><code>		pd.rg = 0</code></span>
<span class="codeline" id="line-202"><code>	} else if mode == 'w' {</code></span>
<span class="codeline" id="line-203"><code>		pd.wg = 0</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	return pollNoError</code></span>
<span class="codeline" id="line-206"><code>}</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>// poll_runtime_pollWait, which is internal/poll.runtime_pollWait,</code></span>
<span class="codeline" id="line-209"><code>// waits for a descriptor to be ready for reading or writing,</code></span>
<span class="codeline" id="line-210"><code>// according to mode, which is 'r' or 'w'.</code></span>
<span class="codeline" id="line-211"><code>// This returns an error code; the codes are defined above.</code></span>
<span class="codeline" id="line-212"><code>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</code></span>
<span class="codeline" id="line-213"><code>func poll_runtime_pollWait(pd *pollDesc, mode int) int {</code></span>
<span class="codeline" id="line-214"><code>	errcode := netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-215"><code>	if errcode != pollNoError {</code></span>
<span class="codeline" id="line-216"><code>		return errcode</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	// As for now only Solaris, illumos, and AIX use level-triggered IO.</code></span>
<span class="codeline" id="line-219"><code>	if GOOS == "solaris" || GOOS == "illumos" || GOOS == "aix" {</code></span>
<span class="codeline" id="line-220"><code>		netpollarm(pd, mode)</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	for !netpollblock(pd, int32(mode), false) {</code></span>
<span class="codeline" id="line-223"><code>		errcode = netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-224"><code>		if errcode != pollNoError {</code></span>
<span class="codeline" id="line-225"><code>			return errcode</code></span>
<span class="codeline" id="line-226"><code>		}</code></span>
<span class="codeline" id="line-227"><code>		// Can happen if timeout has fired and unblocked us,</code></span>
<span class="codeline" id="line-228"><code>		// but before we had a chance to run, timeout has been reset.</code></span>
<span class="codeline" id="line-229"><code>		// Pretend it has not happened and retry.</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	return pollNoError</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>//go:linkname poll_runtime_pollWaitCanceled internal/poll.runtime_pollWaitCanceled</code></span>
<span class="codeline" id="line-235"><code>func poll_runtime_pollWaitCanceled(pd *pollDesc, mode int) {</code></span>
<span class="codeline" id="line-236"><code>	// This function is used only on windows after a failed attempt to cancel</code></span>
<span class="codeline" id="line-237"><code>	// a pending async IO operation. Wait for ioready, ignore closing or timeouts.</code></span>
<span class="codeline" id="line-238"><code>	for !netpollblock(pd, int32(mode), true) {</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</code></span>
<span class="codeline" id="line-243"><code>func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {</code></span>
<span class="codeline" id="line-244"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-245"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-246"><code>		unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-247"><code>		return</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code>	rd0, wd0 := pd.rd, pd.wd</code></span>
<span class="codeline" id="line-250"><code>	combo0 := rd0 &gt; 0 &amp;&amp; rd0 == wd0</code></span>
<span class="codeline" id="line-251"><code>	if d &gt; 0 {</code></span>
<span class="codeline" id="line-252"><code>		d += nanotime()</code></span>
<span class="codeline" id="line-253"><code>		if d &lt;= 0 {</code></span>
<span class="codeline" id="line-254"><code>			// If the user has a deadline in the future, but the delay calculation</code></span>
<span class="codeline" id="line-255"><code>			// overflows, then set the deadline to the maximum possible value.</code></span>
<span class="codeline" id="line-256"><code>			d = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-257"><code>		}</code></span>
<span class="codeline" id="line-258"><code>	}</code></span>
<span class="codeline" id="line-259"><code>	if mode == 'r' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-260"><code>		pd.rd = d</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>	if mode == 'w' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-263"><code>		pd.wd = d</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>	combo := pd.rd &gt; 0 &amp;&amp; pd.rd == pd.wd</code></span>
<span class="codeline" id="line-266"><code>	rtf := netpollReadDeadline</code></span>
<span class="codeline" id="line-267"><code>	if combo {</code></span>
<span class="codeline" id="line-268"><code>		rtf = netpollDeadline</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	if pd.rt.f == nil {</code></span>
<span class="codeline" id="line-271"><code>		if pd.rd &gt; 0 {</code></span>
<span class="codeline" id="line-272"><code>			pd.rt.f = rtf</code></span>
<span class="codeline" id="line-273"><code>			// Copy current seq into the timer arg.</code></span>
<span class="codeline" id="line-274"><code>			// Timer func will check the seq against current descriptor seq,</code></span>
<span class="codeline" id="line-275"><code>			// if they differ the descriptor was reused or timers were reset.</code></span>
<span class="codeline" id="line-276"><code>			pd.rt.arg = pd.makeArg()</code></span>
<span class="codeline" id="line-277"><code>			pd.rt.seq = pd.rseq</code></span>
<span class="codeline" id="line-278"><code>			resettimer(&amp;pd.rt, pd.rd)</code></span>
<span class="codeline" id="line-279"><code>		}</code></span>
<span class="codeline" id="line-280"><code>	} else if pd.rd != rd0 || combo != combo0 {</code></span>
<span class="codeline" id="line-281"><code>		pd.rseq++ // invalidate current timers</code></span>
<span class="codeline" id="line-282"><code>		if pd.rd &gt; 0 {</code></span>
<span class="codeline" id="line-283"><code>			modtimer(&amp;pd.rt, pd.rd, 0, rtf, pd.makeArg(), pd.rseq)</code></span>
<span class="codeline" id="line-284"><code>		} else {</code></span>
<span class="codeline" id="line-285"><code>			deltimer(&amp;pd.rt)</code></span>
<span class="codeline" id="line-286"><code>			pd.rt.f = nil</code></span>
<span class="codeline" id="line-287"><code>		}</code></span>
<span class="codeline" id="line-288"><code>	}</code></span>
<span class="codeline" id="line-289"><code>	if pd.wt.f == nil {</code></span>
<span class="codeline" id="line-290"><code>		if pd.wd &gt; 0 &amp;&amp; !combo {</code></span>
<span class="codeline" id="line-291"><code>			pd.wt.f = netpollWriteDeadline</code></span>
<span class="codeline" id="line-292"><code>			pd.wt.arg = pd.makeArg()</code></span>
<span class="codeline" id="line-293"><code>			pd.wt.seq = pd.wseq</code></span>
<span class="codeline" id="line-294"><code>			resettimer(&amp;pd.wt, pd.wd)</code></span>
<span class="codeline" id="line-295"><code>		}</code></span>
<span class="codeline" id="line-296"><code>	} else if pd.wd != wd0 || combo != combo0 {</code></span>
<span class="codeline" id="line-297"><code>		pd.wseq++ // invalidate current timers</code></span>
<span class="codeline" id="line-298"><code>		if pd.wd &gt; 0 &amp;&amp; !combo {</code></span>
<span class="codeline" id="line-299"><code>			modtimer(&amp;pd.wt, pd.wd, 0, netpollWriteDeadline, pd.makeArg(), pd.wseq)</code></span>
<span class="codeline" id="line-300"><code>		} else {</code></span>
<span class="codeline" id="line-301"><code>			deltimer(&amp;pd.wt)</code></span>
<span class="codeline" id="line-302"><code>			pd.wt.f = nil</code></span>
<span class="codeline" id="line-303"><code>		}</code></span>
<span class="codeline" id="line-304"><code>	}</code></span>
<span class="codeline" id="line-305"><code>	// If we set the new deadline in the past, unblock currently pending IO if any.</code></span>
<span class="codeline" id="line-306"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-307"><code>	if pd.rd &lt; 0 || pd.wd &lt; 0 {</code></span>
<span class="codeline" id="line-308"><code>		atomic.StorepNoWB(noescape(unsafe.Pointer(&amp;wg)), nil) // full memory barrier between stores to rd/wd and load of rg/wg in netpollunblock</code></span>
<span class="codeline" id="line-309"><code>		if pd.rd &lt; 0 {</code></span>
<span class="codeline" id="line-310"><code>			rg = netpollunblock(pd, 'r', false)</code></span>
<span class="codeline" id="line-311"><code>		}</code></span>
<span class="codeline" id="line-312"><code>		if pd.wd &lt; 0 {</code></span>
<span class="codeline" id="line-313"><code>			wg = netpollunblock(pd, 'w', false)</code></span>
<span class="codeline" id="line-314"><code>		}</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-317"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-318"><code>		netpollgoready(rg, 3)</code></span>
<span class="codeline" id="line-319"><code>	}</code></span>
<span class="codeline" id="line-320"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-321"><code>		netpollgoready(wg, 3)</code></span>
<span class="codeline" id="line-322"><code>	}</code></span>
<span class="codeline" id="line-323"><code>}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>//go:linkname poll_runtime_pollUnblock internal/poll.runtime_pollUnblock</code></span>
<span class="codeline" id="line-326"><code>func poll_runtime_pollUnblock(pd *pollDesc) {</code></span>
<span class="codeline" id="line-327"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-328"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-329"><code>		throw("runtime: unblock on closing polldesc")</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	pd.closing = true</code></span>
<span class="codeline" id="line-332"><code>	pd.rseq++</code></span>
<span class="codeline" id="line-333"><code>	pd.wseq++</code></span>
<span class="codeline" id="line-334"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-335"><code>	atomic.StorepNoWB(noescape(unsafe.Pointer(&amp;rg)), nil) // full memory barrier between store to closing and read of rg/wg in netpollunblock</code></span>
<span class="codeline" id="line-336"><code>	rg = netpollunblock(pd, 'r', false)</code></span>
<span class="codeline" id="line-337"><code>	wg = netpollunblock(pd, 'w', false)</code></span>
<span class="codeline" id="line-338"><code>	if pd.rt.f != nil {</code></span>
<span class="codeline" id="line-339"><code>		deltimer(&amp;pd.rt)</code></span>
<span class="codeline" id="line-340"><code>		pd.rt.f = nil</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code>	if pd.wt.f != nil {</code></span>
<span class="codeline" id="line-343"><code>		deltimer(&amp;pd.wt)</code></span>
<span class="codeline" id="line-344"><code>		pd.wt.f = nil</code></span>
<span class="codeline" id="line-345"><code>	}</code></span>
<span class="codeline" id="line-346"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-347"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-348"><code>		netpollgoready(rg, 3)</code></span>
<span class="codeline" id="line-349"><code>	}</code></span>
<span class="codeline" id="line-350"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-351"><code>		netpollgoready(wg, 3)</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code>}</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>// netpollready is called by the platform-specific netpoll function.</code></span>
<span class="codeline" id="line-356"><code>// It declares that the fd associated with pd is ready for I/O.</code></span>
<span class="codeline" id="line-357"><code>// The toRun argument is used to build a list of goroutines to return</code></span>
<span class="codeline" id="line-358"><code>// from netpoll. The mode argument is 'r', 'w', or 'r'+'w' to indicate</code></span>
<span class="codeline" id="line-359"><code>// whether the fd is ready for reading or writing or both.</code></span>
<span class="codeline" id="line-360"><code>//</code></span>
<span class="codeline" id="line-361"><code>// This may run while the world is stopped, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-362"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-363"><code>func netpollready(toRun *gList, pd *pollDesc, mode int32) {</code></span>
<span class="codeline" id="line-364"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-365"><code>	if mode == 'r' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-366"><code>		rg = netpollunblock(pd, 'r', true)</code></span>
<span class="codeline" id="line-367"><code>	}</code></span>
<span class="codeline" id="line-368"><code>	if mode == 'w' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-369"><code>		wg = netpollunblock(pd, 'w', true)</code></span>
<span class="codeline" id="line-370"><code>	}</code></span>
<span class="codeline" id="line-371"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-372"><code>		toRun.push(rg)</code></span>
<span class="codeline" id="line-373"><code>	}</code></span>
<span class="codeline" id="line-374"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-375"><code>		toRun.push(wg)</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code>}</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>func netpollcheckerr(pd *pollDesc, mode int32) int {</code></span>
<span class="codeline" id="line-380"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-381"><code>		return pollErrClosing</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code>	if (mode == 'r' &amp;&amp; pd.rd &lt; 0) || (mode == 'w' &amp;&amp; pd.wd &lt; 0) {</code></span>
<span class="codeline" id="line-384"><code>		return pollErrTimeout</code></span>
<span class="codeline" id="line-385"><code>	}</code></span>
<span class="codeline" id="line-386"><code>	// Report an event scanning error only on a read event.</code></span>
<span class="codeline" id="line-387"><code>	// An error on a write event will be captured in a subsequent</code></span>
<span class="codeline" id="line-388"><code>	// write call that is able to report a more specific error.</code></span>
<span class="codeline" id="line-389"><code>	if mode == 'r' &amp;&amp; pd.everr {</code></span>
<span class="codeline" id="line-390"><code>		return pollErrNotPollable</code></span>
<span class="codeline" id="line-391"><code>	}</code></span>
<span class="codeline" id="line-392"><code>	return pollNoError</code></span>
<span class="codeline" id="line-393"><code>}</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>func netpollblockcommit(gp *g, gpp unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-396"><code>	r := atomic.Casuintptr((*uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))</code></span>
<span class="codeline" id="line-397"><code>	if r {</code></span>
<span class="codeline" id="line-398"><code>		// Bump the count of goroutines waiting for the poller.</code></span>
<span class="codeline" id="line-399"><code>		// The scheduler uses this to decide whether to block</code></span>
<span class="codeline" id="line-400"><code>		// waiting for the poller if there is nothing else to do.</code></span>
<span class="codeline" id="line-401"><code>		atomic.Xadd(&amp;netpollWaiters, 1)</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code>	return r</code></span>
<span class="codeline" id="line-404"><code>}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>func netpollgoready(gp *g, traceskip int) {</code></span>
<span class="codeline" id="line-407"><code>	atomic.Xadd(&amp;netpollWaiters, -1)</code></span>
<span class="codeline" id="line-408"><code>	goready(gp, traceskip+1)</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>// returns true if IO is ready, or false if timedout or closed</code></span>
<span class="codeline" id="line-412"><code>// waitio - wait only for completed IO, ignore errors</code></span>
<span class="codeline" id="line-413"><code>func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {</code></span>
<span class="codeline" id="line-414"><code>	gpp := &amp;pd.rg</code></span>
<span class="codeline" id="line-415"><code>	if mode == 'w' {</code></span>
<span class="codeline" id="line-416"><code>		gpp = &amp;pd.wg</code></span>
<span class="codeline" id="line-417"><code>	}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>	// set the gpp semaphore to pdWait</code></span>
<span class="codeline" id="line-420"><code>	for {</code></span>
<span class="codeline" id="line-421"><code>		old := *gpp</code></span>
<span class="codeline" id="line-422"><code>		if old == pdReady {</code></span>
<span class="codeline" id="line-423"><code>			*gpp = 0</code></span>
<span class="codeline" id="line-424"><code>			return true</code></span>
<span class="codeline" id="line-425"><code>		}</code></span>
<span class="codeline" id="line-426"><code>		if old != 0 {</code></span>
<span class="codeline" id="line-427"><code>			throw("runtime: double wait")</code></span>
<span class="codeline" id="line-428"><code>		}</code></span>
<span class="codeline" id="line-429"><code>		if atomic.Casuintptr(gpp, 0, pdWait) {</code></span>
<span class="codeline" id="line-430"><code>			break</code></span>
<span class="codeline" id="line-431"><code>		}</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>	// need to recheck error states after setting gpp to pdWait</code></span>
<span class="codeline" id="line-435"><code>	// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</code></span>
<span class="codeline" id="line-436"><code>	// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg</code></span>
<span class="codeline" id="line-437"><code>	if waitio || netpollcheckerr(pd, mode) == 0 {</code></span>
<span class="codeline" id="line-438"><code>		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)</code></span>
<span class="codeline" id="line-439"><code>	}</code></span>
<span class="codeline" id="line-440"><code>	// be careful to not lose concurrent pdReady notification</code></span>
<span class="codeline" id="line-441"><code>	old := atomic.Xchguintptr(gpp, 0)</code></span>
<span class="codeline" id="line-442"><code>	if old &gt; pdWait {</code></span>
<span class="codeline" id="line-443"><code>		throw("runtime: corrupted polldesc")</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code>	return old == pdReady</code></span>
<span class="codeline" id="line-446"><code>}</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {</code></span>
<span class="codeline" id="line-449"><code>	gpp := &amp;pd.rg</code></span>
<span class="codeline" id="line-450"><code>	if mode == 'w' {</code></span>
<span class="codeline" id="line-451"><code>		gpp = &amp;pd.wg</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>	for {</code></span>
<span class="codeline" id="line-455"><code>		old := *gpp</code></span>
<span class="codeline" id="line-456"><code>		if old == pdReady {</code></span>
<span class="codeline" id="line-457"><code>			return nil</code></span>
<span class="codeline" id="line-458"><code>		}</code></span>
<span class="codeline" id="line-459"><code>		if old == 0 &amp;&amp; !ioready {</code></span>
<span class="codeline" id="line-460"><code>			// Only set pdReady for ioready. runtime_pollWait</code></span>
<span class="codeline" id="line-461"><code>			// will check for timeout/cancel before waiting.</code></span>
<span class="codeline" id="line-462"><code>			return nil</code></span>
<span class="codeline" id="line-463"><code>		}</code></span>
<span class="codeline" id="line-464"><code>		var new uintptr</code></span>
<span class="codeline" id="line-465"><code>		if ioready {</code></span>
<span class="codeline" id="line-466"><code>			new = pdReady</code></span>
<span class="codeline" id="line-467"><code>		}</code></span>
<span class="codeline" id="line-468"><code>		if atomic.Casuintptr(gpp, old, new) {</code></span>
<span class="codeline" id="line-469"><code>			if old == pdWait {</code></span>
<span class="codeline" id="line-470"><code>				old = 0</code></span>
<span class="codeline" id="line-471"><code>			}</code></span>
<span class="codeline" id="line-472"><code>			return (*g)(unsafe.Pointer(old))</code></span>
<span class="codeline" id="line-473"><code>		}</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool) {</code></span>
<span class="codeline" id="line-478"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-479"><code>	// Seq arg is seq when the timer was set.</code></span>
<span class="codeline" id="line-480"><code>	// If it's stale, ignore the timer event.</code></span>
<span class="codeline" id="line-481"><code>	currentSeq := pd.rseq</code></span>
<span class="codeline" id="line-482"><code>	if !read {</code></span>
<span class="codeline" id="line-483"><code>		currentSeq = pd.wseq</code></span>
<span class="codeline" id="line-484"><code>	}</code></span>
<span class="codeline" id="line-485"><code>	if seq != currentSeq {</code></span>
<span class="codeline" id="line-486"><code>		// The descriptor was reused or timers were reset.</code></span>
<span class="codeline" id="line-487"><code>		unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-488"><code>		return</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code>	var rg *g</code></span>
<span class="codeline" id="line-491"><code>	if read {</code></span>
<span class="codeline" id="line-492"><code>		if pd.rd &lt;= 0 || pd.rt.f == nil {</code></span>
<span class="codeline" id="line-493"><code>			throw("runtime: inconsistent read deadline")</code></span>
<span class="codeline" id="line-494"><code>		}</code></span>
<span class="codeline" id="line-495"><code>		pd.rd = -1</code></span>
<span class="codeline" id="line-496"><code>		atomic.StorepNoWB(unsafe.Pointer(&amp;pd.rt.f), nil) // full memory barrier between store to rd and load of rg in netpollunblock</code></span>
<span class="codeline" id="line-497"><code>		rg = netpollunblock(pd, 'r', false)</code></span>
<span class="codeline" id="line-498"><code>	}</code></span>
<span class="codeline" id="line-499"><code>	var wg *g</code></span>
<span class="codeline" id="line-500"><code>	if write {</code></span>
<span class="codeline" id="line-501"><code>		if pd.wd &lt;= 0 || pd.wt.f == nil &amp;&amp; !read {</code></span>
<span class="codeline" id="line-502"><code>			throw("runtime: inconsistent write deadline")</code></span>
<span class="codeline" id="line-503"><code>		}</code></span>
<span class="codeline" id="line-504"><code>		pd.wd = -1</code></span>
<span class="codeline" id="line-505"><code>		atomic.StorepNoWB(unsafe.Pointer(&amp;pd.wt.f), nil) // full memory barrier between store to wd and load of wg in netpollunblock</code></span>
<span class="codeline" id="line-506"><code>		wg = netpollunblock(pd, 'w', false)</code></span>
<span class="codeline" id="line-507"><code>	}</code></span>
<span class="codeline" id="line-508"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-509"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-510"><code>		netpollgoready(rg, 0)</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-513"><code>		netpollgoready(wg, 0)</code></span>
<span class="codeline" id="line-514"><code>	}</code></span>
<span class="codeline" id="line-515"><code>}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>func netpollDeadline(arg interface{}, seq uintptr) {</code></span>
<span class="codeline" id="line-518"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, true, true)</code></span>
<span class="codeline" id="line-519"><code>}</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>func netpollReadDeadline(arg interface{}, seq uintptr) {</code></span>
<span class="codeline" id="line-522"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, true, false)</code></span>
<span class="codeline" id="line-523"><code>}</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>func netpollWriteDeadline(arg interface{}, seq uintptr) {</code></span>
<span class="codeline" id="line-526"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, false, true)</code></span>
<span class="codeline" id="line-527"><code>}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>func (c *pollCache) alloc() *pollDesc {</code></span>
<span class="codeline" id="line-530"><code>	lock(&amp;c.lock)</code></span>
<span class="codeline" id="line-531"><code>	if c.first == nil {</code></span>
<span class="codeline" id="line-532"><code>		const pdSize = unsafe.Sizeof(pollDesc{})</code></span>
<span class="codeline" id="line-533"><code>		n := pollBlockSize / pdSize</code></span>
<span class="codeline" id="line-534"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-535"><code>			n = 1</code></span>
<span class="codeline" id="line-536"><code>		}</code></span>
<span class="codeline" id="line-537"><code>		// Must be in non-GC memory because can be referenced</code></span>
<span class="codeline" id="line-538"><code>		// only from epoll/kqueue internals.</code></span>
<span class="codeline" id="line-539"><code>		mem := persistentalloc(n*pdSize, 0, &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-540"><code>		for i := uintptr(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-541"><code>			pd := (*pollDesc)(add(mem, i*pdSize))</code></span>
<span class="codeline" id="line-542"><code>			pd.link = c.first</code></span>
<span class="codeline" id="line-543"><code>			c.first = pd</code></span>
<span class="codeline" id="line-544"><code>		}</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code>	pd := c.first</code></span>
<span class="codeline" id="line-547"><code>	c.first = pd.link</code></span>
<span class="codeline" id="line-548"><code>	lockInit(&amp;pd.lock, lockRankPollDesc)</code></span>
<span class="codeline" id="line-549"><code>	unlock(&amp;c.lock)</code></span>
<span class="codeline" id="line-550"><code>	return pd</code></span>
<span class="codeline" id="line-551"><code>}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>// makeArg converts pd to an interface{}.</code></span>
<span class="codeline" id="line-554"><code>// makeArg does not do any allocation. Normally, such</code></span>
<span class="codeline" id="line-555"><code>// a conversion requires an allocation because pointers to</code></span>
<span class="codeline" id="line-556"><code>// go:notinheap types (which pollDesc is) must be stored</code></span>
<span class="codeline" id="line-557"><code>// in interfaces indirectly. See issue 42076.</code></span>
<span class="codeline" id="line-558"><code>func (pd *pollDesc) makeArg() (i interface{}) {</code></span>
<span class="codeline" id="line-559"><code>	x := (*eface)(unsafe.Pointer(&amp;i))</code></span>
<span class="codeline" id="line-560"><code>	x._type = pdType</code></span>
<span class="codeline" id="line-561"><code>	x.data = unsafe.Pointer(&amp;pd.self)</code></span>
<span class="codeline" id="line-562"><code>	return</code></span>
<span class="codeline" id="line-563"><code>}</code></span>
<span class="codeline" id="line-564"><code></code></span>
<span class="codeline" id="line-565"><code>var (</code></span>
<span class="codeline" id="line-566"><code>	pdEface interface{} = (*pollDesc)(nil)</code></span>
<span class="codeline" id="line-567"><code>	pdType  *_type      = efaceOf(&amp;pdEface)._type</code></span>
<span class="codeline" id="line-568"><code>)</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>