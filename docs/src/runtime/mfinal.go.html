<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mfinal.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mfinal.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Garbage collector: finalizers and block profiling.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-12"><code>	"unsafe"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// finblock is an array of finalizers to be executed. finblocks are</code></span>
<span class="codeline" id="line-16"><code>// arranged in a linked list for the finalizer queue.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// finblock is allocated from non-GC'd memory, so any heap pointers</code></span>
<span class="codeline" id="line-19"><code>// must be specially handled. GC currently assumes that the finalizer</code></span>
<span class="codeline" id="line-20"><code>// queue does not grow during marking (but it can shrink).</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>//go:notinheap</code></span>
<span class="codeline" id="line-23"><code>type finblock struct {</code></span>
<span class="codeline" id="line-24"><code>	alllink *finblock</code></span>
<span class="codeline" id="line-25"><code>	next    *finblock</code></span>
<span class="codeline" id="line-26"><code>	cnt     uint32</code></span>
<span class="codeline" id="line-27"><code>	_       int32</code></span>
<span class="codeline" id="line-28"><code>	fin     [(_FinBlockSize - 2*sys.PtrSize - 2*4) / unsafe.Sizeof(finalizer{})]finalizer</code></span>
<span class="codeline" id="line-29"><code>}</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>var finlock mutex  // protects the following variables</code></span>
<span class="codeline" id="line-32"><code>var fing *g        // goroutine that runs finalizers</code></span>
<span class="codeline" id="line-33"><code>var finq *finblock // list of finalizers that are to be executed</code></span>
<span class="codeline" id="line-34"><code>var finc *finblock // cache of free blocks</code></span>
<span class="codeline" id="line-35"><code>var finptrmask [_FinBlockSize / sys.PtrSize / 8]byte</code></span>
<span class="codeline" id="line-36"><code>var fingwait bool</code></span>
<span class="codeline" id="line-37"><code>var fingwake bool</code></span>
<span class="codeline" id="line-38"><code>var allfin *finblock // list of all blocks</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>// NOTE: Layout known to queuefinalizer.</code></span>
<span class="codeline" id="line-41"><code>type finalizer struct {</code></span>
<span class="codeline" id="line-42"><code>	fn   *funcval       // function to call (may be a heap pointer)</code></span>
<span class="codeline" id="line-43"><code>	arg  unsafe.Pointer // ptr to object (may be a heap pointer)</code></span>
<span class="codeline" id="line-44"><code>	nret uintptr        // bytes of return values from fn</code></span>
<span class="codeline" id="line-45"><code>	fint *_type         // type of first argument of fn</code></span>
<span class="codeline" id="line-46"><code>	ot   *ptrtype       // type of ptr to object (may be a heap pointer)</code></span>
<span class="codeline" id="line-47"><code>}</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>var finalizer1 = [...]byte{</code></span>
<span class="codeline" id="line-50"><code>	// Each Finalizer is 5 words, ptr ptr INT ptr ptr (INT = uintptr here)</code></span>
<span class="codeline" id="line-51"><code>	// Each byte describes 8 words.</code></span>
<span class="codeline" id="line-52"><code>	// Need 8 Finalizers described by 5 bytes before pattern repeats:</code></span>
<span class="codeline" id="line-53"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-54"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-55"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-56"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-57"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-58"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-59"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-60"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-61"><code>	// aka</code></span>
<span class="codeline" id="line-62"><code>	//</code></span>
<span class="codeline" id="line-63"><code>	//	ptr ptr INT ptr ptr ptr ptr INT</code></span>
<span class="codeline" id="line-64"><code>	//	ptr ptr ptr ptr INT ptr ptr ptr</code></span>
<span class="codeline" id="line-65"><code>	//	ptr INT ptr ptr ptr ptr INT ptr</code></span>
<span class="codeline" id="line-66"><code>	//	ptr ptr ptr INT ptr ptr ptr ptr</code></span>
<span class="codeline" id="line-67"><code>	//	INT ptr ptr ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-68"><code>	//</code></span>
<span class="codeline" id="line-69"><code>	// Assumptions about Finalizer layout checked below.</code></span>
<span class="codeline" id="line-70"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 0&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 0&lt;&lt;7,</code></span>
<span class="codeline" id="line-71"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 0&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-72"><code>	1&lt;&lt;0 | 0&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 0&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-73"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 0&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-74"><code>	0&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 0&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-75"><code>}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {</code></span>
<span class="codeline" id="line-78"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-79"><code>		// Currently we assume that the finalizer queue won't</code></span>
<span class="codeline" id="line-80"><code>		// grow during marking so we don't have to rescan it</code></span>
<span class="codeline" id="line-81"><code>		// during mark termination. If we ever need to lift</code></span>
<span class="codeline" id="line-82"><code>		// this assumption, we can do it by adding the</code></span>
<span class="codeline" id="line-83"><code>		// necessary barriers to queuefinalizer (which it may</code></span>
<span class="codeline" id="line-84"><code>		// have automatically).</code></span>
<span class="codeline" id="line-85"><code>		throw("queuefinalizer during GC")</code></span>
<span class="codeline" id="line-86"><code>	}</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>	lock(&amp;finlock)</code></span>
<span class="codeline" id="line-89"><code>	if finq == nil || finq.cnt == uint32(len(finq.fin)) {</code></span>
<span class="codeline" id="line-90"><code>		if finc == nil {</code></span>
<span class="codeline" id="line-91"><code>			finc = (*finblock)(persistentalloc(_FinBlockSize, 0, &amp;memstats.gcMiscSys))</code></span>
<span class="codeline" id="line-92"><code>			finc.alllink = allfin</code></span>
<span class="codeline" id="line-93"><code>			allfin = finc</code></span>
<span class="codeline" id="line-94"><code>			if finptrmask[0] == 0 {</code></span>
<span class="codeline" id="line-95"><code>				// Build pointer mask for Finalizer array in block.</code></span>
<span class="codeline" id="line-96"><code>				// Check assumptions made in finalizer1 array above.</code></span>
<span class="codeline" id="line-97"><code>				if (unsafe.Sizeof(finalizer{}) != 5*sys.PtrSize ||</code></span>
<span class="codeline" id="line-98"><code>					unsafe.Offsetof(finalizer{}.fn) != 0 ||</code></span>
<span class="codeline" id="line-99"><code>					unsafe.Offsetof(finalizer{}.arg) != sys.PtrSize ||</code></span>
<span class="codeline" id="line-100"><code>					unsafe.Offsetof(finalizer{}.nret) != 2*sys.PtrSize ||</code></span>
<span class="codeline" id="line-101"><code>					unsafe.Offsetof(finalizer{}.fint) != 3*sys.PtrSize ||</code></span>
<span class="codeline" id="line-102"><code>					unsafe.Offsetof(finalizer{}.ot) != 4*sys.PtrSize) {</code></span>
<span class="codeline" id="line-103"><code>					throw("finalizer out of sync")</code></span>
<span class="codeline" id="line-104"><code>				}</code></span>
<span class="codeline" id="line-105"><code>				for i := range finptrmask {</code></span>
<span class="codeline" id="line-106"><code>					finptrmask[i] = finalizer1[i%len(finalizer1)]</code></span>
<span class="codeline" id="line-107"><code>				}</code></span>
<span class="codeline" id="line-108"><code>			}</code></span>
<span class="codeline" id="line-109"><code>		}</code></span>
<span class="codeline" id="line-110"><code>		block := finc</code></span>
<span class="codeline" id="line-111"><code>		finc = block.next</code></span>
<span class="codeline" id="line-112"><code>		block.next = finq</code></span>
<span class="codeline" id="line-113"><code>		finq = block</code></span>
<span class="codeline" id="line-114"><code>	}</code></span>
<span class="codeline" id="line-115"><code>	f := &amp;finq.fin[finq.cnt]</code></span>
<span class="codeline" id="line-116"><code>	atomic.Xadd(&amp;finq.cnt, +1) // Sync with markroots</code></span>
<span class="codeline" id="line-117"><code>	f.fn = fn</code></span>
<span class="codeline" id="line-118"><code>	f.nret = nret</code></span>
<span class="codeline" id="line-119"><code>	f.fint = fint</code></span>
<span class="codeline" id="line-120"><code>	f.ot = ot</code></span>
<span class="codeline" id="line-121"><code>	f.arg = p</code></span>
<span class="codeline" id="line-122"><code>	fingwake = true</code></span>
<span class="codeline" id="line-123"><code>	unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-127"><code>func iterate_finq(callback func(*funcval, unsafe.Pointer, uintptr, *_type, *ptrtype)) {</code></span>
<span class="codeline" id="line-128"><code>	for fb := allfin; fb != nil; fb = fb.alllink {</code></span>
<span class="codeline" id="line-129"><code>		for i := uint32(0); i &lt; fb.cnt; i++ {</code></span>
<span class="codeline" id="line-130"><code>			f := &amp;fb.fin[i]</code></span>
<span class="codeline" id="line-131"><code>			callback(f.fn, f.arg, f.nret, f.fint, f.ot)</code></span>
<span class="codeline" id="line-132"><code>		}</code></span>
<span class="codeline" id="line-133"><code>	}</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>func wakefing() *g {</code></span>
<span class="codeline" id="line-137"><code>	var res *g</code></span>
<span class="codeline" id="line-138"><code>	lock(&amp;finlock)</code></span>
<span class="codeline" id="line-139"><code>	if fingwait &amp;&amp; fingwake {</code></span>
<span class="codeline" id="line-140"><code>		fingwait = false</code></span>
<span class="codeline" id="line-141"><code>		fingwake = false</code></span>
<span class="codeline" id="line-142"><code>		res = fing</code></span>
<span class="codeline" id="line-143"><code>	}</code></span>
<span class="codeline" id="line-144"><code>	unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-145"><code>	return res</code></span>
<span class="codeline" id="line-146"><code>}</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>var (</code></span>
<span class="codeline" id="line-149"><code>	fingCreate  uint32</code></span>
<span class="codeline" id="line-150"><code>	fingRunning bool</code></span>
<span class="codeline" id="line-151"><code>)</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>func createfing() {</code></span>
<span class="codeline" id="line-154"><code>	// start the finalizer goroutine exactly once</code></span>
<span class="codeline" id="line-155"><code>	if fingCreate == 0 &amp;&amp; atomic.Cas(&amp;fingCreate, 0, 1) {</code></span>
<span class="codeline" id="line-156"><code>		go runfinq()</code></span>
<span class="codeline" id="line-157"><code>	}</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// This is the goroutine that runs all of the finalizers</code></span>
<span class="codeline" id="line-161"><code>func runfinq() {</code></span>
<span class="codeline" id="line-162"><code>	var (</code></span>
<span class="codeline" id="line-163"><code>		frame    unsafe.Pointer</code></span>
<span class="codeline" id="line-164"><code>		framecap uintptr</code></span>
<span class="codeline" id="line-165"><code>	)</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	for {</code></span>
<span class="codeline" id="line-168"><code>		lock(&amp;finlock)</code></span>
<span class="codeline" id="line-169"><code>		fb := finq</code></span>
<span class="codeline" id="line-170"><code>		finq = nil</code></span>
<span class="codeline" id="line-171"><code>		if fb == nil {</code></span>
<span class="codeline" id="line-172"><code>			gp := getg()</code></span>
<span class="codeline" id="line-173"><code>			fing = gp</code></span>
<span class="codeline" id="line-174"><code>			fingwait = true</code></span>
<span class="codeline" id="line-175"><code>			goparkunlock(&amp;finlock, waitReasonFinalizerWait, traceEvGoBlock, 1)</code></span>
<span class="codeline" id="line-176"><code>			continue</code></span>
<span class="codeline" id="line-177"><code>		}</code></span>
<span class="codeline" id="line-178"><code>		unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-179"><code>		if raceenabled {</code></span>
<span class="codeline" id="line-180"><code>			racefingo()</code></span>
<span class="codeline" id="line-181"><code>		}</code></span>
<span class="codeline" id="line-182"><code>		for fb != nil {</code></span>
<span class="codeline" id="line-183"><code>			for i := fb.cnt; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-184"><code>				f := &amp;fb.fin[i-1]</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>				framesz := unsafe.Sizeof((interface{})(nil)) + f.nret</code></span>
<span class="codeline" id="line-187"><code>				if framecap &lt; framesz {</code></span>
<span class="codeline" id="line-188"><code>					// The frame does not contain pointers interesting for GC,</code></span>
<span class="codeline" id="line-189"><code>					// all not yet finalized objects are stored in finq.</code></span>
<span class="codeline" id="line-190"><code>					// If we do not mark it as FlagNoScan,</code></span>
<span class="codeline" id="line-191"><code>					// the last finalized object is not collected.</code></span>
<span class="codeline" id="line-192"><code>					frame = mallocgc(framesz, nil, true)</code></span>
<span class="codeline" id="line-193"><code>					framecap = framesz</code></span>
<span class="codeline" id="line-194"><code>				}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>				if f.fint == nil {</code></span>
<span class="codeline" id="line-197"><code>					throw("missing type in runfinq")</code></span>
<span class="codeline" id="line-198"><code>				}</code></span>
<span class="codeline" id="line-199"><code>				// frame is effectively uninitialized</code></span>
<span class="codeline" id="line-200"><code>				// memory. That means we have to clear</code></span>
<span class="codeline" id="line-201"><code>				// it before writing to it to avoid</code></span>
<span class="codeline" id="line-202"><code>				// confusing the write barrier.</code></span>
<span class="codeline" id="line-203"><code>				*(*[2]uintptr)(frame) = [2]uintptr{}</code></span>
<span class="codeline" id="line-204"><code>				switch f.fint.kind &amp; kindMask {</code></span>
<span class="codeline" id="line-205"><code>				case kindPtr:</code></span>
<span class="codeline" id="line-206"><code>					// direct use of pointer</code></span>
<span class="codeline" id="line-207"><code>					*(*unsafe.Pointer)(frame) = f.arg</code></span>
<span class="codeline" id="line-208"><code>				case kindInterface:</code></span>
<span class="codeline" id="line-209"><code>					ityp := (*interfacetype)(unsafe.Pointer(f.fint))</code></span>
<span class="codeline" id="line-210"><code>					// set up with empty interface</code></span>
<span class="codeline" id="line-211"><code>					(*eface)(frame)._type = &amp;f.ot.typ</code></span>
<span class="codeline" id="line-212"><code>					(*eface)(frame).data = f.arg</code></span>
<span class="codeline" id="line-213"><code>					if len(ityp.mhdr) != 0 {</code></span>
<span class="codeline" id="line-214"><code>						// convert to interface with methods</code></span>
<span class="codeline" id="line-215"><code>						// this conversion is guaranteed to succeed - we checked in SetFinalizer</code></span>
<span class="codeline" id="line-216"><code>						*(*iface)(frame) = assertE2I(ityp, *(*eface)(frame))</code></span>
<span class="codeline" id="line-217"><code>					}</code></span>
<span class="codeline" id="line-218"><code>				default:</code></span>
<span class="codeline" id="line-219"><code>					throw("bad kind in runfinq")</code></span>
<span class="codeline" id="line-220"><code>				}</code></span>
<span class="codeline" id="line-221"><code>				fingRunning = true</code></span>
<span class="codeline" id="line-222"><code>				reflectcall(nil, unsafe.Pointer(f.fn), frame, uint32(framesz), uint32(framesz))</code></span>
<span class="codeline" id="line-223"><code>				fingRunning = false</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>				// Drop finalizer queue heap references</code></span>
<span class="codeline" id="line-226"><code>				// before hiding them from markroot.</code></span>
<span class="codeline" id="line-227"><code>				// This also ensures these will be</code></span>
<span class="codeline" id="line-228"><code>				// clear if we reuse the finalizer.</code></span>
<span class="codeline" id="line-229"><code>				f.fn = nil</code></span>
<span class="codeline" id="line-230"><code>				f.arg = nil</code></span>
<span class="codeline" id="line-231"><code>				f.ot = nil</code></span>
<span class="codeline" id="line-232"><code>				atomic.Store(&amp;fb.cnt, i-1)</code></span>
<span class="codeline" id="line-233"><code>			}</code></span>
<span class="codeline" id="line-234"><code>			next := fb.next</code></span>
<span class="codeline" id="line-235"><code>			lock(&amp;finlock)</code></span>
<span class="codeline" id="line-236"><code>			fb.next = finc</code></span>
<span class="codeline" id="line-237"><code>			finc = fb</code></span>
<span class="codeline" id="line-238"><code>			unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-239"><code>			fb = next</code></span>
<span class="codeline" id="line-240"><code>		}</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code>}</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// SetFinalizer sets the finalizer associated with obj to the provided</code></span>
<span class="codeline" id="line-245"><code>// finalizer function. When the garbage collector finds an unreachable block</code></span>
<span class="codeline" id="line-246"><code>// with an associated finalizer, it clears the association and runs</code></span>
<span class="codeline" id="line-247"><code>// finalizer(obj) in a separate goroutine. This makes obj reachable again,</code></span>
<span class="codeline" id="line-248"><code>// but now without an associated finalizer. Assuming that SetFinalizer</code></span>
<span class="codeline" id="line-249"><code>// is not called again, the next time the garbage collector sees</code></span>
<span class="codeline" id="line-250"><code>// that obj is unreachable, it will free obj.</code></span>
<span class="codeline" id="line-251"><code>//</code></span>
<span class="codeline" id="line-252"><code>// SetFinalizer(obj, nil) clears any finalizer associated with obj.</code></span>
<span class="codeline" id="line-253"><code>//</code></span>
<span class="codeline" id="line-254"><code>// The argument obj must be a pointer to an object allocated by calling</code></span>
<span class="codeline" id="line-255"><code>// new, by taking the address of a composite literal, or by taking the</code></span>
<span class="codeline" id="line-256"><code>// address of a local variable.</code></span>
<span class="codeline" id="line-257"><code>// The argument finalizer must be a function that takes a single argument</code></span>
<span class="codeline" id="line-258"><code>// to which obj's type can be assigned, and can have arbitrary ignored return</code></span>
<span class="codeline" id="line-259"><code>// values. If either of these is not true, SetFinalizer may abort the</code></span>
<span class="codeline" id="line-260"><code>// program.</code></span>
<span class="codeline" id="line-261"><code>//</code></span>
<span class="codeline" id="line-262"><code>// Finalizers are run in dependency order: if A points at B, both have</code></span>
<span class="codeline" id="line-263"><code>// finalizers, and they are otherwise unreachable, only the finalizer</code></span>
<span class="codeline" id="line-264"><code>// for A runs; once A is freed, the finalizer for B can run.</code></span>
<span class="codeline" id="line-265"><code>// If a cyclic structure includes a block with a finalizer, that</code></span>
<span class="codeline" id="line-266"><code>// cycle is not guaranteed to be garbage collected and the finalizer</code></span>
<span class="codeline" id="line-267"><code>// is not guaranteed to run, because there is no ordering that</code></span>
<span class="codeline" id="line-268"><code>// respects the dependencies.</code></span>
<span class="codeline" id="line-269"><code>//</code></span>
<span class="codeline" id="line-270"><code>// The finalizer is scheduled to run at some arbitrary time after the</code></span>
<span class="codeline" id="line-271"><code>// program can no longer reach the object to which obj points.</code></span>
<span class="codeline" id="line-272"><code>// There is no guarantee that finalizers will run before a program exits,</code></span>
<span class="codeline" id="line-273"><code>// so typically they are useful only for releasing non-memory resources</code></span>
<span class="codeline" id="line-274"><code>// associated with an object during a long-running program.</code></span>
<span class="codeline" id="line-275"><code>// For example, an os.File object could use a finalizer to close the</code></span>
<span class="codeline" id="line-276"><code>// associated operating system file descriptor when a program discards</code></span>
<span class="codeline" id="line-277"><code>// an os.File without calling Close, but it would be a mistake</code></span>
<span class="codeline" id="line-278"><code>// to depend on a finalizer to flush an in-memory I/O buffer such as a</code></span>
<span class="codeline" id="line-279"><code>// bufio.Writer, because the buffer would not be flushed at program exit.</code></span>
<span class="codeline" id="line-280"><code>//</code></span>
<span class="codeline" id="line-281"><code>// It is not guaranteed that a finalizer will run if the size of *obj is</code></span>
<span class="codeline" id="line-282"><code>// zero bytes.</code></span>
<span class="codeline" id="line-283"><code>//</code></span>
<span class="codeline" id="line-284"><code>// It is not guaranteed that a finalizer will run for objects allocated</code></span>
<span class="codeline" id="line-285"><code>// in initializers for package-level variables. Such objects may be</code></span>
<span class="codeline" id="line-286"><code>// linker-allocated, not heap-allocated.</code></span>
<span class="codeline" id="line-287"><code>//</code></span>
<span class="codeline" id="line-288"><code>// A finalizer may run as soon as an object becomes unreachable.</code></span>
<span class="codeline" id="line-289"><code>// In order to use finalizers correctly, the program must ensure that</code></span>
<span class="codeline" id="line-290"><code>// the object is reachable until it is no longer required.</code></span>
<span class="codeline" id="line-291"><code>// Objects stored in global variables, or that can be found by tracing</code></span>
<span class="codeline" id="line-292"><code>// pointers from a global variable, are reachable. For other objects,</code></span>
<span class="codeline" id="line-293"><code>// pass the object to a call of the KeepAlive function to mark the</code></span>
<span class="codeline" id="line-294"><code>// last point in the function where the object must be reachable.</code></span>
<span class="codeline" id="line-295"><code>//</code></span>
<span class="codeline" id="line-296"><code>// For example, if p points to a struct, such as os.File, that contains</code></span>
<span class="codeline" id="line-297"><code>// a file descriptor d, and p has a finalizer that closes that file</code></span>
<span class="codeline" id="line-298"><code>// descriptor, and if the last use of p in a function is a call to</code></span>
<span class="codeline" id="line-299"><code>// syscall.Write(p.d, buf, size), then p may be unreachable as soon as</code></span>
<span class="codeline" id="line-300"><code>// the program enters syscall.Write. The finalizer may run at that moment,</code></span>
<span class="codeline" id="line-301"><code>// closing p.d, causing syscall.Write to fail because it is writing to</code></span>
<span class="codeline" id="line-302"><code>// a closed file descriptor (or, worse, to an entirely different</code></span>
<span class="codeline" id="line-303"><code>// file descriptor opened by a different goroutine). To avoid this problem,</code></span>
<span class="codeline" id="line-304"><code>// call runtime.KeepAlive(p) after the call to syscall.Write.</code></span>
<span class="codeline" id="line-305"><code>//</code></span>
<span class="codeline" id="line-306"><code>// A single goroutine runs all finalizers for a program, sequentially.</code></span>
<span class="codeline" id="line-307"><code>// If a finalizer must run for a long time, it should do so by starting</code></span>
<span class="codeline" id="line-308"><code>// a new goroutine.</code></span>
<span class="codeline" id="line-309"><code>func SetFinalizer(obj interface{}, finalizer interface{}) {</code></span>
<span class="codeline" id="line-310"><code>	if debug.sbrk != 0 {</code></span>
<span class="codeline" id="line-311"><code>		// debug.sbrk never frees memory, so no finalizers run</code></span>
<span class="codeline" id="line-312"><code>		// (and we don't have the data structures to record them).</code></span>
<span class="codeline" id="line-313"><code>		return</code></span>
<span class="codeline" id="line-314"><code>	}</code></span>
<span class="codeline" id="line-315"><code>	e := efaceOf(&amp;obj)</code></span>
<span class="codeline" id="line-316"><code>	etyp := e._type</code></span>
<span class="codeline" id="line-317"><code>	if etyp == nil {</code></span>
<span class="codeline" id="line-318"><code>		throw("runtime.SetFinalizer: first argument is nil")</code></span>
<span class="codeline" id="line-319"><code>	}</code></span>
<span class="codeline" id="line-320"><code>	if etyp.kind&amp;kindMask != kindPtr {</code></span>
<span class="codeline" id="line-321"><code>		throw("runtime.SetFinalizer: first argument is " + etyp.string() + ", not pointer")</code></span>
<span class="codeline" id="line-322"><code>	}</code></span>
<span class="codeline" id="line-323"><code>	ot := (*ptrtype)(unsafe.Pointer(etyp))</code></span>
<span class="codeline" id="line-324"><code>	if ot.elem == nil {</code></span>
<span class="codeline" id="line-325"><code>		throw("nil elem type!")</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>	// find the containing object</code></span>
<span class="codeline" id="line-329"><code>	base, _, _ := findObject(uintptr(e.data), 0, 0)</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>	if base == 0 {</code></span>
<span class="codeline" id="line-332"><code>		// 0-length objects are okay.</code></span>
<span class="codeline" id="line-333"><code>		if e.data == unsafe.Pointer(&amp;zerobase) {</code></span>
<span class="codeline" id="line-334"><code>			return</code></span>
<span class="codeline" id="line-335"><code>		}</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>		// Global initializers might be linker-allocated.</code></span>
<span class="codeline" id="line-338"><code>		//	var Foo = &amp;Object{}</code></span>
<span class="codeline" id="line-339"><code>		//	func main() {</code></span>
<span class="codeline" id="line-340"><code>		//		runtime.SetFinalizer(Foo, nil)</code></span>
<span class="codeline" id="line-341"><code>		//	}</code></span>
<span class="codeline" id="line-342"><code>		// The relevant segments are: noptrdata, data, bss, noptrbss.</code></span>
<span class="codeline" id="line-343"><code>		// We cannot assume they are in any order or even contiguous,</code></span>
<span class="codeline" id="line-344"><code>		// due to external linking.</code></span>
<span class="codeline" id="line-345"><code>		for datap := &amp;firstmoduledata; datap != nil; datap = datap.next {</code></span>
<span class="codeline" id="line-346"><code>			if datap.noptrdata &lt;= uintptr(e.data) &amp;&amp; uintptr(e.data) &lt; datap.enoptrdata ||</code></span>
<span class="codeline" id="line-347"><code>				datap.data &lt;= uintptr(e.data) &amp;&amp; uintptr(e.data) &lt; datap.edata ||</code></span>
<span class="codeline" id="line-348"><code>				datap.bss &lt;= uintptr(e.data) &amp;&amp; uintptr(e.data) &lt; datap.ebss ||</code></span>
<span class="codeline" id="line-349"><code>				datap.noptrbss &lt;= uintptr(e.data) &amp;&amp; uintptr(e.data) &lt; datap.enoptrbss {</code></span>
<span class="codeline" id="line-350"><code>				return</code></span>
<span class="codeline" id="line-351"><code>			}</code></span>
<span class="codeline" id="line-352"><code>		}</code></span>
<span class="codeline" id="line-353"><code>		throw("runtime.SetFinalizer: pointer not in allocated block")</code></span>
<span class="codeline" id="line-354"><code>	}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>	if uintptr(e.data) != base {</code></span>
<span class="codeline" id="line-357"><code>		// As an implementation detail we allow to set finalizers for an inner byte</code></span>
<span class="codeline" id="line-358"><code>		// of an object if it could come from tiny alloc (see mallocgc for details).</code></span>
<span class="codeline" id="line-359"><code>		if ot.elem == nil || ot.elem.ptrdata != 0 || ot.elem.size &gt;= maxTinySize {</code></span>
<span class="codeline" id="line-360"><code>			throw("runtime.SetFinalizer: pointer not at beginning of allocated block")</code></span>
<span class="codeline" id="line-361"><code>		}</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>	f := efaceOf(&amp;finalizer)</code></span>
<span class="codeline" id="line-365"><code>	ftyp := f._type</code></span>
<span class="codeline" id="line-366"><code>	if ftyp == nil {</code></span>
<span class="codeline" id="line-367"><code>		// switch to system stack and remove finalizer</code></span>
<span class="codeline" id="line-368"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-369"><code>			removefinalizer(e.data)</code></span>
<span class="codeline" id="line-370"><code>		})</code></span>
<span class="codeline" id="line-371"><code>		return</code></span>
<span class="codeline" id="line-372"><code>	}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>	if ftyp.kind&amp;kindMask != kindFunc {</code></span>
<span class="codeline" id="line-375"><code>		throw("runtime.SetFinalizer: second argument is " + ftyp.string() + ", not a function")</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code>	ft := (*functype)(unsafe.Pointer(ftyp))</code></span>
<span class="codeline" id="line-378"><code>	if ft.dotdotdot() {</code></span>
<span class="codeline" id="line-379"><code>		throw("runtime.SetFinalizer: cannot pass " + etyp.string() + " to finalizer " + ftyp.string() + " because dotdotdot")</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	if ft.inCount != 1 {</code></span>
<span class="codeline" id="line-382"><code>		throw("runtime.SetFinalizer: cannot pass " + etyp.string() + " to finalizer " + ftyp.string())</code></span>
<span class="codeline" id="line-383"><code>	}</code></span>
<span class="codeline" id="line-384"><code>	fint := ft.in()[0]</code></span>
<span class="codeline" id="line-385"><code>	switch {</code></span>
<span class="codeline" id="line-386"><code>	case fint == etyp:</code></span>
<span class="codeline" id="line-387"><code>		// ok - same type</code></span>
<span class="codeline" id="line-388"><code>		goto okarg</code></span>
<span class="codeline" id="line-389"><code>	case fint.kind&amp;kindMask == kindPtr:</code></span>
<span class="codeline" id="line-390"><code>		if (fint.uncommon() == nil || etyp.uncommon() == nil) &amp;&amp; (*ptrtype)(unsafe.Pointer(fint)).elem == ot.elem {</code></span>
<span class="codeline" id="line-391"><code>			// ok - not same type, but both pointers,</code></span>
<span class="codeline" id="line-392"><code>			// one or the other is unnamed, and same element type, so assignable.</code></span>
<span class="codeline" id="line-393"><code>			goto okarg</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code>	case fint.kind&amp;kindMask == kindInterface:</code></span>
<span class="codeline" id="line-396"><code>		ityp := (*interfacetype)(unsafe.Pointer(fint))</code></span>
<span class="codeline" id="line-397"><code>		if len(ityp.mhdr) == 0 {</code></span>
<span class="codeline" id="line-398"><code>			// ok - satisfies empty interface</code></span>
<span class="codeline" id="line-399"><code>			goto okarg</code></span>
<span class="codeline" id="line-400"><code>		}</code></span>
<span class="codeline" id="line-401"><code>		if _, ok := assertE2I2(ityp, *efaceOf(&amp;obj)); ok {</code></span>
<span class="codeline" id="line-402"><code>			goto okarg</code></span>
<span class="codeline" id="line-403"><code>		}</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code>	throw("runtime.SetFinalizer: cannot pass " + etyp.string() + " to finalizer " + ftyp.string())</code></span>
<span class="codeline" id="line-406"><code>okarg:</code></span>
<span class="codeline" id="line-407"><code>	// compute size needed for return parameters</code></span>
<span class="codeline" id="line-408"><code>	nret := uintptr(0)</code></span>
<span class="codeline" id="line-409"><code>	for _, t := range ft.out() {</code></span>
<span class="codeline" id="line-410"><code>		nret = alignUp(nret, uintptr(t.align)) + uintptr(t.size)</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code>	nret = alignUp(nret, sys.PtrSize)</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>	// make sure we have a finalizer goroutine</code></span>
<span class="codeline" id="line-415"><code>	createfing()</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-418"><code>		if !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) {</code></span>
<span class="codeline" id="line-419"><code>			throw("runtime.SetFinalizer: finalizer already set")</code></span>
<span class="codeline" id="line-420"><code>		}</code></span>
<span class="codeline" id="line-421"><code>	})</code></span>
<span class="codeline" id="line-422"><code>}</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>// Mark KeepAlive as noinline so that it is easily detectable as an intrinsic.</code></span>
<span class="codeline" id="line-425"><code>//go:noinline</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>// KeepAlive marks its argument as currently reachable.</code></span>
<span class="codeline" id="line-428"><code>// This ensures that the object is not freed, and its finalizer is not run,</code></span>
<span class="codeline" id="line-429"><code>// before the point in the program where KeepAlive is called.</code></span>
<span class="codeline" id="line-430"><code>//</code></span>
<span class="codeline" id="line-431"><code>// A very simplified example showing where KeepAlive is required:</code></span>
<span class="codeline" id="line-432"><code>// 	type File struct { d int }</code></span>
<span class="codeline" id="line-433"><code>// 	d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)</code></span>
<span class="codeline" id="line-434"><code>// 	// ... do something if err != nil ...</code></span>
<span class="codeline" id="line-435"><code>// 	p := &amp;File{d}</code></span>
<span class="codeline" id="line-436"><code>// 	runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })</code></span>
<span class="codeline" id="line-437"><code>// 	var buf [10]byte</code></span>
<span class="codeline" id="line-438"><code>// 	n, err := syscall.Read(p.d, buf[:])</code></span>
<span class="codeline" id="line-439"><code>// 	// Ensure p is not finalized until Read returns.</code></span>
<span class="codeline" id="line-440"><code>// 	runtime.KeepAlive(p)</code></span>
<span class="codeline" id="line-441"><code>// 	// No more uses of p after this point.</code></span>
<span class="codeline" id="line-442"><code>//</code></span>
<span class="codeline" id="line-443"><code>// Without the KeepAlive call, the finalizer could run at the start of</code></span>
<span class="codeline" id="line-444"><code>// syscall.Read, closing the file descriptor before syscall.Read makes</code></span>
<span class="codeline" id="line-445"><code>// the actual system call.</code></span>
<span class="codeline" id="line-446"><code>func KeepAlive(x interface{}) {</code></span>
<span class="codeline" id="line-447"><code>	// Introduce a use of x that the compiler can't eliminate.</code></span>
<span class="codeline" id="line-448"><code>	// This makes sure x is alive on entry. We need x to be alive</code></span>
<span class="codeline" id="line-449"><code>	// on entry for "defer runtime.KeepAlive(x)"; see issue 21402.</code></span>
<span class="codeline" id="line-450"><code>	if cgoAlwaysFalse {</code></span>
<span class="codeline" id="line-451"><code>		println(x)</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>