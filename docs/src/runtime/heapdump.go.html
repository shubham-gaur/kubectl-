<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: heapdump.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	heapdump.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Implementation of runtime/debug.WriteHeapDump. Writes all</code></span>
<span class="codeline" id="line-6"><code>// objects in the heap plus additional info (roots, threads,</code></span>
<span class="codeline" id="line-7"><code>// finalizers, etc.) to a file.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>// The format of the dumped file is described at</code></span>
<span class="codeline" id="line-10"><code>// https://golang.org/s/go15heapdump.</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>package runtime</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>import (</code></span>
<span class="codeline" id="line-15"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-16"><code>	"unsafe"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>//go:linkname runtime_debug_WriteHeapDump runtime/debug.WriteHeapDump</code></span>
<span class="codeline" id="line-20"><code>func runtime_debug_WriteHeapDump(fd uintptr) {</code></span>
<span class="codeline" id="line-21"><code>	stopTheWorld("write heap dump")</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>	// Keep m on this G's stack instead of the system stack.</code></span>
<span class="codeline" id="line-24"><code>	// Both readmemstats_m and writeheapdump_m have pretty large</code></span>
<span class="codeline" id="line-25"><code>	// peak stack depths and we risk blowing the system stack.</code></span>
<span class="codeline" id="line-26"><code>	// This is safe because the world is stopped, so we don't</code></span>
<span class="codeline" id="line-27"><code>	// need to worry about anyone shrinking and therefore moving</code></span>
<span class="codeline" id="line-28"><code>	// our stack.</code></span>
<span class="codeline" id="line-29"><code>	var m MemStats</code></span>
<span class="codeline" id="line-30"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-31"><code>		// Call readmemstats_m here instead of deeper in</code></span>
<span class="codeline" id="line-32"><code>		// writeheapdump_m because we might blow the system stack</code></span>
<span class="codeline" id="line-33"><code>		// otherwise.</code></span>
<span class="codeline" id="line-34"><code>		readmemstats_m(&amp;m)</code></span>
<span class="codeline" id="line-35"><code>		writeheapdump_m(fd, &amp;m)</code></span>
<span class="codeline" id="line-36"><code>	})</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>	startTheWorld()</code></span>
<span class="codeline" id="line-39"><code>}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>const (</code></span>
<span class="codeline" id="line-42"><code>	fieldKindEol       = 0</code></span>
<span class="codeline" id="line-43"><code>	fieldKindPtr       = 1</code></span>
<span class="codeline" id="line-44"><code>	fieldKindIface     = 2</code></span>
<span class="codeline" id="line-45"><code>	fieldKindEface     = 3</code></span>
<span class="codeline" id="line-46"><code>	tagEOF             = 0</code></span>
<span class="codeline" id="line-47"><code>	tagObject          = 1</code></span>
<span class="codeline" id="line-48"><code>	tagOtherRoot       = 2</code></span>
<span class="codeline" id="line-49"><code>	tagType            = 3</code></span>
<span class="codeline" id="line-50"><code>	tagGoroutine       = 4</code></span>
<span class="codeline" id="line-51"><code>	tagStackFrame      = 5</code></span>
<span class="codeline" id="line-52"><code>	tagParams          = 6</code></span>
<span class="codeline" id="line-53"><code>	tagFinalizer       = 7</code></span>
<span class="codeline" id="line-54"><code>	tagItab            = 8</code></span>
<span class="codeline" id="line-55"><code>	tagOSThread        = 9</code></span>
<span class="codeline" id="line-56"><code>	tagMemStats        = 10</code></span>
<span class="codeline" id="line-57"><code>	tagQueuedFinalizer = 11</code></span>
<span class="codeline" id="line-58"><code>	tagData            = 12</code></span>
<span class="codeline" id="line-59"><code>	tagBSS             = 13</code></span>
<span class="codeline" id="line-60"><code>	tagDefer           = 14</code></span>
<span class="codeline" id="line-61"><code>	tagPanic           = 15</code></span>
<span class="codeline" id="line-62"><code>	tagMemProf         = 16</code></span>
<span class="codeline" id="line-63"><code>	tagAllocSample     = 17</code></span>
<span class="codeline" id="line-64"><code>)</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>var dumpfd uintptr // fd to write the dump to.</code></span>
<span class="codeline" id="line-67"><code>var tmpbuf []byte</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>// buffer of pending write data</code></span>
<span class="codeline" id="line-70"><code>const (</code></span>
<span class="codeline" id="line-71"><code>	bufSize = 4096</code></span>
<span class="codeline" id="line-72"><code>)</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>var buf [bufSize]byte</code></span>
<span class="codeline" id="line-75"><code>var nbuf uintptr</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>func dwrite(data unsafe.Pointer, len uintptr) {</code></span>
<span class="codeline" id="line-78"><code>	if len == 0 {</code></span>
<span class="codeline" id="line-79"><code>		return</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code>	if nbuf+len &lt;= bufSize {</code></span>
<span class="codeline" id="line-82"><code>		copy(buf[nbuf:], (*[bufSize]byte)(data)[:len])</code></span>
<span class="codeline" id="line-83"><code>		nbuf += len</code></span>
<span class="codeline" id="line-84"><code>		return</code></span>
<span class="codeline" id="line-85"><code>	}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>	write(dumpfd, unsafe.Pointer(&amp;buf), int32(nbuf))</code></span>
<span class="codeline" id="line-88"><code>	if len &gt;= bufSize {</code></span>
<span class="codeline" id="line-89"><code>		write(dumpfd, data, int32(len))</code></span>
<span class="codeline" id="line-90"><code>		nbuf = 0</code></span>
<span class="codeline" id="line-91"><code>	} else {</code></span>
<span class="codeline" id="line-92"><code>		copy(buf[:], (*[bufSize]byte)(data)[:len])</code></span>
<span class="codeline" id="line-93"><code>		nbuf = len</code></span>
<span class="codeline" id="line-94"><code>	}</code></span>
<span class="codeline" id="line-95"><code>}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>func dwritebyte(b byte) {</code></span>
<span class="codeline" id="line-98"><code>	dwrite(unsafe.Pointer(&amp;b), 1)</code></span>
<span class="codeline" id="line-99"><code>}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>func flush() {</code></span>
<span class="codeline" id="line-102"><code>	write(dumpfd, unsafe.Pointer(&amp;buf), int32(nbuf))</code></span>
<span class="codeline" id="line-103"><code>	nbuf = 0</code></span>
<span class="codeline" id="line-104"><code>}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>// Cache of types that have been serialized already.</code></span>
<span class="codeline" id="line-107"><code>// We use a type's hash field to pick a bucket.</code></span>
<span class="codeline" id="line-108"><code>// Inside a bucket, we keep a list of types that</code></span>
<span class="codeline" id="line-109"><code>// have been serialized so far, most recently used first.</code></span>
<span class="codeline" id="line-110"><code>// Note: when a bucket overflows we may end up</code></span>
<span class="codeline" id="line-111"><code>// serializing a type more than once. That's ok.</code></span>
<span class="codeline" id="line-112"><code>const (</code></span>
<span class="codeline" id="line-113"><code>	typeCacheBuckets = 256</code></span>
<span class="codeline" id="line-114"><code>	typeCacheAssoc   = 4</code></span>
<span class="codeline" id="line-115"><code>)</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>type typeCacheBucket struct {</code></span>
<span class="codeline" id="line-118"><code>	t [typeCacheAssoc]*_type</code></span>
<span class="codeline" id="line-119"><code>}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>var typecache [typeCacheBuckets]typeCacheBucket</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// dump a uint64 in a varint format parseable by encoding/binary</code></span>
<span class="codeline" id="line-124"><code>func dumpint(v uint64) {</code></span>
<span class="codeline" id="line-125"><code>	var buf [10]byte</code></span>
<span class="codeline" id="line-126"><code>	var n int</code></span>
<span class="codeline" id="line-127"><code>	for v &gt;= 0x80 {</code></span>
<span class="codeline" id="line-128"><code>		buf[n] = byte(v | 0x80)</code></span>
<span class="codeline" id="line-129"><code>		n++</code></span>
<span class="codeline" id="line-130"><code>		v &gt;&gt;= 7</code></span>
<span class="codeline" id="line-131"><code>	}</code></span>
<span class="codeline" id="line-132"><code>	buf[n] = byte(v)</code></span>
<span class="codeline" id="line-133"><code>	n++</code></span>
<span class="codeline" id="line-134"><code>	dwrite(unsafe.Pointer(&amp;buf), uintptr(n))</code></span>
<span class="codeline" id="line-135"><code>}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>func dumpbool(b bool) {</code></span>
<span class="codeline" id="line-138"><code>	if b {</code></span>
<span class="codeline" id="line-139"><code>		dumpint(1)</code></span>
<span class="codeline" id="line-140"><code>	} else {</code></span>
<span class="codeline" id="line-141"><code>		dumpint(0)</code></span>
<span class="codeline" id="line-142"><code>	}</code></span>
<span class="codeline" id="line-143"><code>}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// dump varint uint64 length followed by memory contents</code></span>
<span class="codeline" id="line-146"><code>func dumpmemrange(data unsafe.Pointer, len uintptr) {</code></span>
<span class="codeline" id="line-147"><code>	dumpint(uint64(len))</code></span>
<span class="codeline" id="line-148"><code>	dwrite(data, len)</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>func dumpslice(b []byte) {</code></span>
<span class="codeline" id="line-152"><code>	dumpint(uint64(len(b)))</code></span>
<span class="codeline" id="line-153"><code>	if len(b) &gt; 0 {</code></span>
<span class="codeline" id="line-154"><code>		dwrite(unsafe.Pointer(&amp;b[0]), uintptr(len(b)))</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>}</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>func dumpstr(s string) {</code></span>
<span class="codeline" id="line-159"><code>	sp := stringStructOf(&amp;s)</code></span>
<span class="codeline" id="line-160"><code>	dumpmemrange(sp.str, uintptr(sp.len))</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// dump information for a type</code></span>
<span class="codeline" id="line-164"><code>func dumptype(t *_type) {</code></span>
<span class="codeline" id="line-165"><code>	if t == nil {</code></span>
<span class="codeline" id="line-166"><code>		return</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	// If we've definitely serialized the type before,</code></span>
<span class="codeline" id="line-170"><code>	// no need to do it again.</code></span>
<span class="codeline" id="line-171"><code>	b := &amp;typecache[t.hash&amp;(typeCacheBuckets-1)]</code></span>
<span class="codeline" id="line-172"><code>	if t == b.t[0] {</code></span>
<span class="codeline" id="line-173"><code>		return</code></span>
<span class="codeline" id="line-174"><code>	}</code></span>
<span class="codeline" id="line-175"><code>	for i := 1; i &lt; typeCacheAssoc; i++ {</code></span>
<span class="codeline" id="line-176"><code>		if t == b.t[i] {</code></span>
<span class="codeline" id="line-177"><code>			// Move-to-front</code></span>
<span class="codeline" id="line-178"><code>			for j := i; j &gt; 0; j-- {</code></span>
<span class="codeline" id="line-179"><code>				b.t[j] = b.t[j-1]</code></span>
<span class="codeline" id="line-180"><code>			}</code></span>
<span class="codeline" id="line-181"><code>			b.t[0] = t</code></span>
<span class="codeline" id="line-182"><code>			return</code></span>
<span class="codeline" id="line-183"><code>		}</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// Might not have been dumped yet. Dump it and</code></span>
<span class="codeline" id="line-187"><code>	// remember we did so.</code></span>
<span class="codeline" id="line-188"><code>	for j := typeCacheAssoc - 1; j &gt; 0; j-- {</code></span>
<span class="codeline" id="line-189"><code>		b.t[j] = b.t[j-1]</code></span>
<span class="codeline" id="line-190"><code>	}</code></span>
<span class="codeline" id="line-191"><code>	b.t[0] = t</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>	// dump the type</code></span>
<span class="codeline" id="line-194"><code>	dumpint(tagType)</code></span>
<span class="codeline" id="line-195"><code>	dumpint(uint64(uintptr(unsafe.Pointer(t))))</code></span>
<span class="codeline" id="line-196"><code>	dumpint(uint64(t.size))</code></span>
<span class="codeline" id="line-197"><code>	if x := t.uncommon(); x == nil || t.nameOff(x.pkgpath).name() == "" {</code></span>
<span class="codeline" id="line-198"><code>		dumpstr(t.string())</code></span>
<span class="codeline" id="line-199"><code>	} else {</code></span>
<span class="codeline" id="line-200"><code>		pkgpathstr := t.nameOff(x.pkgpath).name()</code></span>
<span class="codeline" id="line-201"><code>		pkgpath := stringStructOf(&amp;pkgpathstr)</code></span>
<span class="codeline" id="line-202"><code>		namestr := t.name()</code></span>
<span class="codeline" id="line-203"><code>		name := stringStructOf(&amp;namestr)</code></span>
<span class="codeline" id="line-204"><code>		dumpint(uint64(uintptr(pkgpath.len) + 1 + uintptr(name.len)))</code></span>
<span class="codeline" id="line-205"><code>		dwrite(pkgpath.str, uintptr(pkgpath.len))</code></span>
<span class="codeline" id="line-206"><code>		dwritebyte('.')</code></span>
<span class="codeline" id="line-207"><code>		dwrite(name.str, uintptr(name.len))</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>	dumpbool(t.kind&amp;kindDirectIface == 0 || t.ptrdata != 0)</code></span>
<span class="codeline" id="line-210"><code>}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>// dump an object</code></span>
<span class="codeline" id="line-213"><code>func dumpobj(obj unsafe.Pointer, size uintptr, bv bitvector) {</code></span>
<span class="codeline" id="line-214"><code>	dumpint(tagObject)</code></span>
<span class="codeline" id="line-215"><code>	dumpint(uint64(uintptr(obj)))</code></span>
<span class="codeline" id="line-216"><code>	dumpmemrange(obj, size)</code></span>
<span class="codeline" id="line-217"><code>	dumpfields(bv)</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>func dumpotherroot(description string, to unsafe.Pointer) {</code></span>
<span class="codeline" id="line-221"><code>	dumpint(tagOtherRoot)</code></span>
<span class="codeline" id="line-222"><code>	dumpstr(description)</code></span>
<span class="codeline" id="line-223"><code>	dumpint(uint64(uintptr(to)))</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>func dumpfinalizer(obj unsafe.Pointer, fn *funcval, fint *_type, ot *ptrtype) {</code></span>
<span class="codeline" id="line-227"><code>	dumpint(tagFinalizer)</code></span>
<span class="codeline" id="line-228"><code>	dumpint(uint64(uintptr(obj)))</code></span>
<span class="codeline" id="line-229"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fn))))</code></span>
<span class="codeline" id="line-230"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fn.fn))))</code></span>
<span class="codeline" id="line-231"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fint))))</code></span>
<span class="codeline" id="line-232"><code>	dumpint(uint64(uintptr(unsafe.Pointer(ot))))</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>type childInfo struct {</code></span>
<span class="codeline" id="line-236"><code>	// Information passed up from the callee frame about</code></span>
<span class="codeline" id="line-237"><code>	// the layout of the outargs region.</code></span>
<span class="codeline" id="line-238"><code>	argoff uintptr   // where the arguments start in the frame</code></span>
<span class="codeline" id="line-239"><code>	arglen uintptr   // size of args region</code></span>
<span class="codeline" id="line-240"><code>	args   bitvector // if args.n &gt;= 0, pointer map of args region</code></span>
<span class="codeline" id="line-241"><code>	sp     *uint8    // callee sp</code></span>
<span class="codeline" id="line-242"><code>	depth  uintptr   // depth in call stack (0 == most recent)</code></span>
<span class="codeline" id="line-243"><code>}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>// dump kinds &amp; offsets of interesting fields in bv</code></span>
<span class="codeline" id="line-246"><code>func dumpbv(cbv *bitvector, offset uintptr) {</code></span>
<span class="codeline" id="line-247"><code>	for i := uintptr(0); i &lt; uintptr(cbv.n); i++ {</code></span>
<span class="codeline" id="line-248"><code>		if cbv.ptrbit(i) == 1 {</code></span>
<span class="codeline" id="line-249"><code>			dumpint(fieldKindPtr)</code></span>
<span class="codeline" id="line-250"><code>			dumpint(uint64(offset + i*sys.PtrSize))</code></span>
<span class="codeline" id="line-251"><code>		}</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code>}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>func dumpframe(s *stkframe, arg unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-256"><code>	child := (*childInfo)(arg)</code></span>
<span class="codeline" id="line-257"><code>	f := s.fn</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>	// Figure out what we can about our stack map</code></span>
<span class="codeline" id="line-260"><code>	pc := s.pc</code></span>
<span class="codeline" id="line-261"><code>	pcdata := int32(-1) // Use the entry map at function entry</code></span>
<span class="codeline" id="line-262"><code>	if pc != f.entry {</code></span>
<span class="codeline" id="line-263"><code>		pc--</code></span>
<span class="codeline" id="line-264"><code>		pcdata = pcdatavalue(f, _PCDATA_StackMapIndex, pc, nil)</code></span>
<span class="codeline" id="line-265"><code>	}</code></span>
<span class="codeline" id="line-266"><code>	if pcdata == -1 {</code></span>
<span class="codeline" id="line-267"><code>		// We do not have a valid pcdata value but there might be a</code></span>
<span class="codeline" id="line-268"><code>		// stackmap for this function. It is likely that we are looking</code></span>
<span class="codeline" id="line-269"><code>		// at the function prologue, assume so and hope for the best.</code></span>
<span class="codeline" id="line-270"><code>		pcdata = 0</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	stkmap := (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>	var bv bitvector</code></span>
<span class="codeline" id="line-275"><code>	if stkmap != nil &amp;&amp; stkmap.n &gt; 0 {</code></span>
<span class="codeline" id="line-276"><code>		bv = stackmapdata(stkmap, pcdata)</code></span>
<span class="codeline" id="line-277"><code>	} else {</code></span>
<span class="codeline" id="line-278"><code>		bv.n = -1</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// Dump main body of stack frame.</code></span>
<span class="codeline" id="line-282"><code>	dumpint(tagStackFrame)</code></span>
<span class="codeline" id="line-283"><code>	dumpint(uint64(s.sp))                              // lowest address in frame</code></span>
<span class="codeline" id="line-284"><code>	dumpint(uint64(child.depth))                       // # of frames deep on the stack</code></span>
<span class="codeline" id="line-285"><code>	dumpint(uint64(uintptr(unsafe.Pointer(child.sp)))) // sp of child, or 0 if bottom of stack</code></span>
<span class="codeline" id="line-286"><code>	dumpmemrange(unsafe.Pointer(s.sp), s.fp-s.sp)      // frame contents</code></span>
<span class="codeline" id="line-287"><code>	dumpint(uint64(f.entry))</code></span>
<span class="codeline" id="line-288"><code>	dumpint(uint64(s.pc))</code></span>
<span class="codeline" id="line-289"><code>	dumpint(uint64(s.continpc))</code></span>
<span class="codeline" id="line-290"><code>	name := funcname(f)</code></span>
<span class="codeline" id="line-291"><code>	if name == "" {</code></span>
<span class="codeline" id="line-292"><code>		name = "unknown function"</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	dumpstr(name)</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>	// Dump fields in the outargs section</code></span>
<span class="codeline" id="line-297"><code>	if child.args.n &gt;= 0 {</code></span>
<span class="codeline" id="line-298"><code>		dumpbv(&amp;child.args, child.argoff)</code></span>
<span class="codeline" id="line-299"><code>	} else {</code></span>
<span class="codeline" id="line-300"><code>		// conservative - everything might be a pointer</code></span>
<span class="codeline" id="line-301"><code>		for off := child.argoff; off &lt; child.argoff+child.arglen; off += sys.PtrSize {</code></span>
<span class="codeline" id="line-302"><code>			dumpint(fieldKindPtr)</code></span>
<span class="codeline" id="line-303"><code>			dumpint(uint64(off))</code></span>
<span class="codeline" id="line-304"><code>		}</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>	// Dump fields in the local vars section</code></span>
<span class="codeline" id="line-308"><code>	if stkmap == nil {</code></span>
<span class="codeline" id="line-309"><code>		// No locals information, dump everything.</code></span>
<span class="codeline" id="line-310"><code>		for off := child.arglen; off &lt; s.varp-s.sp; off += sys.PtrSize {</code></span>
<span class="codeline" id="line-311"><code>			dumpint(fieldKindPtr)</code></span>
<span class="codeline" id="line-312"><code>			dumpint(uint64(off))</code></span>
<span class="codeline" id="line-313"><code>		}</code></span>
<span class="codeline" id="line-314"><code>	} else if stkmap.n &lt; 0 {</code></span>
<span class="codeline" id="line-315"><code>		// Locals size information, dump just the locals.</code></span>
<span class="codeline" id="line-316"><code>		size := uintptr(-stkmap.n)</code></span>
<span class="codeline" id="line-317"><code>		for off := s.varp - size - s.sp; off &lt; s.varp-s.sp; off += sys.PtrSize {</code></span>
<span class="codeline" id="line-318"><code>			dumpint(fieldKindPtr)</code></span>
<span class="codeline" id="line-319"><code>			dumpint(uint64(off))</code></span>
<span class="codeline" id="line-320"><code>		}</code></span>
<span class="codeline" id="line-321"><code>	} else if stkmap.n &gt; 0 {</code></span>
<span class="codeline" id="line-322"><code>		// Locals bitmap information, scan just the pointers in</code></span>
<span class="codeline" id="line-323"><code>		// locals.</code></span>
<span class="codeline" id="line-324"><code>		dumpbv(&amp;bv, s.varp-uintptr(bv.n)*sys.PtrSize-s.sp)</code></span>
<span class="codeline" id="line-325"><code>	}</code></span>
<span class="codeline" id="line-326"><code>	dumpint(fieldKindEol)</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>	// Record arg info for parent.</code></span>
<span class="codeline" id="line-329"><code>	child.argoff = s.argp - s.fp</code></span>
<span class="codeline" id="line-330"><code>	child.arglen = s.arglen</code></span>
<span class="codeline" id="line-331"><code>	child.sp = (*uint8)(unsafe.Pointer(s.sp))</code></span>
<span class="codeline" id="line-332"><code>	child.depth++</code></span>
<span class="codeline" id="line-333"><code>	stkmap = (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</code></span>
<span class="codeline" id="line-334"><code>	if stkmap != nil {</code></span>
<span class="codeline" id="line-335"><code>		child.args = stackmapdata(stkmap, pcdata)</code></span>
<span class="codeline" id="line-336"><code>	} else {</code></span>
<span class="codeline" id="line-337"><code>		child.args.n = -1</code></span>
<span class="codeline" id="line-338"><code>	}</code></span>
<span class="codeline" id="line-339"><code>	return true</code></span>
<span class="codeline" id="line-340"><code>}</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>func dumpgoroutine(gp *g) {</code></span>
<span class="codeline" id="line-343"><code>	var sp, pc, lr uintptr</code></span>
<span class="codeline" id="line-344"><code>	if gp.syscallsp != 0 {</code></span>
<span class="codeline" id="line-345"><code>		sp = gp.syscallsp</code></span>
<span class="codeline" id="line-346"><code>		pc = gp.syscallpc</code></span>
<span class="codeline" id="line-347"><code>		lr = 0</code></span>
<span class="codeline" id="line-348"><code>	} else {</code></span>
<span class="codeline" id="line-349"><code>		sp = gp.sched.sp</code></span>
<span class="codeline" id="line-350"><code>		pc = gp.sched.pc</code></span>
<span class="codeline" id="line-351"><code>		lr = gp.sched.lr</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>	dumpint(tagGoroutine)</code></span>
<span class="codeline" id="line-355"><code>	dumpint(uint64(uintptr(unsafe.Pointer(gp))))</code></span>
<span class="codeline" id="line-356"><code>	dumpint(uint64(sp))</code></span>
<span class="codeline" id="line-357"><code>	dumpint(uint64(gp.goid))</code></span>
<span class="codeline" id="line-358"><code>	dumpint(uint64(gp.gopc))</code></span>
<span class="codeline" id="line-359"><code>	dumpint(uint64(readgstatus(gp)))</code></span>
<span class="codeline" id="line-360"><code>	dumpbool(isSystemGoroutine(gp, false))</code></span>
<span class="codeline" id="line-361"><code>	dumpbool(false) // isbackground</code></span>
<span class="codeline" id="line-362"><code>	dumpint(uint64(gp.waitsince))</code></span>
<span class="codeline" id="line-363"><code>	dumpstr(gp.waitreason.String())</code></span>
<span class="codeline" id="line-364"><code>	dumpint(uint64(uintptr(gp.sched.ctxt)))</code></span>
<span class="codeline" id="line-365"><code>	dumpint(uint64(uintptr(unsafe.Pointer(gp.m))))</code></span>
<span class="codeline" id="line-366"><code>	dumpint(uint64(uintptr(unsafe.Pointer(gp._defer))))</code></span>
<span class="codeline" id="line-367"><code>	dumpint(uint64(uintptr(unsafe.Pointer(gp._panic))))</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>	// dump stack</code></span>
<span class="codeline" id="line-370"><code>	var child childInfo</code></span>
<span class="codeline" id="line-371"><code>	child.args.n = -1</code></span>
<span class="codeline" id="line-372"><code>	child.arglen = 0</code></span>
<span class="codeline" id="line-373"><code>	child.sp = nil</code></span>
<span class="codeline" id="line-374"><code>	child.depth = 0</code></span>
<span class="codeline" id="line-375"><code>	gentraceback(pc, sp, lr, gp, 0, nil, 0x7fffffff, dumpframe, noescape(unsafe.Pointer(&amp;child)), 0)</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>	// dump defer &amp; panic records</code></span>
<span class="codeline" id="line-378"><code>	for d := gp._defer; d != nil; d = d.link {</code></span>
<span class="codeline" id="line-379"><code>		dumpint(tagDefer)</code></span>
<span class="codeline" id="line-380"><code>		dumpint(uint64(uintptr(unsafe.Pointer(d))))</code></span>
<span class="codeline" id="line-381"><code>		dumpint(uint64(uintptr(unsafe.Pointer(gp))))</code></span>
<span class="codeline" id="line-382"><code>		dumpint(uint64(d.sp))</code></span>
<span class="codeline" id="line-383"><code>		dumpint(uint64(d.pc))</code></span>
<span class="codeline" id="line-384"><code>		dumpint(uint64(uintptr(unsafe.Pointer(d.fn))))</code></span>
<span class="codeline" id="line-385"><code>		if d.fn == nil {</code></span>
<span class="codeline" id="line-386"><code>			// d.fn can be nil for open-coded defers</code></span>
<span class="codeline" id="line-387"><code>			dumpint(uint64(0))</code></span>
<span class="codeline" id="line-388"><code>		} else {</code></span>
<span class="codeline" id="line-389"><code>			dumpint(uint64(uintptr(unsafe.Pointer(d.fn.fn))))</code></span>
<span class="codeline" id="line-390"><code>		}</code></span>
<span class="codeline" id="line-391"><code>		dumpint(uint64(uintptr(unsafe.Pointer(d.link))))</code></span>
<span class="codeline" id="line-392"><code>	}</code></span>
<span class="codeline" id="line-393"><code>	for p := gp._panic; p != nil; p = p.link {</code></span>
<span class="codeline" id="line-394"><code>		dumpint(tagPanic)</code></span>
<span class="codeline" id="line-395"><code>		dumpint(uint64(uintptr(unsafe.Pointer(p))))</code></span>
<span class="codeline" id="line-396"><code>		dumpint(uint64(uintptr(unsafe.Pointer(gp))))</code></span>
<span class="codeline" id="line-397"><code>		eface := efaceOf(&amp;p.arg)</code></span>
<span class="codeline" id="line-398"><code>		dumpint(uint64(uintptr(unsafe.Pointer(eface._type))))</code></span>
<span class="codeline" id="line-399"><code>		dumpint(uint64(uintptr(unsafe.Pointer(eface.data))))</code></span>
<span class="codeline" id="line-400"><code>		dumpint(0) // was p-&gt;defer, no longer recorded</code></span>
<span class="codeline" id="line-401"><code>		dumpint(uint64(uintptr(unsafe.Pointer(p.link))))</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>func dumpgs() {</code></span>
<span class="codeline" id="line-406"><code>	// goroutines &amp; stacks</code></span>
<span class="codeline" id="line-407"><code>	for i := 0; uintptr(i) &lt; allglen; i++ {</code></span>
<span class="codeline" id="line-408"><code>		gp := allgs[i]</code></span>
<span class="codeline" id="line-409"><code>		status := readgstatus(gp) // The world is stopped so gp will not be in a scan state.</code></span>
<span class="codeline" id="line-410"><code>		switch status {</code></span>
<span class="codeline" id="line-411"><code>		default:</code></span>
<span class="codeline" id="line-412"><code>			print("runtime: unexpected G.status ", hex(status), "\n")</code></span>
<span class="codeline" id="line-413"><code>			throw("dumpgs in STW - bad status")</code></span>
<span class="codeline" id="line-414"><code>		case _Gdead:</code></span>
<span class="codeline" id="line-415"><code>			// ok</code></span>
<span class="codeline" id="line-416"><code>		case _Grunnable,</code></span>
<span class="codeline" id="line-417"><code>			_Gsyscall,</code></span>
<span class="codeline" id="line-418"><code>			_Gwaiting:</code></span>
<span class="codeline" id="line-419"><code>			dumpgoroutine(gp)</code></span>
<span class="codeline" id="line-420"><code>		}</code></span>
<span class="codeline" id="line-421"><code>	}</code></span>
<span class="codeline" id="line-422"><code>}</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>func finq_callback(fn *funcval, obj unsafe.Pointer, nret uintptr, fint *_type, ot *ptrtype) {</code></span>
<span class="codeline" id="line-425"><code>	dumpint(tagQueuedFinalizer)</code></span>
<span class="codeline" id="line-426"><code>	dumpint(uint64(uintptr(obj)))</code></span>
<span class="codeline" id="line-427"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fn))))</code></span>
<span class="codeline" id="line-428"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fn.fn))))</code></span>
<span class="codeline" id="line-429"><code>	dumpint(uint64(uintptr(unsafe.Pointer(fint))))</code></span>
<span class="codeline" id="line-430"><code>	dumpint(uint64(uintptr(unsafe.Pointer(ot))))</code></span>
<span class="codeline" id="line-431"><code>}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>func dumproots() {</code></span>
<span class="codeline" id="line-434"><code>	// To protect mheap_.allspans.</code></span>
<span class="codeline" id="line-435"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	// TODO(mwhudson): dump datamask etc from all objects</code></span>
<span class="codeline" id="line-438"><code>	// data segment</code></span>
<span class="codeline" id="line-439"><code>	dumpint(tagData)</code></span>
<span class="codeline" id="line-440"><code>	dumpint(uint64(firstmoduledata.data))</code></span>
<span class="codeline" id="line-441"><code>	dumpmemrange(unsafe.Pointer(firstmoduledata.data), firstmoduledata.edata-firstmoduledata.data)</code></span>
<span class="codeline" id="line-442"><code>	dumpfields(firstmoduledata.gcdatamask)</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>	// bss segment</code></span>
<span class="codeline" id="line-445"><code>	dumpint(tagBSS)</code></span>
<span class="codeline" id="line-446"><code>	dumpint(uint64(firstmoduledata.bss))</code></span>
<span class="codeline" id="line-447"><code>	dumpmemrange(unsafe.Pointer(firstmoduledata.bss), firstmoduledata.ebss-firstmoduledata.bss)</code></span>
<span class="codeline" id="line-448"><code>	dumpfields(firstmoduledata.gcbssmask)</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>	// mspan.types</code></span>
<span class="codeline" id="line-451"><code>	for _, s := range mheap_.allspans {</code></span>
<span class="codeline" id="line-452"><code>		if s.state.get() == mSpanInUse {</code></span>
<span class="codeline" id="line-453"><code>			// Finalizers</code></span>
<span class="codeline" id="line-454"><code>			for sp := s.specials; sp != nil; sp = sp.next {</code></span>
<span class="codeline" id="line-455"><code>				if sp.kind != _KindSpecialFinalizer {</code></span>
<span class="codeline" id="line-456"><code>					continue</code></span>
<span class="codeline" id="line-457"><code>				}</code></span>
<span class="codeline" id="line-458"><code>				spf := (*specialfinalizer)(unsafe.Pointer(sp))</code></span>
<span class="codeline" id="line-459"><code>				p := unsafe.Pointer(s.base() + uintptr(spf.special.offset))</code></span>
<span class="codeline" id="line-460"><code>				dumpfinalizer(p, spf.fn, spf.fint, spf.ot)</code></span>
<span class="codeline" id="line-461"><code>			}</code></span>
<span class="codeline" id="line-462"><code>		}</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	// Finalizer queue</code></span>
<span class="codeline" id="line-466"><code>	iterate_finq(finq_callback)</code></span>
<span class="codeline" id="line-467"><code>}</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>// Bit vector of free marks.</code></span>
<span class="codeline" id="line-470"><code>// Needs to be as big as the largest number of objects per span.</code></span>
<span class="codeline" id="line-471"><code>var freemark [_PageSize / 8]bool</code></span>
<span class="codeline" id="line-472"><code></code></span>
<span class="codeline" id="line-473"><code>func dumpobjs() {</code></span>
<span class="codeline" id="line-474"><code>	// To protect mheap_.allspans.</code></span>
<span class="codeline" id="line-475"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>	for _, s := range mheap_.allspans {</code></span>
<span class="codeline" id="line-478"><code>		if s.state.get() != mSpanInUse {</code></span>
<span class="codeline" id="line-479"><code>			continue</code></span>
<span class="codeline" id="line-480"><code>		}</code></span>
<span class="codeline" id="line-481"><code>		p := s.base()</code></span>
<span class="codeline" id="line-482"><code>		size := s.elemsize</code></span>
<span class="codeline" id="line-483"><code>		n := (s.npages &lt;&lt; _PageShift) / size</code></span>
<span class="codeline" id="line-484"><code>		if n &gt; uintptr(len(freemark)) {</code></span>
<span class="codeline" id="line-485"><code>			throw("freemark array doesn't have enough entries")</code></span>
<span class="codeline" id="line-486"><code>		}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>		for freeIndex := uintptr(0); freeIndex &lt; s.nelems; freeIndex++ {</code></span>
<span class="codeline" id="line-489"><code>			if s.isFree(freeIndex) {</code></span>
<span class="codeline" id="line-490"><code>				freemark[freeIndex] = true</code></span>
<span class="codeline" id="line-491"><code>			}</code></span>
<span class="codeline" id="line-492"><code>		}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>		for j := uintptr(0); j &lt; n; j, p = j+1, p+size {</code></span>
<span class="codeline" id="line-495"><code>			if freemark[j] {</code></span>
<span class="codeline" id="line-496"><code>				freemark[j] = false</code></span>
<span class="codeline" id="line-497"><code>				continue</code></span>
<span class="codeline" id="line-498"><code>			}</code></span>
<span class="codeline" id="line-499"><code>			dumpobj(unsafe.Pointer(p), size, makeheapobjbv(p, size))</code></span>
<span class="codeline" id="line-500"><code>		}</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code>}</code></span>
<span class="codeline" id="line-503"><code></code></span>
<span class="codeline" id="line-504"><code>func dumpparams() {</code></span>
<span class="codeline" id="line-505"><code>	dumpint(tagParams)</code></span>
<span class="codeline" id="line-506"><code>	x := uintptr(1)</code></span>
<span class="codeline" id="line-507"><code>	if *(*byte)(unsafe.Pointer(&amp;x)) == 1 {</code></span>
<span class="codeline" id="line-508"><code>		dumpbool(false) // little-endian ptrs</code></span>
<span class="codeline" id="line-509"><code>	} else {</code></span>
<span class="codeline" id="line-510"><code>		dumpbool(true) // big-endian ptrs</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code>	dumpint(sys.PtrSize)</code></span>
<span class="codeline" id="line-513"><code>	var arenaStart, arenaEnd uintptr</code></span>
<span class="codeline" id="line-514"><code>	for i1 := range mheap_.arenas {</code></span>
<span class="codeline" id="line-515"><code>		if mheap_.arenas[i1] == nil {</code></span>
<span class="codeline" id="line-516"><code>			continue</code></span>
<span class="codeline" id="line-517"><code>		}</code></span>
<span class="codeline" id="line-518"><code>		for i, ha := range mheap_.arenas[i1] {</code></span>
<span class="codeline" id="line-519"><code>			if ha == nil {</code></span>
<span class="codeline" id="line-520"><code>				continue</code></span>
<span class="codeline" id="line-521"><code>			}</code></span>
<span class="codeline" id="line-522"><code>			base := arenaBase(arenaIdx(i1)&lt;&lt;arenaL1Shift | arenaIdx(i))</code></span>
<span class="codeline" id="line-523"><code>			if arenaStart == 0 || base &lt; arenaStart {</code></span>
<span class="codeline" id="line-524"><code>				arenaStart = base</code></span>
<span class="codeline" id="line-525"><code>			}</code></span>
<span class="codeline" id="line-526"><code>			if base+heapArenaBytes &gt; arenaEnd {</code></span>
<span class="codeline" id="line-527"><code>				arenaEnd = base + heapArenaBytes</code></span>
<span class="codeline" id="line-528"><code>			}</code></span>
<span class="codeline" id="line-529"><code>		}</code></span>
<span class="codeline" id="line-530"><code>	}</code></span>
<span class="codeline" id="line-531"><code>	dumpint(uint64(arenaStart))</code></span>
<span class="codeline" id="line-532"><code>	dumpint(uint64(arenaEnd))</code></span>
<span class="codeline" id="line-533"><code>	dumpstr(sys.GOARCH)</code></span>
<span class="codeline" id="line-534"><code>	dumpstr(sys.Goexperiment)</code></span>
<span class="codeline" id="line-535"><code>	dumpint(uint64(ncpu))</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>func itab_callback(tab *itab) {</code></span>
<span class="codeline" id="line-539"><code>	t := tab._type</code></span>
<span class="codeline" id="line-540"><code>	dumptype(t)</code></span>
<span class="codeline" id="line-541"><code>	dumpint(tagItab)</code></span>
<span class="codeline" id="line-542"><code>	dumpint(uint64(uintptr(unsafe.Pointer(tab))))</code></span>
<span class="codeline" id="line-543"><code>	dumpint(uint64(uintptr(unsafe.Pointer(t))))</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>func dumpitabs() {</code></span>
<span class="codeline" id="line-547"><code>	iterate_itabs(itab_callback)</code></span>
<span class="codeline" id="line-548"><code>}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>func dumpms() {</code></span>
<span class="codeline" id="line-551"><code>	for mp := allm; mp != nil; mp = mp.alllink {</code></span>
<span class="codeline" id="line-552"><code>		dumpint(tagOSThread)</code></span>
<span class="codeline" id="line-553"><code>		dumpint(uint64(uintptr(unsafe.Pointer(mp))))</code></span>
<span class="codeline" id="line-554"><code>		dumpint(uint64(mp.id))</code></span>
<span class="codeline" id="line-555"><code>		dumpint(mp.procid)</code></span>
<span class="codeline" id="line-556"><code>	}</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>//go:systemstack</code></span>
<span class="codeline" id="line-560"><code>func dumpmemstats(m *MemStats) {</code></span>
<span class="codeline" id="line-561"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>	// These ints should be identical to the exported</code></span>
<span class="codeline" id="line-564"><code>	// MemStats structure and should be ordered the same</code></span>
<span class="codeline" id="line-565"><code>	// way too.</code></span>
<span class="codeline" id="line-566"><code>	dumpint(tagMemStats)</code></span>
<span class="codeline" id="line-567"><code>	dumpint(m.Alloc)</code></span>
<span class="codeline" id="line-568"><code>	dumpint(m.TotalAlloc)</code></span>
<span class="codeline" id="line-569"><code>	dumpint(m.Sys)</code></span>
<span class="codeline" id="line-570"><code>	dumpint(m.Lookups)</code></span>
<span class="codeline" id="line-571"><code>	dumpint(m.Mallocs)</code></span>
<span class="codeline" id="line-572"><code>	dumpint(m.Frees)</code></span>
<span class="codeline" id="line-573"><code>	dumpint(m.HeapAlloc)</code></span>
<span class="codeline" id="line-574"><code>	dumpint(m.HeapSys)</code></span>
<span class="codeline" id="line-575"><code>	dumpint(m.HeapIdle)</code></span>
<span class="codeline" id="line-576"><code>	dumpint(m.HeapInuse)</code></span>
<span class="codeline" id="line-577"><code>	dumpint(m.HeapReleased)</code></span>
<span class="codeline" id="line-578"><code>	dumpint(m.HeapObjects)</code></span>
<span class="codeline" id="line-579"><code>	dumpint(m.StackInuse)</code></span>
<span class="codeline" id="line-580"><code>	dumpint(m.StackSys)</code></span>
<span class="codeline" id="line-581"><code>	dumpint(m.MSpanInuse)</code></span>
<span class="codeline" id="line-582"><code>	dumpint(m.MSpanSys)</code></span>
<span class="codeline" id="line-583"><code>	dumpint(m.MCacheInuse)</code></span>
<span class="codeline" id="line-584"><code>	dumpint(m.MCacheSys)</code></span>
<span class="codeline" id="line-585"><code>	dumpint(m.BuckHashSys)</code></span>
<span class="codeline" id="line-586"><code>	dumpint(m.GCSys)</code></span>
<span class="codeline" id="line-587"><code>	dumpint(m.OtherSys)</code></span>
<span class="codeline" id="line-588"><code>	dumpint(m.NextGC)</code></span>
<span class="codeline" id="line-589"><code>	dumpint(m.LastGC)</code></span>
<span class="codeline" id="line-590"><code>	dumpint(m.PauseTotalNs)</code></span>
<span class="codeline" id="line-591"><code>	for i := 0; i &lt; 256; i++ {</code></span>
<span class="codeline" id="line-592"><code>		dumpint(m.PauseNs[i])</code></span>
<span class="codeline" id="line-593"><code>	}</code></span>
<span class="codeline" id="line-594"><code>	dumpint(uint64(m.NumGC))</code></span>
<span class="codeline" id="line-595"><code>}</code></span>
<span class="codeline" id="line-596"><code></code></span>
<span class="codeline" id="line-597"><code>func dumpmemprof_callback(b *bucket, nstk uintptr, pstk *uintptr, size, allocs, frees uintptr) {</code></span>
<span class="codeline" id="line-598"><code>	stk := (*[100000]uintptr)(unsafe.Pointer(pstk))</code></span>
<span class="codeline" id="line-599"><code>	dumpint(tagMemProf)</code></span>
<span class="codeline" id="line-600"><code>	dumpint(uint64(uintptr(unsafe.Pointer(b))))</code></span>
<span class="codeline" id="line-601"><code>	dumpint(uint64(size))</code></span>
<span class="codeline" id="line-602"><code>	dumpint(uint64(nstk))</code></span>
<span class="codeline" id="line-603"><code>	for i := uintptr(0); i &lt; nstk; i++ {</code></span>
<span class="codeline" id="line-604"><code>		pc := stk[i]</code></span>
<span class="codeline" id="line-605"><code>		f := findfunc(pc)</code></span>
<span class="codeline" id="line-606"><code>		if !f.valid() {</code></span>
<span class="codeline" id="line-607"><code>			var buf [64]byte</code></span>
<span class="codeline" id="line-608"><code>			n := len(buf)</code></span>
<span class="codeline" id="line-609"><code>			n--</code></span>
<span class="codeline" id="line-610"><code>			buf[n] = ')'</code></span>
<span class="codeline" id="line-611"><code>			if pc == 0 {</code></span>
<span class="codeline" id="line-612"><code>				n--</code></span>
<span class="codeline" id="line-613"><code>				buf[n] = '0'</code></span>
<span class="codeline" id="line-614"><code>			} else {</code></span>
<span class="codeline" id="line-615"><code>				for pc &gt; 0 {</code></span>
<span class="codeline" id="line-616"><code>					n--</code></span>
<span class="codeline" id="line-617"><code>					buf[n] = "0123456789abcdef"[pc&amp;15]</code></span>
<span class="codeline" id="line-618"><code>					pc &gt;&gt;= 4</code></span>
<span class="codeline" id="line-619"><code>				}</code></span>
<span class="codeline" id="line-620"><code>			}</code></span>
<span class="codeline" id="line-621"><code>			n--</code></span>
<span class="codeline" id="line-622"><code>			buf[n] = 'x'</code></span>
<span class="codeline" id="line-623"><code>			n--</code></span>
<span class="codeline" id="line-624"><code>			buf[n] = '0'</code></span>
<span class="codeline" id="line-625"><code>			n--</code></span>
<span class="codeline" id="line-626"><code>			buf[n] = '('</code></span>
<span class="codeline" id="line-627"><code>			dumpslice(buf[n:])</code></span>
<span class="codeline" id="line-628"><code>			dumpstr("?")</code></span>
<span class="codeline" id="line-629"><code>			dumpint(0)</code></span>
<span class="codeline" id="line-630"><code>		} else {</code></span>
<span class="codeline" id="line-631"><code>			dumpstr(funcname(f))</code></span>
<span class="codeline" id="line-632"><code>			if i &gt; 0 &amp;&amp; pc &gt; f.entry {</code></span>
<span class="codeline" id="line-633"><code>				pc--</code></span>
<span class="codeline" id="line-634"><code>			}</code></span>
<span class="codeline" id="line-635"><code>			file, line := funcline(f, pc)</code></span>
<span class="codeline" id="line-636"><code>			dumpstr(file)</code></span>
<span class="codeline" id="line-637"><code>			dumpint(uint64(line))</code></span>
<span class="codeline" id="line-638"><code>		}</code></span>
<span class="codeline" id="line-639"><code>	}</code></span>
<span class="codeline" id="line-640"><code>	dumpint(uint64(allocs))</code></span>
<span class="codeline" id="line-641"><code>	dumpint(uint64(frees))</code></span>
<span class="codeline" id="line-642"><code>}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>func dumpmemprof() {</code></span>
<span class="codeline" id="line-645"><code>	// To protect mheap_.allspans.</code></span>
<span class="codeline" id="line-646"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>	iterate_memprof(dumpmemprof_callback)</code></span>
<span class="codeline" id="line-649"><code>	for _, s := range mheap_.allspans {</code></span>
<span class="codeline" id="line-650"><code>		if s.state.get() != mSpanInUse {</code></span>
<span class="codeline" id="line-651"><code>			continue</code></span>
<span class="codeline" id="line-652"><code>		}</code></span>
<span class="codeline" id="line-653"><code>		for sp := s.specials; sp != nil; sp = sp.next {</code></span>
<span class="codeline" id="line-654"><code>			if sp.kind != _KindSpecialProfile {</code></span>
<span class="codeline" id="line-655"><code>				continue</code></span>
<span class="codeline" id="line-656"><code>			}</code></span>
<span class="codeline" id="line-657"><code>			spp := (*specialprofile)(unsafe.Pointer(sp))</code></span>
<span class="codeline" id="line-658"><code>			p := s.base() + uintptr(spp.special.offset)</code></span>
<span class="codeline" id="line-659"><code>			dumpint(tagAllocSample)</code></span>
<span class="codeline" id="line-660"><code>			dumpint(uint64(p))</code></span>
<span class="codeline" id="line-661"><code>			dumpint(uint64(uintptr(unsafe.Pointer(spp.b))))</code></span>
<span class="codeline" id="line-662"><code>		}</code></span>
<span class="codeline" id="line-663"><code>	}</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>var dumphdr = []byte("go1.7 heap dump\n")</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>func mdump(m *MemStats) {</code></span>
<span class="codeline" id="line-669"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-670"><code></code></span>
<span class="codeline" id="line-671"><code>	// make sure we're done sweeping</code></span>
<span class="codeline" id="line-672"><code>	for _, s := range mheap_.allspans {</code></span>
<span class="codeline" id="line-673"><code>		if s.state.get() == mSpanInUse {</code></span>
<span class="codeline" id="line-674"><code>			s.ensureSwept()</code></span>
<span class="codeline" id="line-675"><code>		}</code></span>
<span class="codeline" id="line-676"><code>	}</code></span>
<span class="codeline" id="line-677"><code>	memclrNoHeapPointers(unsafe.Pointer(&amp;typecache), unsafe.Sizeof(typecache))</code></span>
<span class="codeline" id="line-678"><code>	dwrite(unsafe.Pointer(&amp;dumphdr[0]), uintptr(len(dumphdr)))</code></span>
<span class="codeline" id="line-679"><code>	dumpparams()</code></span>
<span class="codeline" id="line-680"><code>	dumpitabs()</code></span>
<span class="codeline" id="line-681"><code>	dumpobjs()</code></span>
<span class="codeline" id="line-682"><code>	dumpgs()</code></span>
<span class="codeline" id="line-683"><code>	dumpms()</code></span>
<span class="codeline" id="line-684"><code>	dumproots()</code></span>
<span class="codeline" id="line-685"><code>	dumpmemstats(m)</code></span>
<span class="codeline" id="line-686"><code>	dumpmemprof()</code></span>
<span class="codeline" id="line-687"><code>	dumpint(tagEOF)</code></span>
<span class="codeline" id="line-688"><code>	flush()</code></span>
<span class="codeline" id="line-689"><code>}</code></span>
<span class="codeline" id="line-690"><code></code></span>
<span class="codeline" id="line-691"><code>func writeheapdump_m(fd uintptr, m *MemStats) {</code></span>
<span class="codeline" id="line-692"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-693"><code></code></span>
<span class="codeline" id="line-694"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-695"><code>	casgstatus(_g_.m.curg, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-696"><code>	_g_.waitreason = waitReasonDumpingHeap</code></span>
<span class="codeline" id="line-697"><code></code></span>
<span class="codeline" id="line-698"><code>	// Update stats so we can dump them.</code></span>
<span class="codeline" id="line-699"><code>	// As a side effect, flushes all the mcaches so the mspan.freelist</code></span>
<span class="codeline" id="line-700"><code>	// lists contain all the free objects.</code></span>
<span class="codeline" id="line-701"><code>	updatememstats()</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>	// Set dump file.</code></span>
<span class="codeline" id="line-704"><code>	dumpfd = fd</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>	// Call dump routine.</code></span>
<span class="codeline" id="line-707"><code>	mdump(m)</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>	// Reset dump file.</code></span>
<span class="codeline" id="line-710"><code>	dumpfd = 0</code></span>
<span class="codeline" id="line-711"><code>	if tmpbuf != nil {</code></span>
<span class="codeline" id="line-712"><code>		sysFree(unsafe.Pointer(&amp;tmpbuf[0]), uintptr(len(tmpbuf)), &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-713"><code>		tmpbuf = nil</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>	casgstatus(_g_.m.curg, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>// dumpint() the kind &amp; offset of each field in an object.</code></span>
<span class="codeline" id="line-720"><code>func dumpfields(bv bitvector) {</code></span>
<span class="codeline" id="line-721"><code>	dumpbv(&amp;bv, 0)</code></span>
<span class="codeline" id="line-722"><code>	dumpint(fieldKindEol)</code></span>
<span class="codeline" id="line-723"><code>}</code></span>
<span class="codeline" id="line-724"><code></code></span>
<span class="codeline" id="line-725"><code>func makeheapobjbv(p uintptr, size uintptr) bitvector {</code></span>
<span class="codeline" id="line-726"><code>	// Extend the temp buffer if necessary.</code></span>
<span class="codeline" id="line-727"><code>	nptr := size / sys.PtrSize</code></span>
<span class="codeline" id="line-728"><code>	if uintptr(len(tmpbuf)) &lt; nptr/8+1 {</code></span>
<span class="codeline" id="line-729"><code>		if tmpbuf != nil {</code></span>
<span class="codeline" id="line-730"><code>			sysFree(unsafe.Pointer(&amp;tmpbuf[0]), uintptr(len(tmpbuf)), &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-731"><code>		}</code></span>
<span class="codeline" id="line-732"><code>		n := nptr/8 + 1</code></span>
<span class="codeline" id="line-733"><code>		p := sysAlloc(n, &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-734"><code>		if p == nil {</code></span>
<span class="codeline" id="line-735"><code>			throw("heapdump: out of memory")</code></span>
<span class="codeline" id="line-736"><code>		}</code></span>
<span class="codeline" id="line-737"><code>		tmpbuf = (*[1 &lt;&lt; 30]byte)(p)[:n]</code></span>
<span class="codeline" id="line-738"><code>	}</code></span>
<span class="codeline" id="line-739"><code>	// Convert heap bitmap to pointer bitmap.</code></span>
<span class="codeline" id="line-740"><code>	for i := uintptr(0); i &lt; nptr/8+1; i++ {</code></span>
<span class="codeline" id="line-741"><code>		tmpbuf[i] = 0</code></span>
<span class="codeline" id="line-742"><code>	}</code></span>
<span class="codeline" id="line-743"><code>	i := uintptr(0)</code></span>
<span class="codeline" id="line-744"><code>	hbits := heapBitsForAddr(p)</code></span>
<span class="codeline" id="line-745"><code>	for ; i &lt; nptr; i++ {</code></span>
<span class="codeline" id="line-746"><code>		if !hbits.morePointers() {</code></span>
<span class="codeline" id="line-747"><code>			break // end of object</code></span>
<span class="codeline" id="line-748"><code>		}</code></span>
<span class="codeline" id="line-749"><code>		if hbits.isPointer() {</code></span>
<span class="codeline" id="line-750"><code>			tmpbuf[i/8] |= 1 &lt;&lt; (i % 8)</code></span>
<span class="codeline" id="line-751"><code>		}</code></span>
<span class="codeline" id="line-752"><code>		hbits = hbits.next()</code></span>
<span class="codeline" id="line-753"><code>	}</code></span>
<span class="codeline" id="line-754"><code>	return bitvector{int32(i), &amp;tmpbuf[0]}</code></span>
<span class="codeline" id="line-755"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>