<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: slice.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	slice.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"runtime/internal/math"</code></span>
<span class="codeline" id="line-9"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-10"><code>	"unsafe"</code></span>
<span class="codeline" id="line-11"><code>)</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>type slice struct {</code></span>
<span class="codeline" id="line-14"><code>	array unsafe.Pointer</code></span>
<span class="codeline" id="line-15"><code>	len   int</code></span>
<span class="codeline" id="line-16"><code>	cap   int</code></span>
<span class="codeline" id="line-17"><code>}</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// A notInHeapSlice is a slice backed by go:notinheap memory.</code></span>
<span class="codeline" id="line-20"><code>type notInHeapSlice struct {</code></span>
<span class="codeline" id="line-21"><code>	array *notInHeap</code></span>
<span class="codeline" id="line-22"><code>	len   int</code></span>
<span class="codeline" id="line-23"><code>	cap   int</code></span>
<span class="codeline" id="line-24"><code>}</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>func panicmakeslicelen() {</code></span>
<span class="codeline" id="line-27"><code>	panic(errorString("makeslice: len out of range"))</code></span>
<span class="codeline" id="line-28"><code>}</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>func panicmakeslicecap() {</code></span>
<span class="codeline" id="line-31"><code>	panic(errorString("makeslice: cap out of range"))</code></span>
<span class="codeline" id="line-32"><code>}</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// makeslicecopy allocates a slice of "tolen" elements of type "et",</code></span>
<span class="codeline" id="line-35"><code>// then copies "fromlen" elements of type "et" into that new allocation from "from".</code></span>
<span class="codeline" id="line-36"><code>func makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer {</code></span>
<span class="codeline" id="line-37"><code>	var tomem, copymem uintptr</code></span>
<span class="codeline" id="line-38"><code>	if uintptr(tolen) &gt; uintptr(fromlen) {</code></span>
<span class="codeline" id="line-39"><code>		var overflow bool</code></span>
<span class="codeline" id="line-40"><code>		tomem, overflow = math.MulUintptr(et.size, uintptr(tolen))</code></span>
<span class="codeline" id="line-41"><code>		if overflow || tomem &gt; maxAlloc || tolen &lt; 0 {</code></span>
<span class="codeline" id="line-42"><code>			panicmakeslicelen()</code></span>
<span class="codeline" id="line-43"><code>		}</code></span>
<span class="codeline" id="line-44"><code>		copymem = et.size * uintptr(fromlen)</code></span>
<span class="codeline" id="line-45"><code>	} else {</code></span>
<span class="codeline" id="line-46"><code>		// fromlen is a known good length providing and equal or greater than tolen,</code></span>
<span class="codeline" id="line-47"><code>		// thereby making tolen a good slice length too as from and to slices have the</code></span>
<span class="codeline" id="line-48"><code>		// same element width.</code></span>
<span class="codeline" id="line-49"><code>		tomem = et.size * uintptr(tolen)</code></span>
<span class="codeline" id="line-50"><code>		copymem = tomem</code></span>
<span class="codeline" id="line-51"><code>	}</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>	var to unsafe.Pointer</code></span>
<span class="codeline" id="line-54"><code>	if et.ptrdata == 0 {</code></span>
<span class="codeline" id="line-55"><code>		to = mallocgc(tomem, nil, false)</code></span>
<span class="codeline" id="line-56"><code>		if copymem &lt; tomem {</code></span>
<span class="codeline" id="line-57"><code>			memclrNoHeapPointers(add(to, copymem), tomem-copymem)</code></span>
<span class="codeline" id="line-58"><code>		}</code></span>
<span class="codeline" id="line-59"><code>	} else {</code></span>
<span class="codeline" id="line-60"><code>		// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</code></span>
<span class="codeline" id="line-61"><code>		to = mallocgc(tomem, et, true)</code></span>
<span class="codeline" id="line-62"><code>		if copymem &gt; 0 &amp;&amp; writeBarrier.enabled {</code></span>
<span class="codeline" id="line-63"><code>			// Only shade the pointers in old.array since we know the destination slice to</code></span>
<span class="codeline" id="line-64"><code>			// only contains nil pointers because it has been cleared during alloc.</code></span>
<span class="codeline" id="line-65"><code>			bulkBarrierPreWriteSrcOnly(uintptr(to), uintptr(from), copymem)</code></span>
<span class="codeline" id="line-66"><code>		}</code></span>
<span class="codeline" id="line-67"><code>	}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-70"><code>		callerpc := getcallerpc()</code></span>
<span class="codeline" id="line-71"><code>		pc := funcPC(makeslicecopy)</code></span>
<span class="codeline" id="line-72"><code>		racereadrangepc(from, copymem, callerpc, pc)</code></span>
<span class="codeline" id="line-73"><code>	}</code></span>
<span class="codeline" id="line-74"><code>	if msanenabled {</code></span>
<span class="codeline" id="line-75"><code>		msanread(from, copymem)</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>	memmove(to, from, copymem)</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>	return to</code></span>
<span class="codeline" id="line-81"><code>}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>func makeslice(et *_type, len, cap int) unsafe.Pointer {</code></span>
<span class="codeline" id="line-84"><code>	mem, overflow := math.MulUintptr(et.size, uintptr(cap))</code></span>
<span class="codeline" id="line-85"><code>	if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {</code></span>
<span class="codeline" id="line-86"><code>		// NOTE: Produce a 'len out of range' error instead of a</code></span>
<span class="codeline" id="line-87"><code>		// 'cap out of range' error when someone does make([]T, bignumber).</code></span>
<span class="codeline" id="line-88"><code>		// 'cap out of range' is true too, but since the cap is only being</code></span>
<span class="codeline" id="line-89"><code>		// supplied implicitly, saying len is clearer.</code></span>
<span class="codeline" id="line-90"><code>		// See golang.org/issue/4085.</code></span>
<span class="codeline" id="line-91"><code>		mem, overflow := math.MulUintptr(et.size, uintptr(len))</code></span>
<span class="codeline" id="line-92"><code>		if overflow || mem &gt; maxAlloc || len &lt; 0 {</code></span>
<span class="codeline" id="line-93"><code>			panicmakeslicelen()</code></span>
<span class="codeline" id="line-94"><code>		}</code></span>
<span class="codeline" id="line-95"><code>		panicmakeslicecap()</code></span>
<span class="codeline" id="line-96"><code>	}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>	return mallocgc(mem, et, true)</code></span>
<span class="codeline" id="line-99"><code>}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {</code></span>
<span class="codeline" id="line-102"><code>	len := int(len64)</code></span>
<span class="codeline" id="line-103"><code>	if int64(len) != len64 {</code></span>
<span class="codeline" id="line-104"><code>		panicmakeslicelen()</code></span>
<span class="codeline" id="line-105"><code>	}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	cap := int(cap64)</code></span>
<span class="codeline" id="line-108"><code>	if int64(cap) != cap64 {</code></span>
<span class="codeline" id="line-109"><code>		panicmakeslicecap()</code></span>
<span class="codeline" id="line-110"><code>	}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	return makeslice(et, len, cap)</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// growslice handles slice growth during append.</code></span>
<span class="codeline" id="line-116"><code>// It is passed the slice element type, the old slice, and the desired new minimum capacity,</code></span>
<span class="codeline" id="line-117"><code>// and it returns a new slice with at least that capacity, with the old data</code></span>
<span class="codeline" id="line-118"><code>// copied into it.</code></span>
<span class="codeline" id="line-119"><code>// The new slice's length is set to the old slice's length,</code></span>
<span class="codeline" id="line-120"><code>// NOT to the new requested capacity.</code></span>
<span class="codeline" id="line-121"><code>// This is for codegen convenience. The old slice's length is used immediately</code></span>
<span class="codeline" id="line-122"><code>// to calculate where to write new values during an append.</code></span>
<span class="codeline" id="line-123"><code>// TODO: When the old backend is gone, reconsider this decision.</code></span>
<span class="codeline" id="line-124"><code>// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</code></span>
<span class="codeline" id="line-125"><code>func growslice(et *_type, old slice, cap int) slice {</code></span>
<span class="codeline" id="line-126"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-127"><code>		callerpc := getcallerpc()</code></span>
<span class="codeline" id="line-128"><code>		racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))</code></span>
<span class="codeline" id="line-129"><code>	}</code></span>
<span class="codeline" id="line-130"><code>	if msanenabled {</code></span>
<span class="codeline" id="line-131"><code>		msanread(old.array, uintptr(old.len*int(et.size)))</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>	if cap &lt; old.cap {</code></span>
<span class="codeline" id="line-135"><code>		panic(errorString("growslice: cap out of range"))</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>	if et.size == 0 {</code></span>
<span class="codeline" id="line-139"><code>		// append should not create a slice with nil pointer but non-zero len.</code></span>
<span class="codeline" id="line-140"><code>		// We assume that append doesn't need to preserve old.array in this case.</code></span>
<span class="codeline" id="line-141"><code>		return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}</code></span>
<span class="codeline" id="line-142"><code>	}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>	newcap := old.cap</code></span>
<span class="codeline" id="line-145"><code>	doublecap := newcap + newcap</code></span>
<span class="codeline" id="line-146"><code>	if cap &gt; doublecap {</code></span>
<span class="codeline" id="line-147"><code>		newcap = cap</code></span>
<span class="codeline" id="line-148"><code>	} else {</code></span>
<span class="codeline" id="line-149"><code>		if old.cap &lt; 1024 {</code></span>
<span class="codeline" id="line-150"><code>			newcap = doublecap</code></span>
<span class="codeline" id="line-151"><code>		} else {</code></span>
<span class="codeline" id="line-152"><code>			// Check 0 &lt; newcap to detect overflow</code></span>
<span class="codeline" id="line-153"><code>			// and prevent an infinite loop.</code></span>
<span class="codeline" id="line-154"><code>			for 0 &lt; newcap &amp;&amp; newcap &lt; cap {</code></span>
<span class="codeline" id="line-155"><code>				newcap += newcap / 4</code></span>
<span class="codeline" id="line-156"><code>			}</code></span>
<span class="codeline" id="line-157"><code>			// Set newcap to the requested cap when</code></span>
<span class="codeline" id="line-158"><code>			// the newcap calculation overflowed.</code></span>
<span class="codeline" id="line-159"><code>			if newcap &lt;= 0 {</code></span>
<span class="codeline" id="line-160"><code>				newcap = cap</code></span>
<span class="codeline" id="line-161"><code>			}</code></span>
<span class="codeline" id="line-162"><code>		}</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>	var overflow bool</code></span>
<span class="codeline" id="line-166"><code>	var lenmem, newlenmem, capmem uintptr</code></span>
<span class="codeline" id="line-167"><code>	// Specialize for common values of et.size.</code></span>
<span class="codeline" id="line-168"><code>	// For 1 we don't need any division/multiplication.</code></span>
<span class="codeline" id="line-169"><code>	// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</code></span>
<span class="codeline" id="line-170"><code>	// For powers of 2, use a variable shift.</code></span>
<span class="codeline" id="line-171"><code>	switch {</code></span>
<span class="codeline" id="line-172"><code>	case et.size == 1:</code></span>
<span class="codeline" id="line-173"><code>		lenmem = uintptr(old.len)</code></span>
<span class="codeline" id="line-174"><code>		newlenmem = uintptr(cap)</code></span>
<span class="codeline" id="line-175"><code>		capmem = roundupsize(uintptr(newcap))</code></span>
<span class="codeline" id="line-176"><code>		overflow = uintptr(newcap) &gt; maxAlloc</code></span>
<span class="codeline" id="line-177"><code>		newcap = int(capmem)</code></span>
<span class="codeline" id="line-178"><code>	case et.size == sys.PtrSize:</code></span>
<span class="codeline" id="line-179"><code>		lenmem = uintptr(old.len) * sys.PtrSize</code></span>
<span class="codeline" id="line-180"><code>		newlenmem = uintptr(cap) * sys.PtrSize</code></span>
<span class="codeline" id="line-181"><code>		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)</code></span>
<span class="codeline" id="line-182"><code>		overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize</code></span>
<span class="codeline" id="line-183"><code>		newcap = int(capmem / sys.PtrSize)</code></span>
<span class="codeline" id="line-184"><code>	case isPowerOfTwo(et.size):</code></span>
<span class="codeline" id="line-185"><code>		var shift uintptr</code></span>
<span class="codeline" id="line-186"><code>		if sys.PtrSize == 8 {</code></span>
<span class="codeline" id="line-187"><code>			// Mask shift for better code generation.</code></span>
<span class="codeline" id="line-188"><code>			shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63</code></span>
<span class="codeline" id="line-189"><code>		} else {</code></span>
<span class="codeline" id="line-190"><code>			shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31</code></span>
<span class="codeline" id="line-191"><code>		}</code></span>
<span class="codeline" id="line-192"><code>		lenmem = uintptr(old.len) &lt;&lt; shift</code></span>
<span class="codeline" id="line-193"><code>		newlenmem = uintptr(cap) &lt;&lt; shift</code></span>
<span class="codeline" id="line-194"><code>		capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)</code></span>
<span class="codeline" id="line-195"><code>		overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)</code></span>
<span class="codeline" id="line-196"><code>		newcap = int(capmem &gt;&gt; shift)</code></span>
<span class="codeline" id="line-197"><code>	default:</code></span>
<span class="codeline" id="line-198"><code>		lenmem = uintptr(old.len) * et.size</code></span>
<span class="codeline" id="line-199"><code>		newlenmem = uintptr(cap) * et.size</code></span>
<span class="codeline" id="line-200"><code>		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))</code></span>
<span class="codeline" id="line-201"><code>		capmem = roundupsize(capmem)</code></span>
<span class="codeline" id="line-202"><code>		newcap = int(capmem / et.size)</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>	// The check of overflow in addition to capmem &gt; maxAlloc is needed</code></span>
<span class="codeline" id="line-206"><code>	// to prevent an overflow which can be used to trigger a segfault</code></span>
<span class="codeline" id="line-207"><code>	// on 32bit architectures with this example program:</code></span>
<span class="codeline" id="line-208"><code>	//</code></span>
<span class="codeline" id="line-209"><code>	// type T [1&lt;&lt;27 + 1]int64</code></span>
<span class="codeline" id="line-210"><code>	//</code></span>
<span class="codeline" id="line-211"><code>	// var d T</code></span>
<span class="codeline" id="line-212"><code>	// var s []T</code></span>
<span class="codeline" id="line-213"><code>	//</code></span>
<span class="codeline" id="line-214"><code>	// func main() {</code></span>
<span class="codeline" id="line-215"><code>	//   s = append(s, d, d, d, d)</code></span>
<span class="codeline" id="line-216"><code>	//   print(len(s), "\n")</code></span>
<span class="codeline" id="line-217"><code>	// }</code></span>
<span class="codeline" id="line-218"><code>	if overflow || capmem &gt; maxAlloc {</code></span>
<span class="codeline" id="line-219"><code>		panic(errorString("growslice: cap out of range"))</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>	var p unsafe.Pointer</code></span>
<span class="codeline" id="line-223"><code>	if et.ptrdata == 0 {</code></span>
<span class="codeline" id="line-224"><code>		p = mallocgc(capmem, nil, false)</code></span>
<span class="codeline" id="line-225"><code>		// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</code></span>
<span class="codeline" id="line-226"><code>		// Only clear the part that will not be overwritten.</code></span>
<span class="codeline" id="line-227"><code>		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</code></span>
<span class="codeline" id="line-228"><code>	} else {</code></span>
<span class="codeline" id="line-229"><code>		// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</code></span>
<span class="codeline" id="line-230"><code>		p = mallocgc(capmem, et, true)</code></span>
<span class="codeline" id="line-231"><code>		if lenmem &gt; 0 &amp;&amp; writeBarrier.enabled {</code></span>
<span class="codeline" id="line-232"><code>			// Only shade the pointers in old.array since we know the destination slice p</code></span>
<span class="codeline" id="line-233"><code>			// only contains nil pointers because it has been cleared during alloc.</code></span>
<span class="codeline" id="line-234"><code>			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)</code></span>
<span class="codeline" id="line-235"><code>		}</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	memmove(p, old.array, lenmem)</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>	return slice{p, old.len, newcap}</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>func isPowerOfTwo(x uintptr) bool {</code></span>
<span class="codeline" id="line-243"><code>	return x&amp;(x-1) == 0</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>// slicecopy is used to copy from a string or slice of pointerless elements into a slice.</code></span>
<span class="codeline" id="line-247"><code>func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int {</code></span>
<span class="codeline" id="line-248"><code>	if fromLen == 0 || toLen == 0 {</code></span>
<span class="codeline" id="line-249"><code>		return 0</code></span>
<span class="codeline" id="line-250"><code>	}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>	n := fromLen</code></span>
<span class="codeline" id="line-253"><code>	if toLen &lt; n {</code></span>
<span class="codeline" id="line-254"><code>		n = toLen</code></span>
<span class="codeline" id="line-255"><code>	}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>	if width == 0 {</code></span>
<span class="codeline" id="line-258"><code>		return n</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>	size := uintptr(n) * width</code></span>
<span class="codeline" id="line-262"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-263"><code>		callerpc := getcallerpc()</code></span>
<span class="codeline" id="line-264"><code>		pc := funcPC(slicecopy)</code></span>
<span class="codeline" id="line-265"><code>		racereadrangepc(fromPtr, size, callerpc, pc)</code></span>
<span class="codeline" id="line-266"><code>		racewriterangepc(toPtr, size, callerpc, pc)</code></span>
<span class="codeline" id="line-267"><code>	}</code></span>
<span class="codeline" id="line-268"><code>	if msanenabled {</code></span>
<span class="codeline" id="line-269"><code>		msanread(fromPtr, size)</code></span>
<span class="codeline" id="line-270"><code>		msanwrite(toPtr, size)</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	if size == 1 { // common case worth about 2x to do here</code></span>
<span class="codeline" id="line-274"><code>		// TODO: is this still worth it with new memmove impl?</code></span>
<span class="codeline" id="line-275"><code>		*(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer</code></span>
<span class="codeline" id="line-276"><code>	} else {</code></span>
<span class="codeline" id="line-277"><code>		memmove(toPtr, fromPtr, size)</code></span>
<span class="codeline" id="line-278"><code>	}</code></span>
<span class="codeline" id="line-279"><code>	return n</code></span>
<span class="codeline" id="line-280"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>