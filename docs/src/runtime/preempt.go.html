<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: preempt.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	preempt.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2019 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Goroutine preemption</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// A goroutine can be preempted at any safe-point. Currently, there</code></span>
<span class="codeline" id="line-8"><code>// are a few categories of safe-points:</code></span>
<span class="codeline" id="line-9"><code>//</code></span>
<span class="codeline" id="line-10"><code>// 1. A blocked safe-point occurs for the duration that a goroutine is</code></span>
<span class="codeline" id="line-11"><code>//    descheduled, blocked on synchronization, or in a system call.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>// 2. Synchronous safe-points occur when a running goroutine checks</code></span>
<span class="codeline" id="line-14"><code>//    for a preemption request.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// 3. Asynchronous safe-points occur at any instruction in user code</code></span>
<span class="codeline" id="line-17"><code>//    where the goroutine can be safely paused and a conservative</code></span>
<span class="codeline" id="line-18"><code>//    stack and register scan can find stack roots. The runtime can</code></span>
<span class="codeline" id="line-19"><code>//    stop a goroutine at an async safe-point using a signal.</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>// At both blocked and synchronous safe-points, a goroutine's CPU</code></span>
<span class="codeline" id="line-22"><code>// state is minimal and the garbage collector has complete information</code></span>
<span class="codeline" id="line-23"><code>// about its entire stack. This makes it possible to deschedule a</code></span>
<span class="codeline" id="line-24"><code>// goroutine with minimal space, and to precisely scan a goroutine's</code></span>
<span class="codeline" id="line-25"><code>// stack.</code></span>
<span class="codeline" id="line-26"><code>//</code></span>
<span class="codeline" id="line-27"><code>// Synchronous safe-points are implemented by overloading the stack</code></span>
<span class="codeline" id="line-28"><code>// bound check in function prologues. To preempt a goroutine at the</code></span>
<span class="codeline" id="line-29"><code>// next synchronous safe-point, the runtime poisons the goroutine's</code></span>
<span class="codeline" id="line-30"><code>// stack bound to a value that will cause the next stack bound check</code></span>
<span class="codeline" id="line-31"><code>// to fail and enter the stack growth implementation, which will</code></span>
<span class="codeline" id="line-32"><code>// detect that it was actually a preemption and redirect to preemption</code></span>
<span class="codeline" id="line-33"><code>// handling.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// Preemption at asynchronous safe-points is implemented by suspending</code></span>
<span class="codeline" id="line-36"><code>// the thread using an OS mechanism (e.g., signals) and inspecting its</code></span>
<span class="codeline" id="line-37"><code>// state to determine if the goroutine was at an asynchronous</code></span>
<span class="codeline" id="line-38"><code>// safe-point. Since the thread suspension itself is generally</code></span>
<span class="codeline" id="line-39"><code>// asynchronous, it also checks if the running goroutine wants to be</code></span>
<span class="codeline" id="line-40"><code>// preempted, since this could have changed. If all conditions are</code></span>
<span class="codeline" id="line-41"><code>// satisfied, it adjusts the signal context to make it look like the</code></span>
<span class="codeline" id="line-42"><code>// signaled thread just called asyncPreempt and resumes the thread.</code></span>
<span class="codeline" id="line-43"><code>// asyncPreempt spills all registers and enters the scheduler.</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>// (An alternative would be to preempt in the signal handler itself.</code></span>
<span class="codeline" id="line-46"><code>// This would let the OS save and restore the register state and the</code></span>
<span class="codeline" id="line-47"><code>// runtime would only need to know how to extract potentially</code></span>
<span class="codeline" id="line-48"><code>// pointer-containing registers from the signal context. However, this</code></span>
<span class="codeline" id="line-49"><code>// would consume an M for every preempted G, and the scheduler itself</code></span>
<span class="codeline" id="line-50"><code>// is not designed to run from a signal handler, as it tends to</code></span>
<span class="codeline" id="line-51"><code>// allocate memory and start threads in the preemption path.)</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>package runtime</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>import (</code></span>
<span class="codeline" id="line-56"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-57"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-58"><code>	"unsafe"</code></span>
<span class="codeline" id="line-59"><code>)</code></span>
<span class="codeline" id="line-60"><code></code></span>
<span class="codeline" id="line-61"><code>type suspendGState struct {</code></span>
<span class="codeline" id="line-62"><code>	g *g</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>	// dead indicates the goroutine was not suspended because it</code></span>
<span class="codeline" id="line-65"><code>	// is dead. This goroutine could be reused after the dead</code></span>
<span class="codeline" id="line-66"><code>	// state was observed, so the caller must not assume that it</code></span>
<span class="codeline" id="line-67"><code>	// remains dead.</code></span>
<span class="codeline" id="line-68"><code>	dead bool</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>	// stopped indicates that this suspendG transitioned the G to</code></span>
<span class="codeline" id="line-71"><code>	// _Gwaiting via g.preemptStop and thus is responsible for</code></span>
<span class="codeline" id="line-72"><code>	// readying it when done.</code></span>
<span class="codeline" id="line-73"><code>	stopped bool</code></span>
<span class="codeline" id="line-74"><code>}</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>// suspendG suspends goroutine gp at a safe-point and returns the</code></span>
<span class="codeline" id="line-77"><code>// state of the suspended goroutine. The caller gets read access to</code></span>
<span class="codeline" id="line-78"><code>// the goroutine until it calls resumeG.</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>// It is safe for multiple callers to attempt to suspend the same</code></span>
<span class="codeline" id="line-81"><code>// goroutine at the same time. The goroutine may execute between</code></span>
<span class="codeline" id="line-82"><code>// subsequent successful suspend operations. The current</code></span>
<span class="codeline" id="line-83"><code>// implementation grants exclusive access to the goroutine, and hence</code></span>
<span class="codeline" id="line-84"><code>// multiple callers will serialize. However, the intent is to grant</code></span>
<span class="codeline" id="line-85"><code>// shared read access, so please don't depend on exclusive access.</code></span>
<span class="codeline" id="line-86"><code>//</code></span>
<span class="codeline" id="line-87"><code>// This must be called from the system stack and the user goroutine on</code></span>
<span class="codeline" id="line-88"><code>// the current M (if any) must be in a preemptible state. This</code></span>
<span class="codeline" id="line-89"><code>// prevents deadlocks where two goroutines attempt to suspend each</code></span>
<span class="codeline" id="line-90"><code>// other and both are in non-preemptible states. There are other ways</code></span>
<span class="codeline" id="line-91"><code>// to resolve this deadlock, but this seems simplest.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// TODO(austin): What if we instead required this to be called from a</code></span>
<span class="codeline" id="line-94"><code>// user goroutine? Then we could deschedule the goroutine while</code></span>
<span class="codeline" id="line-95"><code>// waiting instead of blocking the thread. If two goroutines tried to</code></span>
<span class="codeline" id="line-96"><code>// suspend each other, one of them would win and the other wouldn't</code></span>
<span class="codeline" id="line-97"><code>// complete the suspend until it was resumed. We would have to be</code></span>
<span class="codeline" id="line-98"><code>// careful that they couldn't actually queue up suspend for each other</code></span>
<span class="codeline" id="line-99"><code>// and then both be suspended. This would also avoid the need for a</code></span>
<span class="codeline" id="line-100"><code>// kernel context switch in the synchronous case because we could just</code></span>
<span class="codeline" id="line-101"><code>// directly schedule the waiter. The context switch is unavoidable in</code></span>
<span class="codeline" id="line-102"><code>// the signal case.</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>//go:systemstack</code></span>
<span class="codeline" id="line-105"><code>func suspendG(gp *g) suspendGState {</code></span>
<span class="codeline" id="line-106"><code>	if mp := getg().m; mp.curg != nil &amp;&amp; readgstatus(mp.curg) == _Grunning {</code></span>
<span class="codeline" id="line-107"><code>		// Since we're on the system stack of this M, the user</code></span>
<span class="codeline" id="line-108"><code>		// G is stuck at an unsafe point. If another goroutine</code></span>
<span class="codeline" id="line-109"><code>		// were to try to preempt m.curg, it could deadlock.</code></span>
<span class="codeline" id="line-110"><code>		throw("suspendG from non-preemptible goroutine")</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>	// See https://golang.org/cl/21503 for justification of the yield delay.</code></span>
<span class="codeline" id="line-114"><code>	const yieldDelay = 10 * 1000</code></span>
<span class="codeline" id="line-115"><code>	var nextYield int64</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// Drive the goroutine to a preemption point.</code></span>
<span class="codeline" id="line-118"><code>	stopped := false</code></span>
<span class="codeline" id="line-119"><code>	var asyncM *m</code></span>
<span class="codeline" id="line-120"><code>	var asyncGen uint32</code></span>
<span class="codeline" id="line-121"><code>	var nextPreemptM int64</code></span>
<span class="codeline" id="line-122"><code>	for i := 0; ; i++ {</code></span>
<span class="codeline" id="line-123"><code>		switch s := readgstatus(gp); s {</code></span>
<span class="codeline" id="line-124"><code>		default:</code></span>
<span class="codeline" id="line-125"><code>			if s&amp;_Gscan != 0 {</code></span>
<span class="codeline" id="line-126"><code>				// Someone else is suspending it. Wait</code></span>
<span class="codeline" id="line-127"><code>				// for them to finish.</code></span>
<span class="codeline" id="line-128"><code>				//</code></span>
<span class="codeline" id="line-129"><code>				// TODO: It would be nicer if we could</code></span>
<span class="codeline" id="line-130"><code>				// coalesce suspends.</code></span>
<span class="codeline" id="line-131"><code>				break</code></span>
<span class="codeline" id="line-132"><code>			}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>			dumpgstatus(gp)</code></span>
<span class="codeline" id="line-135"><code>			throw("invalid g status")</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>		case _Gdead:</code></span>
<span class="codeline" id="line-138"><code>			// Nothing to suspend.</code></span>
<span class="codeline" id="line-139"><code>			//</code></span>
<span class="codeline" id="line-140"><code>			// preemptStop may need to be cleared, but</code></span>
<span class="codeline" id="line-141"><code>			// doing that here could race with goroutine</code></span>
<span class="codeline" id="line-142"><code>			// reuse. Instead, goexit0 clears it.</code></span>
<span class="codeline" id="line-143"><code>			return suspendGState{dead: true}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>		case _Gcopystack:</code></span>
<span class="codeline" id="line-146"><code>			// The stack is being copied. We need to wait</code></span>
<span class="codeline" id="line-147"><code>			// until this is done.</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>		case _Gpreempted:</code></span>
<span class="codeline" id="line-150"><code>			// We (or someone else) suspended the G. Claim</code></span>
<span class="codeline" id="line-151"><code>			// ownership of it by transitioning it to</code></span>
<span class="codeline" id="line-152"><code>			// _Gwaiting.</code></span>
<span class="codeline" id="line-153"><code>			if !casGFromPreempted(gp, _Gpreempted, _Gwaiting) {</code></span>
<span class="codeline" id="line-154"><code>				break</code></span>
<span class="codeline" id="line-155"><code>			}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>			// We stopped the G, so we have to ready it later.</code></span>
<span class="codeline" id="line-158"><code>			stopped = true</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>			s = _Gwaiting</code></span>
<span class="codeline" id="line-161"><code>			fallthrough</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>		case _Grunnable, _Gsyscall, _Gwaiting:</code></span>
<span class="codeline" id="line-164"><code>			// Claim goroutine by setting scan bit.</code></span>
<span class="codeline" id="line-165"><code>			// This may race with execution or readying of gp.</code></span>
<span class="codeline" id="line-166"><code>			// The scan bit keeps it from transition state.</code></span>
<span class="codeline" id="line-167"><code>			if !castogscanstatus(gp, s, s|_Gscan) {</code></span>
<span class="codeline" id="line-168"><code>				break</code></span>
<span class="codeline" id="line-169"><code>			}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>			// Clear the preemption request. It's safe to</code></span>
<span class="codeline" id="line-172"><code>			// reset the stack guard because we hold the</code></span>
<span class="codeline" id="line-173"><code>			// _Gscan bit and thus own the stack.</code></span>
<span class="codeline" id="line-174"><code>			gp.preemptStop = false</code></span>
<span class="codeline" id="line-175"><code>			gp.preempt = false</code></span>
<span class="codeline" id="line-176"><code>			gp.stackguard0 = gp.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>			// The goroutine was already at a safe-point</code></span>
<span class="codeline" id="line-179"><code>			// and we've now locked that in.</code></span>
<span class="codeline" id="line-180"><code>			//</code></span>
<span class="codeline" id="line-181"><code>			// TODO: It would be much better if we didn't</code></span>
<span class="codeline" id="line-182"><code>			// leave it in _Gscan, but instead gently</code></span>
<span class="codeline" id="line-183"><code>			// prevented its scheduling until resumption.</code></span>
<span class="codeline" id="line-184"><code>			// Maybe we only use this to bump a suspended</code></span>
<span class="codeline" id="line-185"><code>			// count and the scheduler skips suspended</code></span>
<span class="codeline" id="line-186"><code>			// goroutines? That wouldn't be enough for</code></span>
<span class="codeline" id="line-187"><code>			// {_Gsyscall,_Gwaiting} -&gt; _Grunning. Maybe</code></span>
<span class="codeline" id="line-188"><code>			// for all those transitions we need to check</code></span>
<span class="codeline" id="line-189"><code>			// suspended and deschedule?</code></span>
<span class="codeline" id="line-190"><code>			return suspendGState{g: gp, stopped: stopped}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>		case _Grunning:</code></span>
<span class="codeline" id="line-193"><code>			// Optimization: if there is already a pending preemption request</code></span>
<span class="codeline" id="line-194"><code>			// (from the previous loop iteration), don't bother with the atomics.</code></span>
<span class="codeline" id="line-195"><code>			if gp.preemptStop &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt &amp;&amp; asyncM == gp.m &amp;&amp; atomic.Load(&amp;asyncM.preemptGen) == asyncGen {</code></span>
<span class="codeline" id="line-196"><code>				break</code></span>
<span class="codeline" id="line-197"><code>			}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>			// Temporarily block state transitions.</code></span>
<span class="codeline" id="line-200"><code>			if !castogscanstatus(gp, _Grunning, _Gscanrunning) {</code></span>
<span class="codeline" id="line-201"><code>				break</code></span>
<span class="codeline" id="line-202"><code>			}</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>			// Request synchronous preemption.</code></span>
<span class="codeline" id="line-205"><code>			gp.preemptStop = true</code></span>
<span class="codeline" id="line-206"><code>			gp.preempt = true</code></span>
<span class="codeline" id="line-207"><code>			gp.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>			// Prepare for asynchronous preemption.</code></span>
<span class="codeline" id="line-210"><code>			asyncM2 := gp.m</code></span>
<span class="codeline" id="line-211"><code>			asyncGen2 := atomic.Load(&amp;asyncM2.preemptGen)</code></span>
<span class="codeline" id="line-212"><code>			needAsync := asyncM != asyncM2 || asyncGen != asyncGen2</code></span>
<span class="codeline" id="line-213"><code>			asyncM = asyncM2</code></span>
<span class="codeline" id="line-214"><code>			asyncGen = asyncGen2</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>			casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>			// Send asynchronous preemption. We do this</code></span>
<span class="codeline" id="line-219"><code>			// after CASing the G back to _Grunning</code></span>
<span class="codeline" id="line-220"><code>			// because preemptM may be synchronous and we</code></span>
<span class="codeline" id="line-221"><code>			// don't want to catch the G just spinning on</code></span>
<span class="codeline" id="line-222"><code>			// its status.</code></span>
<span class="codeline" id="line-223"><code>			if preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 &amp;&amp; needAsync {</code></span>
<span class="codeline" id="line-224"><code>				// Rate limit preemptM calls. This is</code></span>
<span class="codeline" id="line-225"><code>				// particularly important on Windows</code></span>
<span class="codeline" id="line-226"><code>				// where preemptM is actually</code></span>
<span class="codeline" id="line-227"><code>				// synchronous and the spin loop here</code></span>
<span class="codeline" id="line-228"><code>				// can lead to live-lock.</code></span>
<span class="codeline" id="line-229"><code>				now := nanotime()</code></span>
<span class="codeline" id="line-230"><code>				if now &gt;= nextPreemptM {</code></span>
<span class="codeline" id="line-231"><code>					nextPreemptM = now + yieldDelay/2</code></span>
<span class="codeline" id="line-232"><code>					preemptM(asyncM)</code></span>
<span class="codeline" id="line-233"><code>				}</code></span>
<span class="codeline" id="line-234"><code>			}</code></span>
<span class="codeline" id="line-235"><code>		}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>		// TODO: Don't busy wait. This loop should really only</code></span>
<span class="codeline" id="line-238"><code>		// be a simple read/decide/CAS loop that only fails if</code></span>
<span class="codeline" id="line-239"><code>		// there's an active race. Once the CAS succeeds, we</code></span>
<span class="codeline" id="line-240"><code>		// should queue up the preemption (which will require</code></span>
<span class="codeline" id="line-241"><code>		// it to be reliable in the _Grunning case, not</code></span>
<span class="codeline" id="line-242"><code>		// best-effort) and then sleep until we're notified</code></span>
<span class="codeline" id="line-243"><code>		// that the goroutine is suspended.</code></span>
<span class="codeline" id="line-244"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-245"><code>			nextYield = nanotime() + yieldDelay</code></span>
<span class="codeline" id="line-246"><code>		}</code></span>
<span class="codeline" id="line-247"><code>		if nanotime() &lt; nextYield {</code></span>
<span class="codeline" id="line-248"><code>			procyield(10)</code></span>
<span class="codeline" id="line-249"><code>		} else {</code></span>
<span class="codeline" id="line-250"><code>			osyield()</code></span>
<span class="codeline" id="line-251"><code>			nextYield = nanotime() + yieldDelay/2</code></span>
<span class="codeline" id="line-252"><code>		}</code></span>
<span class="codeline" id="line-253"><code>	}</code></span>
<span class="codeline" id="line-254"><code>}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// resumeG undoes the effects of suspendG, allowing the suspended</code></span>
<span class="codeline" id="line-257"><code>// goroutine to continue from its current safe-point.</code></span>
<span class="codeline" id="line-258"><code>func resumeG(state suspendGState) {</code></span>
<span class="codeline" id="line-259"><code>	if state.dead {</code></span>
<span class="codeline" id="line-260"><code>		// We didn't actually stop anything.</code></span>
<span class="codeline" id="line-261"><code>		return</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>	gp := state.g</code></span>
<span class="codeline" id="line-265"><code>	switch s := readgstatus(gp); s {</code></span>
<span class="codeline" id="line-266"><code>	default:</code></span>
<span class="codeline" id="line-267"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-268"><code>		throw("unexpected g status")</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>	case _Grunnable | _Gscan,</code></span>
<span class="codeline" id="line-271"><code>		_Gwaiting | _Gscan,</code></span>
<span class="codeline" id="line-272"><code>		_Gsyscall | _Gscan:</code></span>
<span class="codeline" id="line-273"><code>		casfrom_Gscanstatus(gp, s, s&amp;^_Gscan)</code></span>
<span class="codeline" id="line-274"><code>	}</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	if state.stopped {</code></span>
<span class="codeline" id="line-277"><code>		// We stopped it, so we need to re-schedule it.</code></span>
<span class="codeline" id="line-278"><code>		ready(gp, 0, true)</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code>}</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>// canPreemptM reports whether mp is in a state that is safe to preempt.</code></span>
<span class="codeline" id="line-283"><code>//</code></span>
<span class="codeline" id="line-284"><code>// It is nosplit because it has nosplit callers.</code></span>
<span class="codeline" id="line-285"><code>//</code></span>
<span class="codeline" id="line-286"><code>//go:nosplit</code></span>
<span class="codeline" id="line-287"><code>func canPreemptM(mp *m) bool {</code></span>
<span class="codeline" id="line-288"><code>	return mp.locks == 0 &amp;&amp; mp.mallocing == 0 &amp;&amp; mp.preemptoff == "" &amp;&amp; mp.p.ptr().status == _Prunning</code></span>
<span class="codeline" id="line-289"><code>}</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>//go:generate go run mkpreempt.go</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>// asyncPreempt saves all user registers and calls asyncPreempt2.</code></span>
<span class="codeline" id="line-294"><code>//</code></span>
<span class="codeline" id="line-295"><code>// When stack scanning encounters an asyncPreempt frame, it scans that</code></span>
<span class="codeline" id="line-296"><code>// frame and its parent frame conservatively.</code></span>
<span class="codeline" id="line-297"><code>//</code></span>
<span class="codeline" id="line-298"><code>// asyncPreempt is implemented in assembly.</code></span>
<span class="codeline" id="line-299"><code>func asyncPreempt()</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>//go:nosplit</code></span>
<span class="codeline" id="line-302"><code>func asyncPreempt2() {</code></span>
<span class="codeline" id="line-303"><code>	gp := getg()</code></span>
<span class="codeline" id="line-304"><code>	gp.asyncSafePoint = true</code></span>
<span class="codeline" id="line-305"><code>	if gp.preemptStop {</code></span>
<span class="codeline" id="line-306"><code>		mcall(preemptPark)</code></span>
<span class="codeline" id="line-307"><code>	} else {</code></span>
<span class="codeline" id="line-308"><code>		mcall(gopreempt_m)</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	gp.asyncSafePoint = false</code></span>
<span class="codeline" id="line-311"><code>}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>// asyncPreemptStack is the bytes of stack space required to inject an</code></span>
<span class="codeline" id="line-314"><code>// asyncPreempt call.</code></span>
<span class="codeline" id="line-315"><code>var asyncPreemptStack = ^uintptr(0)</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>func init() {</code></span>
<span class="codeline" id="line-318"><code>	f := findfunc(funcPC(asyncPreempt))</code></span>
<span class="codeline" id="line-319"><code>	total := funcMaxSPDelta(f)</code></span>
<span class="codeline" id="line-320"><code>	f = findfunc(funcPC(asyncPreempt2))</code></span>
<span class="codeline" id="line-321"><code>	total += funcMaxSPDelta(f)</code></span>
<span class="codeline" id="line-322"><code>	// Add some overhead for return PCs, etc.</code></span>
<span class="codeline" id="line-323"><code>	asyncPreemptStack = uintptr(total) + 8*sys.PtrSize</code></span>
<span class="codeline" id="line-324"><code>	if asyncPreemptStack &gt; _StackLimit {</code></span>
<span class="codeline" id="line-325"><code>		// We need more than the nosplit limit. This isn't</code></span>
<span class="codeline" id="line-326"><code>		// unsafe, but it may limit asynchronous preemption.</code></span>
<span class="codeline" id="line-327"><code>		//</code></span>
<span class="codeline" id="line-328"><code>		// This may be a problem if we start using more</code></span>
<span class="codeline" id="line-329"><code>		// registers. In that case, we should store registers</code></span>
<span class="codeline" id="line-330"><code>		// in a context object. If we pre-allocate one per P,</code></span>
<span class="codeline" id="line-331"><code>		// asyncPreempt can spill just a few registers to the</code></span>
<span class="codeline" id="line-332"><code>		// stack, then grab its context object and spill into</code></span>
<span class="codeline" id="line-333"><code>		// it. When it enters the runtime, it would allocate a</code></span>
<span class="codeline" id="line-334"><code>		// new context for the P.</code></span>
<span class="codeline" id="line-335"><code>		print("runtime: asyncPreemptStack=", asyncPreemptStack, "\n")</code></span>
<span class="codeline" id="line-336"><code>		throw("async stack too large")</code></span>
<span class="codeline" id="line-337"><code>	}</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// wantAsyncPreempt returns whether an asynchronous preemption is</code></span>
<span class="codeline" id="line-341"><code>// queued for gp.</code></span>
<span class="codeline" id="line-342"><code>func wantAsyncPreempt(gp *g) bool {</code></span>
<span class="codeline" id="line-343"><code>	// Check both the G and the P.</code></span>
<span class="codeline" id="line-344"><code>	return (gp.preempt || gp.m.p != 0 &amp;&amp; gp.m.p.ptr().preempt) &amp;&amp; readgstatus(gp)&amp;^_Gscan == _Grunning</code></span>
<span class="codeline" id="line-345"><code>}</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>// isAsyncSafePoint reports whether gp at instruction PC is an</code></span>
<span class="codeline" id="line-348"><code>// asynchronous safe point. This indicates that:</code></span>
<span class="codeline" id="line-349"><code>//</code></span>
<span class="codeline" id="line-350"><code>// 1. It's safe to suspend gp and conservatively scan its stack and</code></span>
<span class="codeline" id="line-351"><code>// registers. There are no potentially hidden pointer values and it's</code></span>
<span class="codeline" id="line-352"><code>// not in the middle of an atomic sequence like a write barrier.</code></span>
<span class="codeline" id="line-353"><code>//</code></span>
<span class="codeline" id="line-354"><code>// 2. gp has enough stack space to inject the asyncPreempt call.</code></span>
<span class="codeline" id="line-355"><code>//</code></span>
<span class="codeline" id="line-356"><code>// 3. It's generally safe to interact with the runtime, even if we're</code></span>
<span class="codeline" id="line-357"><code>// in a signal handler stopped here. For example, there are no runtime</code></span>
<span class="codeline" id="line-358"><code>// locks held, so acquiring a runtime lock won't self-deadlock.</code></span>
<span class="codeline" id="line-359"><code>//</code></span>
<span class="codeline" id="line-360"><code>// In some cases the PC is safe for asynchronous preemption but it</code></span>
<span class="codeline" id="line-361"><code>// also needs to adjust the resumption PC. The new PC is returned in</code></span>
<span class="codeline" id="line-362"><code>// the second result.</code></span>
<span class="codeline" id="line-363"><code>func isAsyncSafePoint(gp *g, pc, sp, lr uintptr) (bool, uintptr) {</code></span>
<span class="codeline" id="line-364"><code>	mp := gp.m</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>	// Only user Gs can have safe-points. We check this first</code></span>
<span class="codeline" id="line-367"><code>	// because it's extremely common that we'll catch mp in the</code></span>
<span class="codeline" id="line-368"><code>	// scheduler processing this G preemption.</code></span>
<span class="codeline" id="line-369"><code>	if mp.curg != gp {</code></span>
<span class="codeline" id="line-370"><code>		return false, 0</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>	// Check M state.</code></span>
<span class="codeline" id="line-374"><code>	if mp.p == 0 || !canPreemptM(mp) {</code></span>
<span class="codeline" id="line-375"><code>		return false, 0</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>	// Check stack space.</code></span>
<span class="codeline" id="line-379"><code>	if sp &lt; gp.stack.lo || sp-gp.stack.lo &lt; asyncPreemptStack {</code></span>
<span class="codeline" id="line-380"><code>		return false, 0</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>	// Check if PC is an unsafe-point.</code></span>
<span class="codeline" id="line-384"><code>	f := findfunc(pc)</code></span>
<span class="codeline" id="line-385"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-386"><code>		// Not Go code.</code></span>
<span class="codeline" id="line-387"><code>		return false, 0</code></span>
<span class="codeline" id="line-388"><code>	}</code></span>
<span class="codeline" id="line-389"><code>	if (GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "mips64" || GOARCH == "mips64le") &amp;&amp; lr == pc+8 &amp;&amp; funcspdelta(f, pc, nil) == 0 {</code></span>
<span class="codeline" id="line-390"><code>		// We probably stopped at a half-executed CALL instruction,</code></span>
<span class="codeline" id="line-391"><code>		// where the LR is updated but the PC has not. If we preempt</code></span>
<span class="codeline" id="line-392"><code>		// here we'll see a seemingly self-recursive call, which is in</code></span>
<span class="codeline" id="line-393"><code>		// fact not.</code></span>
<span class="codeline" id="line-394"><code>		// This is normally ok, as we use the return address saved on</code></span>
<span class="codeline" id="line-395"><code>		// stack for unwinding, not the LR value. But if this is a</code></span>
<span class="codeline" id="line-396"><code>		// call to morestack, we haven't created the frame, and we'll</code></span>
<span class="codeline" id="line-397"><code>		// use the LR for unwinding, which will be bad.</code></span>
<span class="codeline" id="line-398"><code>		return false, 0</code></span>
<span class="codeline" id="line-399"><code>	}</code></span>
<span class="codeline" id="line-400"><code>	up, startpc := pcdatavalue2(f, _PCDATA_UnsafePoint, pc)</code></span>
<span class="codeline" id="line-401"><code>	if up != _PCDATA_UnsafePointSafe {</code></span>
<span class="codeline" id="line-402"><code>		// Unsafe-point marked by compiler. This includes</code></span>
<span class="codeline" id="line-403"><code>		// atomic sequences (e.g., write barrier) and nosplit</code></span>
<span class="codeline" id="line-404"><code>		// functions (except at calls).</code></span>
<span class="codeline" id="line-405"><code>		return false, 0</code></span>
<span class="codeline" id="line-406"><code>	}</code></span>
<span class="codeline" id="line-407"><code>	if fd := funcdata(f, _FUNCDATA_LocalsPointerMaps); fd == nil || fd == unsafe.Pointer(&amp;no_pointers_stackmap) {</code></span>
<span class="codeline" id="line-408"><code>		// This is assembly code. Don't assume it's</code></span>
<span class="codeline" id="line-409"><code>		// well-formed. We identify assembly code by</code></span>
<span class="codeline" id="line-410"><code>		// checking that it has either no stack map, or</code></span>
<span class="codeline" id="line-411"><code>		// no_pointers_stackmap, which is the stack map</code></span>
<span class="codeline" id="line-412"><code>		// for ones marked as NO_LOCAL_POINTERS.</code></span>
<span class="codeline" id="line-413"><code>		//</code></span>
<span class="codeline" id="line-414"><code>		// TODO: Are there cases that are safe but don't have a</code></span>
<span class="codeline" id="line-415"><code>		// locals pointer map, like empty frame functions?</code></span>
<span class="codeline" id="line-416"><code>		return false, 0</code></span>
<span class="codeline" id="line-417"><code>	}</code></span>
<span class="codeline" id="line-418"><code>	name := funcname(f)</code></span>
<span class="codeline" id="line-419"><code>	if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {</code></span>
<span class="codeline" id="line-420"><code>		inltree := (*[1 &lt;&lt; 20]inlinedCall)(inldata)</code></span>
<span class="codeline" id="line-421"><code>		ix := pcdatavalue(f, _PCDATA_InlTreeIndex, pc, nil)</code></span>
<span class="codeline" id="line-422"><code>		if ix &gt;= 0 {</code></span>
<span class="codeline" id="line-423"><code>			name = funcnameFromNameoff(f, inltree[ix].func_)</code></span>
<span class="codeline" id="line-424"><code>		}</code></span>
<span class="codeline" id="line-425"><code>	}</code></span>
<span class="codeline" id="line-426"><code>	if hasPrefix(name, "runtime.") ||</code></span>
<span class="codeline" id="line-427"><code>		hasPrefix(name, "runtime/internal/") ||</code></span>
<span class="codeline" id="line-428"><code>		hasPrefix(name, "reflect.") {</code></span>
<span class="codeline" id="line-429"><code>		// For now we never async preempt the runtime or</code></span>
<span class="codeline" id="line-430"><code>		// anything closely tied to the runtime. Known issues</code></span>
<span class="codeline" id="line-431"><code>		// include: various points in the scheduler ("don't</code></span>
<span class="codeline" id="line-432"><code>		// preempt between here and here"), much of the defer</code></span>
<span class="codeline" id="line-433"><code>		// implementation (untyped info on stack), bulk write</code></span>
<span class="codeline" id="line-434"><code>		// barriers (write barrier check),</code></span>
<span class="codeline" id="line-435"><code>		// reflect.{makeFuncStub,methodValueCall}.</code></span>
<span class="codeline" id="line-436"><code>		//</code></span>
<span class="codeline" id="line-437"><code>		// TODO(austin): We should improve this, or opt things</code></span>
<span class="codeline" id="line-438"><code>		// in incrementally.</code></span>
<span class="codeline" id="line-439"><code>		return false, 0</code></span>
<span class="codeline" id="line-440"><code>	}</code></span>
<span class="codeline" id="line-441"><code>	switch up {</code></span>
<span class="codeline" id="line-442"><code>	case _PCDATA_Restart1, _PCDATA_Restart2:</code></span>
<span class="codeline" id="line-443"><code>		// Restartable instruction sequence. Back off PC to</code></span>
<span class="codeline" id="line-444"><code>		// the start PC.</code></span>
<span class="codeline" id="line-445"><code>		if startpc == 0 || startpc &gt; pc || pc-startpc &gt; 20 {</code></span>
<span class="codeline" id="line-446"><code>			throw("bad restart PC")</code></span>
<span class="codeline" id="line-447"><code>		}</code></span>
<span class="codeline" id="line-448"><code>		return true, startpc</code></span>
<span class="codeline" id="line-449"><code>	case _PCDATA_RestartAtEntry:</code></span>
<span class="codeline" id="line-450"><code>		// Restart from the function entry at resumption.</code></span>
<span class="codeline" id="line-451"><code>		return true, f.entry</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code>	return true, pc</code></span>
<span class="codeline" id="line-454"><code>}</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>var no_pointers_stackmap uint64 // defined in assembly, for NO_LOCAL_POINTERS macro</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>