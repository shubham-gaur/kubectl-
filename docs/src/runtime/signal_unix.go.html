<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: signal_unix.go in package runtime</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	signal_unix.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2012 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"unsafe"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// sigTabT is the type of an entry in the global sigtable array.</code></span>
<span class="codeline" id="line-15"><code>// sigtable is inherently system dependent, and appears in OS-specific files,</code></span>
<span class="codeline" id="line-16"><code>// but sigTabT is the same for all Unixy systems.</code></span>
<span class="codeline" id="line-17"><code>// The sigtable array is indexed by a system signal number to get the flags</code></span>
<span class="codeline" id="line-18"><code>// and printable name of each signal.</code></span>
<span class="codeline" id="line-19"><code>type sigTabT struct {</code></span>
<span class="codeline" id="line-20"><code>	flags int32</code></span>
<span class="codeline" id="line-21"><code>	name  string</code></span>
<span class="codeline" id="line-22"><code>}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>//go:linkname os_sigpipe os.sigpipe</code></span>
<span class="codeline" id="line-25"><code>func os_sigpipe() {</code></span>
<span class="codeline" id="line-26"><code>	systemstack(sigpipe)</code></span>
<span class="codeline" id="line-27"><code>}</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>func signame(sig uint32) string {</code></span>
<span class="codeline" id="line-30"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-31"><code>		return ""</code></span>
<span class="codeline" id="line-32"><code>	}</code></span>
<span class="codeline" id="line-33"><code>	return sigtable[sig].name</code></span>
<span class="codeline" id="line-34"><code>}</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>const (</code></span>
<span class="codeline" id="line-37"><code>	_SIG_DFL uintptr = 0</code></span>
<span class="codeline" id="line-38"><code>	_SIG_IGN uintptr = 1</code></span>
<span class="codeline" id="line-39"><code>)</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>// sigPreempt is the signal used for non-cooperative preemption.</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>// There's no good way to choose this signal, but there are some</code></span>
<span class="codeline" id="line-44"><code>// heuristics:</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>// 1. It should be a signal that's passed-through by debuggers by</code></span>
<span class="codeline" id="line-47"><code>// default. On Linux, this is SIGALRM, SIGURG, SIGCHLD, SIGIO,</code></span>
<span class="codeline" id="line-48"><code>// SIGVTALRM, SIGPROF, and SIGWINCH, plus some glibc-internal signals.</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>// 2. It shouldn't be used internally by libc in mixed Go/C binaries</code></span>
<span class="codeline" id="line-51"><code>// because libc may assume it's the only thing that can handle these</code></span>
<span class="codeline" id="line-52"><code>// signals. For example SIGCANCEL or SIGSETXID.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// 3. It should be a signal that can happen spuriously without</code></span>
<span class="codeline" id="line-55"><code>// consequences. For example, SIGALRM is a bad choice because the</code></span>
<span class="codeline" id="line-56"><code>// signal handler can't tell if it was caused by the real process</code></span>
<span class="codeline" id="line-57"><code>// alarm or not (arguably this means the signal is broken, but I</code></span>
<span class="codeline" id="line-58"><code>// digress). SIGUSR1 and SIGUSR2 are also bad because those are often</code></span>
<span class="codeline" id="line-59"><code>// used in meaningful ways by applications.</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// 4. We need to deal with platforms without real-time signals (like</code></span>
<span class="codeline" id="line-62"><code>// macOS), so those are out.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// We use SIGURG because it meets all of these criteria, is extremely</code></span>
<span class="codeline" id="line-65"><code>// unlikely to be used by an application for its "real" meaning (both</code></span>
<span class="codeline" id="line-66"><code>// because out-of-band data is basically unused and because SIGURG</code></span>
<span class="codeline" id="line-67"><code>// doesn't report which socket has the condition, making it pretty</code></span>
<span class="codeline" id="line-68"><code>// useless), and even if it is, the application has to be ready for</code></span>
<span class="codeline" id="line-69"><code>// spurious SIGURG. SIGIO wouldn't be a bad choice either, but is more</code></span>
<span class="codeline" id="line-70"><code>// likely to be used for real.</code></span>
<span class="codeline" id="line-71"><code>const sigPreempt = _SIGURG</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// Stores the signal handlers registered before Go installed its own.</code></span>
<span class="codeline" id="line-74"><code>// These signal handlers will be invoked in cases where Go doesn't want to</code></span>
<span class="codeline" id="line-75"><code>// handle a particular signal (e.g., signal occurred on a non-Go thread).</code></span>
<span class="codeline" id="line-76"><code>// See sigfwdgo for more information on when the signals are forwarded.</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>// This is read by the signal handler; accesses should use</code></span>
<span class="codeline" id="line-79"><code>// atomic.Loaduintptr and atomic.Storeuintptr.</code></span>
<span class="codeline" id="line-80"><code>var fwdSig [_NSIG]uintptr</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>// handlingSig is indexed by signal number and is non-zero if we are</code></span>
<span class="codeline" id="line-83"><code>// currently handling the signal. Or, to put it another way, whether</code></span>
<span class="codeline" id="line-84"><code>// the signal handler is currently set to the Go signal handler or not.</code></span>
<span class="codeline" id="line-85"><code>// This is uint32 rather than bool so that we can use atomic instructions.</code></span>
<span class="codeline" id="line-86"><code>var handlingSig [_NSIG]uint32</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>// channels for synchronizing signal mask updates with the signal mask</code></span>
<span class="codeline" id="line-89"><code>// thread</code></span>
<span class="codeline" id="line-90"><code>var (</code></span>
<span class="codeline" id="line-91"><code>	disableSigChan  chan uint32</code></span>
<span class="codeline" id="line-92"><code>	enableSigChan   chan uint32</code></span>
<span class="codeline" id="line-93"><code>	maskUpdatedChan chan struct{}</code></span>
<span class="codeline" id="line-94"><code>)</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>func init() {</code></span>
<span class="codeline" id="line-97"><code>	// _NSIG is the number of signals on this operating system.</code></span>
<span class="codeline" id="line-98"><code>	// sigtable should describe what to do for all the possible signals.</code></span>
<span class="codeline" id="line-99"><code>	if len(sigtable) != _NSIG {</code></span>
<span class="codeline" id="line-100"><code>		print("runtime: len(sigtable)=", len(sigtable), " _NSIG=", _NSIG, "\n")</code></span>
<span class="codeline" id="line-101"><code>		throw("bad sigtable len")</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code>}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>var signalsOK bool</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>// Initialize signals.</code></span>
<span class="codeline" id="line-108"><code>// Called by libpreinit so runtime may not be initialized.</code></span>
<span class="codeline" id="line-109"><code>//go:nosplit</code></span>
<span class="codeline" id="line-110"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-111"><code>func initsig(preinit bool) {</code></span>
<span class="codeline" id="line-112"><code>	if !preinit {</code></span>
<span class="codeline" id="line-113"><code>		// It's now OK for signal handlers to run.</code></span>
<span class="codeline" id="line-114"><code>		signalsOK = true</code></span>
<span class="codeline" id="line-115"><code>	}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// For c-archive/c-shared this is called by libpreinit with</code></span>
<span class="codeline" id="line-118"><code>	// preinit == true.</code></span>
<span class="codeline" id="line-119"><code>	if (isarchive || islibrary) &amp;&amp; !preinit {</code></span>
<span class="codeline" id="line-120"><code>		return</code></span>
<span class="codeline" id="line-121"><code>	}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>	for i := uint32(0); i &lt; _NSIG; i++ {</code></span>
<span class="codeline" id="line-124"><code>		t := &amp;sigtable[i]</code></span>
<span class="codeline" id="line-125"><code>		if t.flags == 0 || t.flags&amp;_SigDefault != 0 {</code></span>
<span class="codeline" id="line-126"><code>			continue</code></span>
<span class="codeline" id="line-127"><code>		}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>		// We don't need to use atomic operations here because</code></span>
<span class="codeline" id="line-130"><code>		// there shouldn't be any other goroutines running yet.</code></span>
<span class="codeline" id="line-131"><code>		fwdSig[i] = getsig(i)</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>		if !sigInstallGoHandler(i) {</code></span>
<span class="codeline" id="line-134"><code>			// Even if we are not installing a signal handler,</code></span>
<span class="codeline" id="line-135"><code>			// set SA_ONSTACK if necessary.</code></span>
<span class="codeline" id="line-136"><code>			if fwdSig[i] != _SIG_DFL &amp;&amp; fwdSig[i] != _SIG_IGN {</code></span>
<span class="codeline" id="line-137"><code>				setsigstack(i)</code></span>
<span class="codeline" id="line-138"><code>			} else if fwdSig[i] == _SIG_IGN {</code></span>
<span class="codeline" id="line-139"><code>				sigInitIgnored(i)</code></span>
<span class="codeline" id="line-140"><code>			}</code></span>
<span class="codeline" id="line-141"><code>			continue</code></span>
<span class="codeline" id="line-142"><code>		}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>		handlingSig[i] = 1</code></span>
<span class="codeline" id="line-145"><code>		setsig(i, funcPC(sighandler))</code></span>
<span class="codeline" id="line-146"><code>	}</code></span>
<span class="codeline" id="line-147"><code>}</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>//go:nosplit</code></span>
<span class="codeline" id="line-150"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-151"><code>func sigInstallGoHandler(sig uint32) bool {</code></span>
<span class="codeline" id="line-152"><code>	// For some signals, we respect an inherited SIG_IGN handler</code></span>
<span class="codeline" id="line-153"><code>	// rather than insist on installing our own default handler.</code></span>
<span class="codeline" id="line-154"><code>	// Even these signals can be fetched using the os/signal package.</code></span>
<span class="codeline" id="line-155"><code>	switch sig {</code></span>
<span class="codeline" id="line-156"><code>	case _SIGHUP, _SIGINT:</code></span>
<span class="codeline" id="line-157"><code>		if atomic.Loaduintptr(&amp;fwdSig[sig]) == _SIG_IGN {</code></span>
<span class="codeline" id="line-158"><code>			return false</code></span>
<span class="codeline" id="line-159"><code>		}</code></span>
<span class="codeline" id="line-160"><code>	}</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-163"><code>	if t.flags&amp;_SigSetStack != 0 {</code></span>
<span class="codeline" id="line-164"><code>		return false</code></span>
<span class="codeline" id="line-165"><code>	}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	// When built using c-archive or c-shared, only install signal</code></span>
<span class="codeline" id="line-168"><code>	// handlers for synchronous signals and SIGPIPE.</code></span>
<span class="codeline" id="line-169"><code>	if (isarchive || islibrary) &amp;&amp; t.flags&amp;_SigPanic == 0 &amp;&amp; sig != _SIGPIPE {</code></span>
<span class="codeline" id="line-170"><code>		return false</code></span>
<span class="codeline" id="line-171"><code>	}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>	return true</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// sigenable enables the Go signal handler to catch the signal sig.</code></span>
<span class="codeline" id="line-177"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-178"><code>// via os/signal.enableSignal and signal_enable.</code></span>
<span class="codeline" id="line-179"><code>func sigenable(sig uint32) {</code></span>
<span class="codeline" id="line-180"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-181"><code>		return</code></span>
<span class="codeline" id="line-182"><code>	}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-185"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-186"><code>		return</code></span>
<span class="codeline" id="line-187"><code>	}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-190"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-191"><code>		ensureSigM()</code></span>
<span class="codeline" id="line-192"><code>		enableSigChan &lt;- sig</code></span>
<span class="codeline" id="line-193"><code>		&lt;-maskUpdatedChan</code></span>
<span class="codeline" id="line-194"><code>		if atomic.Cas(&amp;handlingSig[sig], 0, 1) {</code></span>
<span class="codeline" id="line-195"><code>			atomic.Storeuintptr(&amp;fwdSig[sig], getsig(sig))</code></span>
<span class="codeline" id="line-196"><code>			setsig(sig, funcPC(sighandler))</code></span>
<span class="codeline" id="line-197"><code>		}</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code>}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>// sigdisable disables the Go signal handler for the signal sig.</code></span>
<span class="codeline" id="line-202"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-203"><code>// via os/signal.disableSignal and signal_disable.</code></span>
<span class="codeline" id="line-204"><code>func sigdisable(sig uint32) {</code></span>
<span class="codeline" id="line-205"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-206"><code>		return</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-210"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-211"><code>		return</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-215"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-216"><code>		ensureSigM()</code></span>
<span class="codeline" id="line-217"><code>		disableSigChan &lt;- sig</code></span>
<span class="codeline" id="line-218"><code>		&lt;-maskUpdatedChan</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>		// If initsig does not install a signal handler for a</code></span>
<span class="codeline" id="line-221"><code>		// signal, then to go back to the state before Notify</code></span>
<span class="codeline" id="line-222"><code>		// we should remove the one we installed.</code></span>
<span class="codeline" id="line-223"><code>		if !sigInstallGoHandler(sig) {</code></span>
<span class="codeline" id="line-224"><code>			atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-225"><code>			setsig(sig, atomic.Loaduintptr(&amp;fwdSig[sig]))</code></span>
<span class="codeline" id="line-226"><code>		}</code></span>
<span class="codeline" id="line-227"><code>	}</code></span>
<span class="codeline" id="line-228"><code>}</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>// sigignore ignores the signal sig.</code></span>
<span class="codeline" id="line-231"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-232"><code>// via os/signal.ignoreSignal and signal_ignore.</code></span>
<span class="codeline" id="line-233"><code>func sigignore(sig uint32) {</code></span>
<span class="codeline" id="line-234"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-235"><code>		return</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-239"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-240"><code>		return</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-244"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-245"><code>		atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-246"><code>		setsig(sig, _SIG_IGN)</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// clearSignalHandlers clears all signal handlers that are not ignored</code></span>
<span class="codeline" id="line-251"><code>// back to the default. This is called by the child after a fork, so that</code></span>
<span class="codeline" id="line-252"><code>// we can enable the signal mask for the exec without worrying about</code></span>
<span class="codeline" id="line-253"><code>// running a signal handler in the child.</code></span>
<span class="codeline" id="line-254"><code>//go:nosplit</code></span>
<span class="codeline" id="line-255"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-256"><code>func clearSignalHandlers() {</code></span>
<span class="codeline" id="line-257"><code>	for i := uint32(0); i &lt; _NSIG; i++ {</code></span>
<span class="codeline" id="line-258"><code>		if atomic.Load(&amp;handlingSig[i]) != 0 {</code></span>
<span class="codeline" id="line-259"><code>			setsig(i, _SIG_DFL)</code></span>
<span class="codeline" id="line-260"><code>		}</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>// setProcessCPUProfiler is called when the profiling timer changes.</code></span>
<span class="codeline" id="line-265"><code>// It is called with prof.lock held. hz is the new timer, and is 0 if</code></span>
<span class="codeline" id="line-266"><code>// profiling is being disabled. Enable or disable the signal as</code></span>
<span class="codeline" id="line-267"><code>// required for -buildmode=c-archive.</code></span>
<span class="codeline" id="line-268"><code>func setProcessCPUProfiler(hz int32) {</code></span>
<span class="codeline" id="line-269"><code>	if hz != 0 {</code></span>
<span class="codeline" id="line-270"><code>		// Enable the Go signal handler if not enabled.</code></span>
<span class="codeline" id="line-271"><code>		if atomic.Cas(&amp;handlingSig[_SIGPROF], 0, 1) {</code></span>
<span class="codeline" id="line-272"><code>			atomic.Storeuintptr(&amp;fwdSig[_SIGPROF], getsig(_SIGPROF))</code></span>
<span class="codeline" id="line-273"><code>			setsig(_SIGPROF, funcPC(sighandler))</code></span>
<span class="codeline" id="line-274"><code>		}</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>		var it itimerval</code></span>
<span class="codeline" id="line-277"><code>		it.it_interval.tv_sec = 0</code></span>
<span class="codeline" id="line-278"><code>		it.it_interval.set_usec(1000000 / hz)</code></span>
<span class="codeline" id="line-279"><code>		it.it_value = it.it_interval</code></span>
<span class="codeline" id="line-280"><code>		setitimer(_ITIMER_PROF, &amp;it, nil)</code></span>
<span class="codeline" id="line-281"><code>	} else {</code></span>
<span class="codeline" id="line-282"><code>		// If the Go signal handler should be disabled by default,</code></span>
<span class="codeline" id="line-283"><code>		// switch back to the signal handler that was installed</code></span>
<span class="codeline" id="line-284"><code>		// when we enabled profiling. We don't try to handle the case</code></span>
<span class="codeline" id="line-285"><code>		// of a program that changes the SIGPROF handler while Go</code></span>
<span class="codeline" id="line-286"><code>		// profiling is enabled.</code></span>
<span class="codeline" id="line-287"><code>		//</code></span>
<span class="codeline" id="line-288"><code>		// If no signal handler was installed before, then start</code></span>
<span class="codeline" id="line-289"><code>		// ignoring SIGPROF signals. We do this, rather than change</code></span>
<span class="codeline" id="line-290"><code>		// to SIG_DFL, because there may be a pending SIGPROF</code></span>
<span class="codeline" id="line-291"><code>		// signal that has not yet been delivered to some other thread.</code></span>
<span class="codeline" id="line-292"><code>		// If we change to SIG_DFL here, the program will crash</code></span>
<span class="codeline" id="line-293"><code>		// when that SIGPROF is delivered. We assume that programs</code></span>
<span class="codeline" id="line-294"><code>		// that use profiling don't want to crash on a stray SIGPROF.</code></span>
<span class="codeline" id="line-295"><code>		// See issue 19320.</code></span>
<span class="codeline" id="line-296"><code>		if !sigInstallGoHandler(_SIGPROF) {</code></span>
<span class="codeline" id="line-297"><code>			if atomic.Cas(&amp;handlingSig[_SIGPROF], 1, 0) {</code></span>
<span class="codeline" id="line-298"><code>				h := atomic.Loaduintptr(&amp;fwdSig[_SIGPROF])</code></span>
<span class="codeline" id="line-299"><code>				if h == _SIG_DFL {</code></span>
<span class="codeline" id="line-300"><code>					h = _SIG_IGN</code></span>
<span class="codeline" id="line-301"><code>				}</code></span>
<span class="codeline" id="line-302"><code>				setsig(_SIGPROF, h)</code></span>
<span class="codeline" id="line-303"><code>			}</code></span>
<span class="codeline" id="line-304"><code>		}</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>		setitimer(_ITIMER_PROF, &amp;itimerval{}, nil)</code></span>
<span class="codeline" id="line-307"><code>	}</code></span>
<span class="codeline" id="line-308"><code>}</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>// setThreadCPUProfiler makes any thread-specific changes required to</code></span>
<span class="codeline" id="line-311"><code>// implement profiling at a rate of hz.</code></span>
<span class="codeline" id="line-312"><code>// No changes required on Unix systems.</code></span>
<span class="codeline" id="line-313"><code>func setThreadCPUProfiler(hz int32) {</code></span>
<span class="codeline" id="line-314"><code>	getg().m.profilehz = hz</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>func sigpipe() {</code></span>
<span class="codeline" id="line-318"><code>	if signal_ignored(_SIGPIPE) || sigsend(_SIGPIPE) {</code></span>
<span class="codeline" id="line-319"><code>		return</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	dieFromSignal(_SIGPIPE)</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// doSigPreempt handles a preemption signal on gp.</code></span>
<span class="codeline" id="line-325"><code>func doSigPreempt(gp *g, ctxt *sigctxt) {</code></span>
<span class="codeline" id="line-326"><code>	// Check if this G wants to be preempted and is safe to</code></span>
<span class="codeline" id="line-327"><code>	// preempt.</code></span>
<span class="codeline" id="line-328"><code>	if wantAsyncPreempt(gp) {</code></span>
<span class="codeline" id="line-329"><code>		if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok {</code></span>
<span class="codeline" id="line-330"><code>			// Adjust the PC and inject a call to asyncPreempt.</code></span>
<span class="codeline" id="line-331"><code>			ctxt.pushCall(funcPC(asyncPreempt), newpc)</code></span>
<span class="codeline" id="line-332"><code>		}</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>	// Acknowledge the preemption.</code></span>
<span class="codeline" id="line-336"><code>	atomic.Xadd(&amp;gp.m.preemptGen, 1)</code></span>
<span class="codeline" id="line-337"><code>	atomic.Store(&amp;gp.m.signalPending, 0)</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-340"><code>		atomic.Xadd(&amp;pendingPreemptSignals, -1)</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code>}</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>const preemptMSupported = true</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>// preemptM sends a preemption request to mp. This request may be</code></span>
<span class="codeline" id="line-347"><code>// handled asynchronously and may be coalesced with other requests to</code></span>
<span class="codeline" id="line-348"><code>// the M. When the request is received, if the running G or P are</code></span>
<span class="codeline" id="line-349"><code>// marked for preemption and the goroutine is at an asynchronous</code></span>
<span class="codeline" id="line-350"><code>// safe-point, it will preempt the goroutine. It always atomically</code></span>
<span class="codeline" id="line-351"><code>// increments mp.preemptGen after handling a preemption request.</code></span>
<span class="codeline" id="line-352"><code>func preemptM(mp *m) {</code></span>
<span class="codeline" id="line-353"><code>	// On Darwin, don't try to preempt threads during exec.</code></span>
<span class="codeline" id="line-354"><code>	// Issue #41702.</code></span>
<span class="codeline" id="line-355"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-356"><code>		execLock.rlock()</code></span>
<span class="codeline" id="line-357"><code>	}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>	if atomic.Cas(&amp;mp.signalPending, 0, 1) {</code></span>
<span class="codeline" id="line-360"><code>		if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-361"><code>			atomic.Xadd(&amp;pendingPreemptSignals, 1)</code></span>
<span class="codeline" id="line-362"><code>		}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>		// If multiple threads are preempting the same M, it may send many</code></span>
<span class="codeline" id="line-365"><code>		// signals to the same M such that it hardly make progress, causing</code></span>
<span class="codeline" id="line-366"><code>		// live-lock problem. Apparently this could happen on darwin. See</code></span>
<span class="codeline" id="line-367"><code>		// issue #37741.</code></span>
<span class="codeline" id="line-368"><code>		// Only send a signal if there isn't already one pending.</code></span>
<span class="codeline" id="line-369"><code>		signalM(mp, sigPreempt)</code></span>
<span class="codeline" id="line-370"><code>	}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-373"><code>		execLock.runlock()</code></span>
<span class="codeline" id="line-374"><code>	}</code></span>
<span class="codeline" id="line-375"><code>}</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>// sigFetchG fetches the value of G safely when running in a signal handler.</code></span>
<span class="codeline" id="line-378"><code>// On some architectures, the g value may be clobbered when running in a VDSO.</code></span>
<span class="codeline" id="line-379"><code>// See issue #32912.</code></span>
<span class="codeline" id="line-380"><code>//</code></span>
<span class="codeline" id="line-381"><code>//go:nosplit</code></span>
<span class="codeline" id="line-382"><code>func sigFetchG(c *sigctxt) *g {</code></span>
<span class="codeline" id="line-383"><code>	switch GOARCH {</code></span>
<span class="codeline" id="line-384"><code>	case "arm", "arm64":</code></span>
<span class="codeline" id="line-385"><code>		if !iscgo &amp;&amp; inVDSOPage(c.sigpc()) {</code></span>
<span class="codeline" id="line-386"><code>			// When using cgo, we save the g on TLS and load it from there</code></span>
<span class="codeline" id="line-387"><code>			// in sigtramp. Just use that.</code></span>
<span class="codeline" id="line-388"><code>			// Otherwise, before making a VDSO call we save the g to the</code></span>
<span class="codeline" id="line-389"><code>			// bottom of the signal stack. Fetch from there.</code></span>
<span class="codeline" id="line-390"><code>			// TODO: in efence mode, stack is sysAlloc'd, so this wouldn't</code></span>
<span class="codeline" id="line-391"><code>			// work.</code></span>
<span class="codeline" id="line-392"><code>			sp := getcallersp()</code></span>
<span class="codeline" id="line-393"><code>			s := spanOf(sp)</code></span>
<span class="codeline" id="line-394"><code>			if s != nil &amp;&amp; s.state.get() == mSpanManual &amp;&amp; s.base() &lt; sp &amp;&amp; sp &lt; s.limit {</code></span>
<span class="codeline" id="line-395"><code>				gp := *(**g)(unsafe.Pointer(s.base()))</code></span>
<span class="codeline" id="line-396"><code>				return gp</code></span>
<span class="codeline" id="line-397"><code>			}</code></span>
<span class="codeline" id="line-398"><code>			return nil</code></span>
<span class="codeline" id="line-399"><code>		}</code></span>
<span class="codeline" id="line-400"><code>	}</code></span>
<span class="codeline" id="line-401"><code>	return getg()</code></span>
<span class="codeline" id="line-402"><code>}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>// sigtrampgo is called from the signal handler function, sigtramp,</code></span>
<span class="codeline" id="line-405"><code>// written in assembly code.</code></span>
<span class="codeline" id="line-406"><code>// This is called by the signal handler, and the world may be stopped.</code></span>
<span class="codeline" id="line-407"><code>//</code></span>
<span class="codeline" id="line-408"><code>// It must be nosplit because getg() is still the G that was running</code></span>
<span class="codeline" id="line-409"><code>// (if any) when the signal was delivered, but it's (usually) called</code></span>
<span class="codeline" id="line-410"><code>// on the gsignal stack. Until this switches the G to gsignal, the</code></span>
<span class="codeline" id="line-411"><code>// stack bounds check won't work.</code></span>
<span class="codeline" id="line-412"><code>//</code></span>
<span class="codeline" id="line-413"><code>//go:nosplit</code></span>
<span class="codeline" id="line-414"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-415"><code>func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {</code></span>
<span class="codeline" id="line-416"><code>	if sigfwdgo(sig, info, ctx) {</code></span>
<span class="codeline" id="line-417"><code>		return</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code>	c := &amp;sigctxt{info, ctx}</code></span>
<span class="codeline" id="line-420"><code>	g := sigFetchG(c)</code></span>
<span class="codeline" id="line-421"><code>	setg(g)</code></span>
<span class="codeline" id="line-422"><code>	if g == nil {</code></span>
<span class="codeline" id="line-423"><code>		if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-424"><code>			sigprofNonGoPC(c.sigpc())</code></span>
<span class="codeline" id="line-425"><code>			return</code></span>
<span class="codeline" id="line-426"><code>		}</code></span>
<span class="codeline" id="line-427"><code>		if sig == sigPreempt &amp;&amp; preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-428"><code>			// This is probably a signal from preemptM sent</code></span>
<span class="codeline" id="line-429"><code>			// while executing Go code but received while</code></span>
<span class="codeline" id="line-430"><code>			// executing non-Go code.</code></span>
<span class="codeline" id="line-431"><code>			// We got past sigfwdgo, so we know that there is</code></span>
<span class="codeline" id="line-432"><code>			// no non-Go signal handler for sigPreempt.</code></span>
<span class="codeline" id="line-433"><code>			// The default behavior for sigPreempt is to ignore</code></span>
<span class="codeline" id="line-434"><code>			// the signal, so badsignal will be a no-op anyway.</code></span>
<span class="codeline" id="line-435"><code>			if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-436"><code>				atomic.Xadd(&amp;pendingPreemptSignals, -1)</code></span>
<span class="codeline" id="line-437"><code>			}</code></span>
<span class="codeline" id="line-438"><code>			return</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>		c.fixsigcode(sig)</code></span>
<span class="codeline" id="line-441"><code>		badsignal(uintptr(sig), c)</code></span>
<span class="codeline" id="line-442"><code>		return</code></span>
<span class="codeline" id="line-443"><code>	}</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>	setg(g.m.gsignal)</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	// If some non-Go code called sigaltstack, adjust.</code></span>
<span class="codeline" id="line-448"><code>	var gsignalStack gsignalStack</code></span>
<span class="codeline" id="line-449"><code>	setStack := adjustSignalStack(sig, g.m, &amp;gsignalStack)</code></span>
<span class="codeline" id="line-450"><code>	if setStack {</code></span>
<span class="codeline" id="line-451"><code>		g.m.gsignal.stktopsp = getcallersp()</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>	if g.stackguard0 == stackFork {</code></span>
<span class="codeline" id="line-455"><code>		signalDuringFork(sig)</code></span>
<span class="codeline" id="line-456"><code>	}</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>	c.fixsigcode(sig)</code></span>
<span class="codeline" id="line-459"><code>	sighandler(sig, info, ctx, g)</code></span>
<span class="codeline" id="line-460"><code>	setg(g)</code></span>
<span class="codeline" id="line-461"><code>	if setStack {</code></span>
<span class="codeline" id="line-462"><code>		restoreGsignalStack(&amp;gsignalStack)</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code>}</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>// adjustSignalStack adjusts the current stack guard based on the</code></span>
<span class="codeline" id="line-467"><code>// stack pointer that is actually in use while handling a signal.</code></span>
<span class="codeline" id="line-468"><code>// We do this in case some non-Go code called sigaltstack.</code></span>
<span class="codeline" id="line-469"><code>// This reports whether the stack was adjusted, and if so stores the old</code></span>
<span class="codeline" id="line-470"><code>// signal stack in *gsigstack.</code></span>
<span class="codeline" id="line-471"><code>//go:nosplit</code></span>
<span class="codeline" id="line-472"><code>func adjustSignalStack(sig uint32, mp *m, gsigStack *gsignalStack) bool {</code></span>
<span class="codeline" id="line-473"><code>	sp := uintptr(unsafe.Pointer(&amp;sig))</code></span>
<span class="codeline" id="line-474"><code>	if sp &gt;= mp.gsignal.stack.lo &amp;&amp; sp &lt; mp.gsignal.stack.hi {</code></span>
<span class="codeline" id="line-475"><code>		return false</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>	var st stackt</code></span>
<span class="codeline" id="line-479"><code>	sigaltstack(nil, &amp;st)</code></span>
<span class="codeline" id="line-480"><code>	stsp := uintptr(unsafe.Pointer(st.ss_sp))</code></span>
<span class="codeline" id="line-481"><code>	if st.ss_flags&amp;_SS_DISABLE == 0 &amp;&amp; sp &gt;= stsp &amp;&amp; sp &lt; stsp+st.ss_size {</code></span>
<span class="codeline" id="line-482"><code>		setGsignalStack(&amp;st, gsigStack)</code></span>
<span class="codeline" id="line-483"><code>		return true</code></span>
<span class="codeline" id="line-484"><code>	}</code></span>
<span class="codeline" id="line-485"><code></code></span>
<span class="codeline" id="line-486"><code>	if sp &gt;= mp.g0.stack.lo &amp;&amp; sp &lt; mp.g0.stack.hi {</code></span>
<span class="codeline" id="line-487"><code>		// The signal was delivered on the g0 stack.</code></span>
<span class="codeline" id="line-488"><code>		// This can happen when linked with C code</code></span>
<span class="codeline" id="line-489"><code>		// using the thread sanitizer, which collects</code></span>
<span class="codeline" id="line-490"><code>		// signals then delivers them itself by calling</code></span>
<span class="codeline" id="line-491"><code>		// the signal handler directly when C code,</code></span>
<span class="codeline" id="line-492"><code>		// including C code called via cgo, calls a</code></span>
<span class="codeline" id="line-493"><code>		// TSAN-intercepted function such as malloc.</code></span>
<span class="codeline" id="line-494"><code>		//</code></span>
<span class="codeline" id="line-495"><code>		// We check this condition last as g0.stack.lo</code></span>
<span class="codeline" id="line-496"><code>		// may be not very accurate (see mstart).</code></span>
<span class="codeline" id="line-497"><code>		st := stackt{ss_size: mp.g0.stack.hi - mp.g0.stack.lo}</code></span>
<span class="codeline" id="line-498"><code>		setSignalstackSP(&amp;st, mp.g0.stack.lo)</code></span>
<span class="codeline" id="line-499"><code>		setGsignalStack(&amp;st, gsigStack)</code></span>
<span class="codeline" id="line-500"><code>		return true</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>	// sp is not within gsignal stack, g0 stack, or sigaltstack. Bad.</code></span>
<span class="codeline" id="line-504"><code>	setg(nil)</code></span>
<span class="codeline" id="line-505"><code>	needm()</code></span>
<span class="codeline" id="line-506"><code>	if st.ss_flags&amp;_SS_DISABLE != 0 {</code></span>
<span class="codeline" id="line-507"><code>		noSignalStack(sig)</code></span>
<span class="codeline" id="line-508"><code>	} else {</code></span>
<span class="codeline" id="line-509"><code>		sigNotOnStack(sig)</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code>	dropm()</code></span>
<span class="codeline" id="line-512"><code>	return false</code></span>
<span class="codeline" id="line-513"><code>}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>// crashing is the number of m's we have waited for when implementing</code></span>
<span class="codeline" id="line-516"><code>// GOTRACEBACK=crash when a signal is received.</code></span>
<span class="codeline" id="line-517"><code>var crashing int32</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>// testSigtrap and testSigusr1 are used by the runtime tests. If</code></span>
<span class="codeline" id="line-520"><code>// non-nil, it is called on SIGTRAP/SIGUSR1. If it returns true, the</code></span>
<span class="codeline" id="line-521"><code>// normal behavior on this signal is suppressed.</code></span>
<span class="codeline" id="line-522"><code>var testSigtrap func(info *siginfo, ctxt *sigctxt, gp *g) bool</code></span>
<span class="codeline" id="line-523"><code>var testSigusr1 func(gp *g) bool</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>// sighandler is invoked when a signal occurs. The global g will be</code></span>
<span class="codeline" id="line-526"><code>// set to a gsignal goroutine and we will be running on the alternate</code></span>
<span class="codeline" id="line-527"><code>// signal stack. The parameter g will be the value of the global g</code></span>
<span class="codeline" id="line-528"><code>// when the signal occurred. The sig, info, and ctxt parameters are</code></span>
<span class="codeline" id="line-529"><code>// from the system signal handler: they are the parameters passed when</code></span>
<span class="codeline" id="line-530"><code>// the SA is passed to the sigaction system call.</code></span>
<span class="codeline" id="line-531"><code>//</code></span>
<span class="codeline" id="line-532"><code>// The garbage collector may have stopped the world, so write barriers</code></span>
<span class="codeline" id="line-533"><code>// are not allowed.</code></span>
<span class="codeline" id="line-534"><code>//</code></span>
<span class="codeline" id="line-535"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-536"><code>func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {</code></span>
<span class="codeline" id="line-537"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-538"><code>	c := &amp;sigctxt{info, ctxt}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-541"><code>		sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m)</code></span>
<span class="codeline" id="line-542"><code>		return</code></span>
<span class="codeline" id="line-543"><code>	}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>	if sig == _SIGTRAP &amp;&amp; testSigtrap != nil &amp;&amp; testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) {</code></span>
<span class="codeline" id="line-546"><code>		return</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>	if sig == _SIGUSR1 &amp;&amp; testSigusr1 != nil &amp;&amp; testSigusr1(gp) {</code></span>
<span class="codeline" id="line-550"><code>		return</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>	if sig == sigPreempt &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-554"><code>		// Might be a preemption signal.</code></span>
<span class="codeline" id="line-555"><code>		doSigPreempt(gp, c)</code></span>
<span class="codeline" id="line-556"><code>		// Even if this was definitely a preemption signal, it</code></span>
<span class="codeline" id="line-557"><code>		// may have been coalesced with another signal, so we</code></span>
<span class="codeline" id="line-558"><code>		// still let it through to the application.</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code></code></span>
<span class="codeline" id="line-561"><code>	flags := int32(_SigThrow)</code></span>
<span class="codeline" id="line-562"><code>	if sig &lt; uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-563"><code>		flags = sigtable[sig].flags</code></span>
<span class="codeline" id="line-564"><code>	}</code></span>
<span class="codeline" id="line-565"><code>	if c.sigcode() != _SI_USER &amp;&amp; flags&amp;_SigPanic != 0 &amp;&amp; gp.throwsplit {</code></span>
<span class="codeline" id="line-566"><code>		// We can't safely sigpanic because it may grow the</code></span>
<span class="codeline" id="line-567"><code>		// stack. Abort in the signal handler instead.</code></span>
<span class="codeline" id="line-568"><code>		flags = _SigThrow</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>	if isAbortPC(c.sigpc()) {</code></span>
<span class="codeline" id="line-571"><code>		// On many architectures, the abort function just</code></span>
<span class="codeline" id="line-572"><code>		// causes a memory fault. Don't turn that into a panic.</code></span>
<span class="codeline" id="line-573"><code>		flags = _SigThrow</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	if c.sigcode() != _SI_USER &amp;&amp; flags&amp;_SigPanic != 0 {</code></span>
<span class="codeline" id="line-576"><code>		// The signal is going to cause a panic.</code></span>
<span class="codeline" id="line-577"><code>		// Arrange the stack so that it looks like the point</code></span>
<span class="codeline" id="line-578"><code>		// where the signal occurred made a call to the</code></span>
<span class="codeline" id="line-579"><code>		// function sigpanic. Then set the PC to sigpanic.</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>		// Have to pass arguments out of band since</code></span>
<span class="codeline" id="line-582"><code>		// augmenting the stack frame would break</code></span>
<span class="codeline" id="line-583"><code>		// the unwinding code.</code></span>
<span class="codeline" id="line-584"><code>		gp.sig = sig</code></span>
<span class="codeline" id="line-585"><code>		gp.sigcode0 = uintptr(c.sigcode())</code></span>
<span class="codeline" id="line-586"><code>		gp.sigcode1 = uintptr(c.fault())</code></span>
<span class="codeline" id="line-587"><code>		gp.sigpc = c.sigpc()</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>		c.preparePanic(sig, gp)</code></span>
<span class="codeline" id="line-590"><code>		return</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code></code></span>
<span class="codeline" id="line-593"><code>	if c.sigcode() == _SI_USER || flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-594"><code>		if sigsend(sig) {</code></span>
<span class="codeline" id="line-595"><code>			return</code></span>
<span class="codeline" id="line-596"><code>		}</code></span>
<span class="codeline" id="line-597"><code>	}</code></span>
<span class="codeline" id="line-598"><code></code></span>
<span class="codeline" id="line-599"><code>	if c.sigcode() == _SI_USER &amp;&amp; signal_ignored(sig) {</code></span>
<span class="codeline" id="line-600"><code>		return</code></span>
<span class="codeline" id="line-601"><code>	}</code></span>
<span class="codeline" id="line-602"><code></code></span>
<span class="codeline" id="line-603"><code>	if flags&amp;_SigKill != 0 {</code></span>
<span class="codeline" id="line-604"><code>		dieFromSignal(sig)</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	// _SigThrow means that we should exit now.</code></span>
<span class="codeline" id="line-608"><code>	// If we get here with _SigPanic, it means that the signal</code></span>
<span class="codeline" id="line-609"><code>	// was sent to us by a program (c.sigcode() == _SI_USER);</code></span>
<span class="codeline" id="line-610"><code>	// in that case, if we didn't handle it in sigsend, we exit now.</code></span>
<span class="codeline" id="line-611"><code>	if flags&amp;(_SigThrow|_SigPanic) == 0 {</code></span>
<span class="codeline" id="line-612"><code>		return</code></span>
<span class="codeline" id="line-613"><code>	}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>	_g_.m.throwing = 1</code></span>
<span class="codeline" id="line-616"><code>	_g_.m.caughtsig.set(gp)</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>	if crashing == 0 {</code></span>
<span class="codeline" id="line-619"><code>		startpanic_m()</code></span>
<span class="codeline" id="line-620"><code>	}</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>	if sig &lt; uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-623"><code>		print(sigtable[sig].name, "\n")</code></span>
<span class="codeline" id="line-624"><code>	} else {</code></span>
<span class="codeline" id="line-625"><code>		print("Signal ", sig, "\n")</code></span>
<span class="codeline" id="line-626"><code>	}</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")</code></span>
<span class="codeline" id="line-629"><code>	if _g_.m.lockedg != 0 &amp;&amp; _g_.m.ncgo &gt; 0 &amp;&amp; gp == _g_.m.g0 {</code></span>
<span class="codeline" id="line-630"><code>		print("signal arrived during cgo execution\n")</code></span>
<span class="codeline" id="line-631"><code>		gp = _g_.m.lockedg.ptr()</code></span>
<span class="codeline" id="line-632"><code>	}</code></span>
<span class="codeline" id="line-633"><code>	if sig == _SIGILL || sig == _SIGFPE {</code></span>
<span class="codeline" id="line-634"><code>		// It would be nice to know how long the instruction is.</code></span>
<span class="codeline" id="line-635"><code>		// Unfortunately, that's complicated to do in general (mostly for x86</code></span>
<span class="codeline" id="line-636"><code>		// and s930x, but other archs have non-standard instruction lengths also).</code></span>
<span class="codeline" id="line-637"><code>		// Opt to print 16 bytes, which covers most instructions.</code></span>
<span class="codeline" id="line-638"><code>		const maxN = 16</code></span>
<span class="codeline" id="line-639"><code>		n := uintptr(maxN)</code></span>
<span class="codeline" id="line-640"><code>		// We have to be careful, though. If we're near the end of</code></span>
<span class="codeline" id="line-641"><code>		// a page and the following page isn't mapped, we could</code></span>
<span class="codeline" id="line-642"><code>		// segfault. So make sure we don't straddle a page (even though</code></span>
<span class="codeline" id="line-643"><code>		// that could lead to printing an incomplete instruction).</code></span>
<span class="codeline" id="line-644"><code>		// We're assuming here we can read at least the page containing the PC.</code></span>
<span class="codeline" id="line-645"><code>		// I suppose it is possible that the page is mapped executable but not readable?</code></span>
<span class="codeline" id="line-646"><code>		pc := c.sigpc()</code></span>
<span class="codeline" id="line-647"><code>		if n &gt; physPageSize-pc%physPageSize {</code></span>
<span class="codeline" id="line-648"><code>			n = physPageSize - pc%physPageSize</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>		print("instruction bytes:")</code></span>
<span class="codeline" id="line-651"><code>		b := (*[maxN]byte)(unsafe.Pointer(pc))</code></span>
<span class="codeline" id="line-652"><code>		for i := uintptr(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-653"><code>			print(" ", hex(b[i]))</code></span>
<span class="codeline" id="line-654"><code>		}</code></span>
<span class="codeline" id="line-655"><code>		println()</code></span>
<span class="codeline" id="line-656"><code>	}</code></span>
<span class="codeline" id="line-657"><code>	print("\n")</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>	level, _, docrash := gotraceback()</code></span>
<span class="codeline" id="line-660"><code>	if level &gt; 0 {</code></span>
<span class="codeline" id="line-661"><code>		goroutineheader(gp)</code></span>
<span class="codeline" id="line-662"><code>		tracebacktrap(c.sigpc(), c.sigsp(), c.siglr(), gp)</code></span>
<span class="codeline" id="line-663"><code>		if crashing &gt; 0 &amp;&amp; gp != _g_.m.curg &amp;&amp; _g_.m.curg != nil &amp;&amp; readgstatus(_g_.m.curg)&amp;^_Gscan == _Grunning {</code></span>
<span class="codeline" id="line-664"><code>			// tracebackothers on original m skipped this one; trace it now.</code></span>
<span class="codeline" id="line-665"><code>			goroutineheader(_g_.m.curg)</code></span>
<span class="codeline" id="line-666"><code>			traceback(^uintptr(0), ^uintptr(0), 0, _g_.m.curg)</code></span>
<span class="codeline" id="line-667"><code>		} else if crashing == 0 {</code></span>
<span class="codeline" id="line-668"><code>			tracebackothers(gp)</code></span>
<span class="codeline" id="line-669"><code>			print("\n")</code></span>
<span class="codeline" id="line-670"><code>		}</code></span>
<span class="codeline" id="line-671"><code>		dumpregs(c)</code></span>
<span class="codeline" id="line-672"><code>	}</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	if docrash {</code></span>
<span class="codeline" id="line-675"><code>		crashing++</code></span>
<span class="codeline" id="line-676"><code>		if crashing &lt; mcount()-int32(extraMCount) {</code></span>
<span class="codeline" id="line-677"><code>			// There are other m's that need to dump their stacks.</code></span>
<span class="codeline" id="line-678"><code>			// Relay SIGQUIT to the next m by sending it to the current process.</code></span>
<span class="codeline" id="line-679"><code>			// All m's that have already received SIGQUIT have signal masks blocking</code></span>
<span class="codeline" id="line-680"><code>			// receipt of any signals, so the SIGQUIT will go to an m that hasn't seen it yet.</code></span>
<span class="codeline" id="line-681"><code>			// When the last m receives the SIGQUIT, it will fall through to the call to</code></span>
<span class="codeline" id="line-682"><code>			// crash below. Just in case the relaying gets botched, each m involved in</code></span>
<span class="codeline" id="line-683"><code>			// the relay sleeps for 5 seconds and then does the crash/exit itself.</code></span>
<span class="codeline" id="line-684"><code>			// In expected operation, the last m has received the SIGQUIT and run</code></span>
<span class="codeline" id="line-685"><code>			// crash/exit and the process is gone, all long before any of the</code></span>
<span class="codeline" id="line-686"><code>			// 5-second sleeps have finished.</code></span>
<span class="codeline" id="line-687"><code>			print("\n-----\n\n")</code></span>
<span class="codeline" id="line-688"><code>			raiseproc(_SIGQUIT)</code></span>
<span class="codeline" id="line-689"><code>			usleep(5 * 1000 * 1000)</code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>		crash()</code></span>
<span class="codeline" id="line-692"><code>	}</code></span>
<span class="codeline" id="line-693"><code></code></span>
<span class="codeline" id="line-694"><code>	printDebugLog()</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>	exit(2)</code></span>
<span class="codeline" id="line-697"><code>}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// sigpanic turns a synchronous signal into a run-time panic.</code></span>
<span class="codeline" id="line-700"><code>// If the signal handler sees a synchronous panic, it arranges the</code></span>
<span class="codeline" id="line-701"><code>// stack to look like the function where the signal occurred called</code></span>
<span class="codeline" id="line-702"><code>// sigpanic, sets the signal's PC value to sigpanic, and returns from</code></span>
<span class="codeline" id="line-703"><code>// the signal handler. The effect is that the program will act as</code></span>
<span class="codeline" id="line-704"><code>// though the function that got the signal simply called sigpanic</code></span>
<span class="codeline" id="line-705"><code>// instead.</code></span>
<span class="codeline" id="line-706"><code>//</code></span>
<span class="codeline" id="line-707"><code>// This must NOT be nosplit because the linker doesn't know where</code></span>
<span class="codeline" id="line-708"><code>// sigpanic calls can be injected.</code></span>
<span class="codeline" id="line-709"><code>//</code></span>
<span class="codeline" id="line-710"><code>// The signal handler must not inject a call to sigpanic if</code></span>
<span class="codeline" id="line-711"><code>// getg().throwsplit, since sigpanic may need to grow the stack.</code></span>
<span class="codeline" id="line-712"><code>//</code></span>
<span class="codeline" id="line-713"><code>// This is exported via linkname to assembly in runtime/cgo.</code></span>
<span class="codeline" id="line-714"><code>//go:linkname sigpanic</code></span>
<span class="codeline" id="line-715"><code>func sigpanic() {</code></span>
<span class="codeline" id="line-716"><code>	g := getg()</code></span>
<span class="codeline" id="line-717"><code>	if !canpanic(g) {</code></span>
<span class="codeline" id="line-718"><code>		throw("unexpected signal during runtime execution")</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>	switch g.sig {</code></span>
<span class="codeline" id="line-722"><code>	case _SIGBUS:</code></span>
<span class="codeline" id="line-723"><code>		if g.sigcode0 == _BUS_ADRERR &amp;&amp; g.sigcode1 &lt; 0x1000 {</code></span>
<span class="codeline" id="line-724"><code>			panicmem()</code></span>
<span class="codeline" id="line-725"><code>		}</code></span>
<span class="codeline" id="line-726"><code>		// Support runtime/debug.SetPanicOnFault.</code></span>
<span class="codeline" id="line-727"><code>		if g.paniconfault {</code></span>
<span class="codeline" id="line-728"><code>			panicmemAddr(g.sigcode1)</code></span>
<span class="codeline" id="line-729"><code>		}</code></span>
<span class="codeline" id="line-730"><code>		print("unexpected fault address ", hex(g.sigcode1), "\n")</code></span>
<span class="codeline" id="line-731"><code>		throw("fault")</code></span>
<span class="codeline" id="line-732"><code>	case _SIGSEGV:</code></span>
<span class="codeline" id="line-733"><code>		if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) &amp;&amp; g.sigcode1 &lt; 0x1000 {</code></span>
<span class="codeline" id="line-734"><code>			panicmem()</code></span>
<span class="codeline" id="line-735"><code>		}</code></span>
<span class="codeline" id="line-736"><code>		// Support runtime/debug.SetPanicOnFault.</code></span>
<span class="codeline" id="line-737"><code>		if g.paniconfault {</code></span>
<span class="codeline" id="line-738"><code>			panicmemAddr(g.sigcode1)</code></span>
<span class="codeline" id="line-739"><code>		}</code></span>
<span class="codeline" id="line-740"><code>		print("unexpected fault address ", hex(g.sigcode1), "\n")</code></span>
<span class="codeline" id="line-741"><code>		throw("fault")</code></span>
<span class="codeline" id="line-742"><code>	case _SIGFPE:</code></span>
<span class="codeline" id="line-743"><code>		switch g.sigcode0 {</code></span>
<span class="codeline" id="line-744"><code>		case _FPE_INTDIV:</code></span>
<span class="codeline" id="line-745"><code>			panicdivide()</code></span>
<span class="codeline" id="line-746"><code>		case _FPE_INTOVF:</code></span>
<span class="codeline" id="line-747"><code>			panicoverflow()</code></span>
<span class="codeline" id="line-748"><code>		}</code></span>
<span class="codeline" id="line-749"><code>		panicfloat()</code></span>
<span class="codeline" id="line-750"><code>	}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>	if g.sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-753"><code>		// can't happen: we looked up g.sig in sigtable to decide to call sigpanic</code></span>
<span class="codeline" id="line-754"><code>		throw("unexpected signal value")</code></span>
<span class="codeline" id="line-755"><code>	}</code></span>
<span class="codeline" id="line-756"><code>	panic(errorString(sigtable[g.sig].name))</code></span>
<span class="codeline" id="line-757"><code>}</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>// dieFromSignal kills the program with a signal.</code></span>
<span class="codeline" id="line-760"><code>// This provides the expected exit status for the shell.</code></span>
<span class="codeline" id="line-761"><code>// This is only called with fatal signals expected to kill the process.</code></span>
<span class="codeline" id="line-762"><code>//go:nosplit</code></span>
<span class="codeline" id="line-763"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-764"><code>func dieFromSignal(sig uint32) {</code></span>
<span class="codeline" id="line-765"><code>	unblocksig(sig)</code></span>
<span class="codeline" id="line-766"><code>	// Mark the signal as unhandled to ensure it is forwarded.</code></span>
<span class="codeline" id="line-767"><code>	atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-768"><code>	raise(sig)</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	// That should have killed us. On some systems, though, raise</code></span>
<span class="codeline" id="line-771"><code>	// sends the signal to the whole process rather than to just</code></span>
<span class="codeline" id="line-772"><code>	// the current thread, which means that the signal may not yet</code></span>
<span class="codeline" id="line-773"><code>	// have been delivered. Give other threads a chance to run and</code></span>
<span class="codeline" id="line-774"><code>	// pick up the signal.</code></span>
<span class="codeline" id="line-775"><code>	osyield()</code></span>
<span class="codeline" id="line-776"><code>	osyield()</code></span>
<span class="codeline" id="line-777"><code>	osyield()</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>	// If that didn't work, try _SIG_DFL.</code></span>
<span class="codeline" id="line-780"><code>	setsig(sig, _SIG_DFL)</code></span>
<span class="codeline" id="line-781"><code>	raise(sig)</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>	osyield()</code></span>
<span class="codeline" id="line-784"><code>	osyield()</code></span>
<span class="codeline" id="line-785"><code>	osyield()</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>	// If we are still somehow running, just exit with the wrong status.</code></span>
<span class="codeline" id="line-788"><code>	exit(2)</code></span>
<span class="codeline" id="line-789"><code>}</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>// raisebadsignal is called when a signal is received on a non-Go</code></span>
<span class="codeline" id="line-792"><code>// thread, and the Go program does not want to handle it (that is, the</code></span>
<span class="codeline" id="line-793"><code>// program has not called os/signal.Notify for the signal).</code></span>
<span class="codeline" id="line-794"><code>func raisebadsignal(sig uint32, c *sigctxt) {</code></span>
<span class="codeline" id="line-795"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-796"><code>		// Ignore profiling signals that arrive on non-Go threads.</code></span>
<span class="codeline" id="line-797"><code>		return</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code></code></span>
<span class="codeline" id="line-800"><code>	var handler uintptr</code></span>
<span class="codeline" id="line-801"><code>	if sig &gt;= _NSIG {</code></span>
<span class="codeline" id="line-802"><code>		handler = _SIG_DFL</code></span>
<span class="codeline" id="line-803"><code>	} else {</code></span>
<span class="codeline" id="line-804"><code>		handler = atomic.Loaduintptr(&amp;fwdSig[sig])</code></span>
<span class="codeline" id="line-805"><code>	}</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>	// Reset the signal handler and raise the signal.</code></span>
<span class="codeline" id="line-808"><code>	// We are currently running inside a signal handler, so the</code></span>
<span class="codeline" id="line-809"><code>	// signal is blocked. We need to unblock it before raising the</code></span>
<span class="codeline" id="line-810"><code>	// signal, or the signal we raise will be ignored until we return</code></span>
<span class="codeline" id="line-811"><code>	// from the signal handler. We know that the signal was unblocked</code></span>
<span class="codeline" id="line-812"><code>	// before entering the handler, or else we would not have received</code></span>
<span class="codeline" id="line-813"><code>	// it. That means that we don't have to worry about blocking it</code></span>
<span class="codeline" id="line-814"><code>	// again.</code></span>
<span class="codeline" id="line-815"><code>	unblocksig(sig)</code></span>
<span class="codeline" id="line-816"><code>	setsig(sig, handler)</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>	// If we're linked into a non-Go program we want to try to</code></span>
<span class="codeline" id="line-819"><code>	// avoid modifying the original context in which the signal</code></span>
<span class="codeline" id="line-820"><code>	// was raised. If the handler is the default, we know it</code></span>
<span class="codeline" id="line-821"><code>	// is non-recoverable, so we don't have to worry about</code></span>
<span class="codeline" id="line-822"><code>	// re-installing sighandler. At this point we can just</code></span>
<span class="codeline" id="line-823"><code>	// return and the signal will be re-raised and caught by</code></span>
<span class="codeline" id="line-824"><code>	// the default handler with the correct context.</code></span>
<span class="codeline" id="line-825"><code>	//</code></span>
<span class="codeline" id="line-826"><code>	// On FreeBSD, the libthr sigaction code prevents</code></span>
<span class="codeline" id="line-827"><code>	// this from working so we fall through to raise.</code></span>
<span class="codeline" id="line-828"><code>	if GOOS != "freebsd" &amp;&amp; (isarchive || islibrary) &amp;&amp; handler == _SIG_DFL &amp;&amp; c.sigcode() != _SI_USER {</code></span>
<span class="codeline" id="line-829"><code>		return</code></span>
<span class="codeline" id="line-830"><code>	}</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>	raise(sig)</code></span>
<span class="codeline" id="line-833"><code></code></span>
<span class="codeline" id="line-834"><code>	// Give the signal a chance to be delivered.</code></span>
<span class="codeline" id="line-835"><code>	// In almost all real cases the program is about to crash,</code></span>
<span class="codeline" id="line-836"><code>	// so sleeping here is not a waste of time.</code></span>
<span class="codeline" id="line-837"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-838"><code></code></span>
<span class="codeline" id="line-839"><code>	// If the signal didn't cause the program to exit, restore the</code></span>
<span class="codeline" id="line-840"><code>	// Go signal handler and carry on.</code></span>
<span class="codeline" id="line-841"><code>	//</code></span>
<span class="codeline" id="line-842"><code>	// We may receive another instance of the signal before we</code></span>
<span class="codeline" id="line-843"><code>	// restore the Go handler, but that is not so bad: we know</code></span>
<span class="codeline" id="line-844"><code>	// that the Go program has been ignoring the signal.</code></span>
<span class="codeline" id="line-845"><code>	setsig(sig, funcPC(sighandler))</code></span>
<span class="codeline" id="line-846"><code>}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>//go:nosplit</code></span>
<span class="codeline" id="line-849"><code>func crash() {</code></span>
<span class="codeline" id="line-850"><code>	// OS X core dumps are linear dumps of the mapped memory,</code></span>
<span class="codeline" id="line-851"><code>	// from the first virtual byte to the last, with zeros in the gaps.</code></span>
<span class="codeline" id="line-852"><code>	// Because of the way we arrange the address space on 64-bit systems,</code></span>
<span class="codeline" id="line-853"><code>	// this means the OS X core file will be &gt;128 GB and even on a zippy</code></span>
<span class="codeline" id="line-854"><code>	// workstation can take OS X well over an hour to write (uninterruptible).</code></span>
<span class="codeline" id="line-855"><code>	// Save users from making that mistake.</code></span>
<span class="codeline" id="line-856"><code>	if GOOS == "darwin" &amp;&amp; GOARCH == "amd64" {</code></span>
<span class="codeline" id="line-857"><code>		return</code></span>
<span class="codeline" id="line-858"><code>	}</code></span>
<span class="codeline" id="line-859"><code></code></span>
<span class="codeline" id="line-860"><code>	dieFromSignal(_SIGABRT)</code></span>
<span class="codeline" id="line-861"><code>}</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>// ensureSigM starts one global, sleeping thread to make sure at least one thread</code></span>
<span class="codeline" id="line-864"><code>// is available to catch signals enabled for os/signal.</code></span>
<span class="codeline" id="line-865"><code>func ensureSigM() {</code></span>
<span class="codeline" id="line-866"><code>	if maskUpdatedChan != nil {</code></span>
<span class="codeline" id="line-867"><code>		return</code></span>
<span class="codeline" id="line-868"><code>	}</code></span>
<span class="codeline" id="line-869"><code>	maskUpdatedChan = make(chan struct{})</code></span>
<span class="codeline" id="line-870"><code>	disableSigChan = make(chan uint32)</code></span>
<span class="codeline" id="line-871"><code>	enableSigChan = make(chan uint32)</code></span>
<span class="codeline" id="line-872"><code>	go func() {</code></span>
<span class="codeline" id="line-873"><code>		// Signal masks are per-thread, so make sure this goroutine stays on one</code></span>
<span class="codeline" id="line-874"><code>		// thread.</code></span>
<span class="codeline" id="line-875"><code>		LockOSThread()</code></span>
<span class="codeline" id="line-876"><code>		defer UnlockOSThread()</code></span>
<span class="codeline" id="line-877"><code>		// The sigBlocked mask contains the signals not active for os/signal,</code></span>
<span class="codeline" id="line-878"><code>		// initially all signals except the essential. When signal.Notify()/Stop is called,</code></span>
<span class="codeline" id="line-879"><code>		// sigenable/sigdisable in turn notify this thread to update its signal</code></span>
<span class="codeline" id="line-880"><code>		// mask accordingly.</code></span>
<span class="codeline" id="line-881"><code>		sigBlocked := sigset_all</code></span>
<span class="codeline" id="line-882"><code>		for i := range sigtable {</code></span>
<span class="codeline" id="line-883"><code>			if !blockableSig(uint32(i)) {</code></span>
<span class="codeline" id="line-884"><code>				sigdelset(&amp;sigBlocked, i)</code></span>
<span class="codeline" id="line-885"><code>			}</code></span>
<span class="codeline" id="line-886"><code>		}</code></span>
<span class="codeline" id="line-887"><code>		sigprocmask(_SIG_SETMASK, &amp;sigBlocked, nil)</code></span>
<span class="codeline" id="line-888"><code>		for {</code></span>
<span class="codeline" id="line-889"><code>			select {</code></span>
<span class="codeline" id="line-890"><code>			case sig := &lt;-enableSigChan:</code></span>
<span class="codeline" id="line-891"><code>				if sig &gt; 0 {</code></span>
<span class="codeline" id="line-892"><code>					sigdelset(&amp;sigBlocked, int(sig))</code></span>
<span class="codeline" id="line-893"><code>				}</code></span>
<span class="codeline" id="line-894"><code>			case sig := &lt;-disableSigChan:</code></span>
<span class="codeline" id="line-895"><code>				if sig &gt; 0 &amp;&amp; blockableSig(sig) {</code></span>
<span class="codeline" id="line-896"><code>					sigaddset(&amp;sigBlocked, int(sig))</code></span>
<span class="codeline" id="line-897"><code>				}</code></span>
<span class="codeline" id="line-898"><code>			}</code></span>
<span class="codeline" id="line-899"><code>			sigprocmask(_SIG_SETMASK, &amp;sigBlocked, nil)</code></span>
<span class="codeline" id="line-900"><code>			maskUpdatedChan &lt;- struct{}{}</code></span>
<span class="codeline" id="line-901"><code>		}</code></span>
<span class="codeline" id="line-902"><code>	}()</code></span>
<span class="codeline" id="line-903"><code>}</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>// This is called when we receive a signal when there is no signal stack.</code></span>
<span class="codeline" id="line-906"><code>// This can only happen if non-Go code calls sigaltstack to disable the</code></span>
<span class="codeline" id="line-907"><code>// signal stack.</code></span>
<span class="codeline" id="line-908"><code>func noSignalStack(sig uint32) {</code></span>
<span class="codeline" id="line-909"><code>	println("signal", sig, "received on thread with no signal stack")</code></span>
<span class="codeline" id="line-910"><code>	throw("non-Go code disabled sigaltstack")</code></span>
<span class="codeline" id="line-911"><code>}</code></span>
<span class="codeline" id="line-912"><code></code></span>
<span class="codeline" id="line-913"><code>// This is called if we receive a signal when there is a signal stack</code></span>
<span class="codeline" id="line-914"><code>// but we are not on it. This can only happen if non-Go code called</code></span>
<span class="codeline" id="line-915"><code>// sigaction without setting the SS_ONSTACK flag.</code></span>
<span class="codeline" id="line-916"><code>func sigNotOnStack(sig uint32) {</code></span>
<span class="codeline" id="line-917"><code>	println("signal", sig, "received but handler not on signal stack")</code></span>
<span class="codeline" id="line-918"><code>	throw("non-Go code set up signal handler without SA_ONSTACK flag")</code></span>
<span class="codeline" id="line-919"><code>}</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>// signalDuringFork is called if we receive a signal while doing a fork.</code></span>
<span class="codeline" id="line-922"><code>// We do not want signals at that time, as a signal sent to the process</code></span>
<span class="codeline" id="line-923"><code>// group may be delivered to the child process, causing confusion.</code></span>
<span class="codeline" id="line-924"><code>// This should never be called, because we block signals across the fork;</code></span>
<span class="codeline" id="line-925"><code>// this function is just a safety check. See issue 18600 for background.</code></span>
<span class="codeline" id="line-926"><code>func signalDuringFork(sig uint32) {</code></span>
<span class="codeline" id="line-927"><code>	println("signal", sig, "received during fork")</code></span>
<span class="codeline" id="line-928"><code>	throw("signal received during fork")</code></span>
<span class="codeline" id="line-929"><code>}</code></span>
<span class="codeline" id="line-930"><code></code></span>
<span class="codeline" id="line-931"><code>var badginsignalMsg = "fatal: bad g in signal handler\n"</code></span>
<span class="codeline" id="line-932"><code></code></span>
<span class="codeline" id="line-933"><code>// This runs on a foreign stack, without an m or a g. No stack split.</code></span>
<span class="codeline" id="line-934"><code>//go:nosplit</code></span>
<span class="codeline" id="line-935"><code>//go:norace</code></span>
<span class="codeline" id="line-936"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-937"><code>func badsignal(sig uintptr, c *sigctxt) {</code></span>
<span class="codeline" id="line-938"><code>	if !iscgo &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-939"><code>		// There is no extra M. needm will not be able to grab</code></span>
<span class="codeline" id="line-940"><code>		// an M. Instead of hanging, just crash.</code></span>
<span class="codeline" id="line-941"><code>		// Cannot call split-stack function as there is no G.</code></span>
<span class="codeline" id="line-942"><code>		s := stringStructOf(&amp;badginsignalMsg)</code></span>
<span class="codeline" id="line-943"><code>		write(2, s.str, int32(s.len))</code></span>
<span class="codeline" id="line-944"><code>		exit(2)</code></span>
<span class="codeline" id="line-945"><code>		*(*uintptr)(unsafe.Pointer(uintptr(123))) = 2</code></span>
<span class="codeline" id="line-946"><code>	}</code></span>
<span class="codeline" id="line-947"><code>	needm()</code></span>
<span class="codeline" id="line-948"><code>	if !sigsend(uint32(sig)) {</code></span>
<span class="codeline" id="line-949"><code>		// A foreign thread received the signal sig, and the</code></span>
<span class="codeline" id="line-950"><code>		// Go code does not want to handle it.</code></span>
<span class="codeline" id="line-951"><code>		raisebadsignal(uint32(sig), c)</code></span>
<span class="codeline" id="line-952"><code>	}</code></span>
<span class="codeline" id="line-953"><code>	dropm()</code></span>
<span class="codeline" id="line-954"><code>}</code></span>
<span class="codeline" id="line-955"><code></code></span>
<span class="codeline" id="line-956"><code>//go:noescape</code></span>
<span class="codeline" id="line-957"><code>func sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)</code></span>
<span class="codeline" id="line-958"><code></code></span>
<span class="codeline" id="line-959"><code>// Determines if the signal should be handled by Go and if not, forwards the</code></span>
<span class="codeline" id="line-960"><code>// signal to the handler that was installed before Go's. Returns whether the</code></span>
<span class="codeline" id="line-961"><code>// signal was forwarded.</code></span>
<span class="codeline" id="line-962"><code>// This is called by the signal handler, and the world may be stopped.</code></span>
<span class="codeline" id="line-963"><code>//go:nosplit</code></span>
<span class="codeline" id="line-964"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-965"><code>func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-966"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-967"><code>		return false</code></span>
<span class="codeline" id="line-968"><code>	}</code></span>
<span class="codeline" id="line-969"><code>	fwdFn := atomic.Loaduintptr(&amp;fwdSig[sig])</code></span>
<span class="codeline" id="line-970"><code>	flags := sigtable[sig].flags</code></span>
<span class="codeline" id="line-971"><code></code></span>
<span class="codeline" id="line-972"><code>	// If we aren't handling the signal, forward it.</code></span>
<span class="codeline" id="line-973"><code>	if atomic.Load(&amp;handlingSig[sig]) == 0 || !signalsOK {</code></span>
<span class="codeline" id="line-974"><code>		// If the signal is ignored, doing nothing is the same as forwarding.</code></span>
<span class="codeline" id="line-975"><code>		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL &amp;&amp; flags&amp;_SigIgn != 0) {</code></span>
<span class="codeline" id="line-976"><code>			return true</code></span>
<span class="codeline" id="line-977"><code>		}</code></span>
<span class="codeline" id="line-978"><code>		// We are not handling the signal and there is no other handler to forward to.</code></span>
<span class="codeline" id="line-979"><code>		// Crash with the default behavior.</code></span>
<span class="codeline" id="line-980"><code>		if fwdFn == _SIG_DFL {</code></span>
<span class="codeline" id="line-981"><code>			setsig(sig, _SIG_DFL)</code></span>
<span class="codeline" id="line-982"><code>			dieFromSignal(sig)</code></span>
<span class="codeline" id="line-983"><code>			return false</code></span>
<span class="codeline" id="line-984"><code>		}</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>		sigfwd(fwdFn, sig, info, ctx)</code></span>
<span class="codeline" id="line-987"><code>		return true</code></span>
<span class="codeline" id="line-988"><code>	}</code></span>
<span class="codeline" id="line-989"><code></code></span>
<span class="codeline" id="line-990"><code>	// This function and its caller sigtrampgo assumes SIGPIPE is delivered on the</code></span>
<span class="codeline" id="line-991"><code>	// originating thread. This property does not hold on macOS (golang.org/issue/33384),</code></span>
<span class="codeline" id="line-992"><code>	// so we have no choice but to ignore SIGPIPE.</code></span>
<span class="codeline" id="line-993"><code>	if (GOOS == "darwin" || GOOS == "ios") &amp;&amp; sig == _SIGPIPE {</code></span>
<span class="codeline" id="line-994"><code>		return true</code></span>
<span class="codeline" id="line-995"><code>	}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>	// If there is no handler to forward to, no need to forward.</code></span>
<span class="codeline" id="line-998"><code>	if fwdFn == _SIG_DFL {</code></span>
<span class="codeline" id="line-999"><code>		return false</code></span>
<span class="codeline" id="line-1000"><code>	}</code></span>
<span class="codeline" id="line-1001"><code></code></span>
<span class="codeline" id="line-1002"><code>	c := &amp;sigctxt{info, ctx}</code></span>
<span class="codeline" id="line-1003"><code>	// Only forward synchronous signals and SIGPIPE.</code></span>
<span class="codeline" id="line-1004"><code>	// Unfortunately, user generated SIGPIPEs will also be forwarded, because si_code</code></span>
<span class="codeline" id="line-1005"><code>	// is set to _SI_USER even for a SIGPIPE raised from a write to a closed socket</code></span>
<span class="codeline" id="line-1006"><code>	// or pipe.</code></span>
<span class="codeline" id="line-1007"><code>	if (c.sigcode() == _SI_USER || flags&amp;_SigPanic == 0) &amp;&amp; sig != _SIGPIPE {</code></span>
<span class="codeline" id="line-1008"><code>		return false</code></span>
<span class="codeline" id="line-1009"><code>	}</code></span>
<span class="codeline" id="line-1010"><code>	// Determine if the signal occurred inside Go code. We test that:</code></span>
<span class="codeline" id="line-1011"><code>	//   (1) we weren't in VDSO page,</code></span>
<span class="codeline" id="line-1012"><code>	//   (2) we were in a goroutine (i.e., m.curg != nil), and</code></span>
<span class="codeline" id="line-1013"><code>	//   (3) we weren't in CGO.</code></span>
<span class="codeline" id="line-1014"><code>	g := sigFetchG(c)</code></span>
<span class="codeline" id="line-1015"><code>	if g != nil &amp;&amp; g.m != nil &amp;&amp; g.m.curg != nil &amp;&amp; !g.m.incgo {</code></span>
<span class="codeline" id="line-1016"><code>		return false</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code></code></span>
<span class="codeline" id="line-1019"><code>	// Signal not handled by Go, forward it.</code></span>
<span class="codeline" id="line-1020"><code>	if fwdFn != _SIG_IGN {</code></span>
<span class="codeline" id="line-1021"><code>		sigfwd(fwdFn, sig, info, ctx)</code></span>
<span class="codeline" id="line-1022"><code>	}</code></span>
<span class="codeline" id="line-1023"><code></code></span>
<span class="codeline" id="line-1024"><code>	return true</code></span>
<span class="codeline" id="line-1025"><code>}</code></span>
<span class="codeline" id="line-1026"><code></code></span>
<span class="codeline" id="line-1027"><code>// sigsave saves the current thread's signal mask into *p.</code></span>
<span class="codeline" id="line-1028"><code>// This is used to preserve the non-Go signal mask when a non-Go</code></span>
<span class="codeline" id="line-1029"><code>// thread calls a Go function.</code></span>
<span class="codeline" id="line-1030"><code>// This is nosplit and nowritebarrierrec because it is called by needm</code></span>
<span class="codeline" id="line-1031"><code>// which may be called on a non-Go thread with no g available.</code></span>
<span class="codeline" id="line-1032"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1033"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1034"><code>func sigsave(p *sigset) {</code></span>
<span class="codeline" id="line-1035"><code>	sigprocmask(_SIG_SETMASK, nil, p)</code></span>
<span class="codeline" id="line-1036"><code>}</code></span>
<span class="codeline" id="line-1037"><code></code></span>
<span class="codeline" id="line-1038"><code>// msigrestore sets the current thread's signal mask to sigmask.</code></span>
<span class="codeline" id="line-1039"><code>// This is used to restore the non-Go signal mask when a non-Go thread</code></span>
<span class="codeline" id="line-1040"><code>// calls a Go function.</code></span>
<span class="codeline" id="line-1041"><code>// This is nosplit and nowritebarrierrec because it is called by dropm</code></span>
<span class="codeline" id="line-1042"><code>// after g has been cleared.</code></span>
<span class="codeline" id="line-1043"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1044"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1045"><code>func msigrestore(sigmask sigset) {</code></span>
<span class="codeline" id="line-1046"><code>	sigprocmask(_SIG_SETMASK, &amp;sigmask, nil)</code></span>
<span class="codeline" id="line-1047"><code>}</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>// sigsetAllExiting is used by sigblock(true) when a thread is</code></span>
<span class="codeline" id="line-1050"><code>// exiting. sigset_all is defined in OS specific code, and per GOOS</code></span>
<span class="codeline" id="line-1051"><code>// behavior may override this default for sigsetAllExiting: see</code></span>
<span class="codeline" id="line-1052"><code>// osinit().</code></span>
<span class="codeline" id="line-1053"><code>var sigsetAllExiting = sigset_all</code></span>
<span class="codeline" id="line-1054"><code></code></span>
<span class="codeline" id="line-1055"><code>// sigblock blocks signals in the current thread's signal mask.</code></span>
<span class="codeline" id="line-1056"><code>// This is used to block signals while setting up and tearing down g</code></span>
<span class="codeline" id="line-1057"><code>// when a non-Go thread calls a Go function. When a thread is exiting</code></span>
<span class="codeline" id="line-1058"><code>// we use the sigsetAllExiting value, otherwise the OS specific</code></span>
<span class="codeline" id="line-1059"><code>// definition of sigset_all is used.</code></span>
<span class="codeline" id="line-1060"><code>// This is nosplit and nowritebarrierrec because it is called by needm</code></span>
<span class="codeline" id="line-1061"><code>// which may be called on a non-Go thread with no g available.</code></span>
<span class="codeline" id="line-1062"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1063"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1064"><code>func sigblock(exiting bool) {</code></span>
<span class="codeline" id="line-1065"><code>	if exiting {</code></span>
<span class="codeline" id="line-1066"><code>		sigprocmask(_SIG_SETMASK, &amp;sigsetAllExiting, nil)</code></span>
<span class="codeline" id="line-1067"><code>		return</code></span>
<span class="codeline" id="line-1068"><code>	}</code></span>
<span class="codeline" id="line-1069"><code>	sigprocmask(_SIG_SETMASK, &amp;sigset_all, nil)</code></span>
<span class="codeline" id="line-1070"><code>}</code></span>
<span class="codeline" id="line-1071"><code></code></span>
<span class="codeline" id="line-1072"><code>// unblocksig removes sig from the current thread's signal mask.</code></span>
<span class="codeline" id="line-1073"><code>// This is nosplit and nowritebarrierrec because it is called from</code></span>
<span class="codeline" id="line-1074"><code>// dieFromSignal, which can be called by sigfwdgo while running in the</code></span>
<span class="codeline" id="line-1075"><code>// signal handler, on the signal stack, with no g available.</code></span>
<span class="codeline" id="line-1076"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1077"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1078"><code>func unblocksig(sig uint32) {</code></span>
<span class="codeline" id="line-1079"><code>	var set sigset</code></span>
<span class="codeline" id="line-1080"><code>	sigaddset(&amp;set, int(sig))</code></span>
<span class="codeline" id="line-1081"><code>	sigprocmask(_SIG_UNBLOCK, &amp;set, nil)</code></span>
<span class="codeline" id="line-1082"><code>}</code></span>
<span class="codeline" id="line-1083"><code></code></span>
<span class="codeline" id="line-1084"><code>// minitSignals is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1085"><code>// thread's alternate signal stack and signal mask.</code></span>
<span class="codeline" id="line-1086"><code>func minitSignals() {</code></span>
<span class="codeline" id="line-1087"><code>	minitSignalStack()</code></span>
<span class="codeline" id="line-1088"><code>	minitSignalMask()</code></span>
<span class="codeline" id="line-1089"><code>}</code></span>
<span class="codeline" id="line-1090"><code></code></span>
<span class="codeline" id="line-1091"><code>// minitSignalStack is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1092"><code>// alternate signal stack. If the alternate signal stack is not set</code></span>
<span class="codeline" id="line-1093"><code>// for the thread (the normal case) then set the alternate signal</code></span>
<span class="codeline" id="line-1094"><code>// stack to the gsignal stack. If the alternate signal stack is set</code></span>
<span class="codeline" id="line-1095"><code>// for the thread (the case when a non-Go thread sets the alternate</code></span>
<span class="codeline" id="line-1096"><code>// signal stack and then calls a Go function) then set the gsignal</code></span>
<span class="codeline" id="line-1097"><code>// stack to the alternate signal stack. We also set the alternate</code></span>
<span class="codeline" id="line-1098"><code>// signal stack to the gsignal stack if cgo is not used (regardless</code></span>
<span class="codeline" id="line-1099"><code>// of whether it is already set). Record which choice was made in</code></span>
<span class="codeline" id="line-1100"><code>// newSigstack, so that it can be undone in unminit.</code></span>
<span class="codeline" id="line-1101"><code>func minitSignalStack() {</code></span>
<span class="codeline" id="line-1102"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1103"><code>	var st stackt</code></span>
<span class="codeline" id="line-1104"><code>	sigaltstack(nil, &amp;st)</code></span>
<span class="codeline" id="line-1105"><code>	if st.ss_flags&amp;_SS_DISABLE != 0 || !iscgo {</code></span>
<span class="codeline" id="line-1106"><code>		signalstack(&amp;_g_.m.gsignal.stack)</code></span>
<span class="codeline" id="line-1107"><code>		_g_.m.newSigstack = true</code></span>
<span class="codeline" id="line-1108"><code>	} else {</code></span>
<span class="codeline" id="line-1109"><code>		setGsignalStack(&amp;st, &amp;_g_.m.goSigStack)</code></span>
<span class="codeline" id="line-1110"><code>		_g_.m.newSigstack = false</code></span>
<span class="codeline" id="line-1111"><code>	}</code></span>
<span class="codeline" id="line-1112"><code>}</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>// minitSignalMask is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1115"><code>// thread's signal mask. When this is called all signals have been</code></span>
<span class="codeline" id="line-1116"><code>// blocked for the thread.  This starts with m.sigmask, which was set</code></span>
<span class="codeline" id="line-1117"><code>// either from initSigmask for a newly created thread or by calling</code></span>
<span class="codeline" id="line-1118"><code>// sigsave if this is a non-Go thread calling a Go function. It</code></span>
<span class="codeline" id="line-1119"><code>// removes all essential signals from the mask, thus causing those</code></span>
<span class="codeline" id="line-1120"><code>// signals to not be blocked. Then it sets the thread's signal mask.</code></span>
<span class="codeline" id="line-1121"><code>// After this is called the thread can receive signals.</code></span>
<span class="codeline" id="line-1122"><code>func minitSignalMask() {</code></span>
<span class="codeline" id="line-1123"><code>	nmask := getg().m.sigmask</code></span>
<span class="codeline" id="line-1124"><code>	for i := range sigtable {</code></span>
<span class="codeline" id="line-1125"><code>		if !blockableSig(uint32(i)) {</code></span>
<span class="codeline" id="line-1126"><code>			sigdelset(&amp;nmask, i)</code></span>
<span class="codeline" id="line-1127"><code>		}</code></span>
<span class="codeline" id="line-1128"><code>	}</code></span>
<span class="codeline" id="line-1129"><code>	sigprocmask(_SIG_SETMASK, &amp;nmask, nil)</code></span>
<span class="codeline" id="line-1130"><code>}</code></span>
<span class="codeline" id="line-1131"><code></code></span>
<span class="codeline" id="line-1132"><code>// unminitSignals is called from dropm, via unminit, to undo the</code></span>
<span class="codeline" id="line-1133"><code>// effect of calling minit on a non-Go thread.</code></span>
<span class="codeline" id="line-1134"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1135"><code>func unminitSignals() {</code></span>
<span class="codeline" id="line-1136"><code>	if getg().m.newSigstack {</code></span>
<span class="codeline" id="line-1137"><code>		st := stackt{ss_flags: _SS_DISABLE}</code></span>
<span class="codeline" id="line-1138"><code>		sigaltstack(&amp;st, nil)</code></span>
<span class="codeline" id="line-1139"><code>	} else {</code></span>
<span class="codeline" id="line-1140"><code>		// We got the signal stack from someone else. Restore</code></span>
<span class="codeline" id="line-1141"><code>		// the Go-allocated stack in case this M gets reused</code></span>
<span class="codeline" id="line-1142"><code>		// for another thread (e.g., it's an extram). Also, on</code></span>
<span class="codeline" id="line-1143"><code>		// Android, libc allocates a signal stack for all</code></span>
<span class="codeline" id="line-1144"><code>		// threads, so it's important to restore the Go stack</code></span>
<span class="codeline" id="line-1145"><code>		// even on Go-created threads so we can free it.</code></span>
<span class="codeline" id="line-1146"><code>		restoreGsignalStack(&amp;getg().m.goSigStack)</code></span>
<span class="codeline" id="line-1147"><code>	}</code></span>
<span class="codeline" id="line-1148"><code>}</code></span>
<span class="codeline" id="line-1149"><code></code></span>
<span class="codeline" id="line-1150"><code>// blockableSig reports whether sig may be blocked by the signal mask.</code></span>
<span class="codeline" id="line-1151"><code>// We never want to block the signals marked _SigUnblock;</code></span>
<span class="codeline" id="line-1152"><code>// these are the synchronous signals that turn into a Go panic.</code></span>
<span class="codeline" id="line-1153"><code>// In a Go program--not a c-archive/c-shared--we never want to block</code></span>
<span class="codeline" id="line-1154"><code>// the signals marked _SigKill or _SigThrow, as otherwise it's possible</code></span>
<span class="codeline" id="line-1155"><code>// for all running threads to block them and delay their delivery until</code></span>
<span class="codeline" id="line-1156"><code>// we start a new thread. When linked into a C program we let the C code</code></span>
<span class="codeline" id="line-1157"><code>// decide on the disposition of those signals.</code></span>
<span class="codeline" id="line-1158"><code>func blockableSig(sig uint32) bool {</code></span>
<span class="codeline" id="line-1159"><code>	flags := sigtable[sig].flags</code></span>
<span class="codeline" id="line-1160"><code>	if flags&amp;_SigUnblock != 0 {</code></span>
<span class="codeline" id="line-1161"><code>		return false</code></span>
<span class="codeline" id="line-1162"><code>	}</code></span>
<span class="codeline" id="line-1163"><code>	if isarchive || islibrary {</code></span>
<span class="codeline" id="line-1164"><code>		return true</code></span>
<span class="codeline" id="line-1165"><code>	}</code></span>
<span class="codeline" id="line-1166"><code>	return flags&amp;(_SigKill|_SigThrow) == 0</code></span>
<span class="codeline" id="line-1167"><code>}</code></span>
<span class="codeline" id="line-1168"><code></code></span>
<span class="codeline" id="line-1169"><code>// gsignalStack saves the fields of the gsignal stack changed by</code></span>
<span class="codeline" id="line-1170"><code>// setGsignalStack.</code></span>
<span class="codeline" id="line-1171"><code>type gsignalStack struct {</code></span>
<span class="codeline" id="line-1172"><code>	stack       stack</code></span>
<span class="codeline" id="line-1173"><code>	stackguard0 uintptr</code></span>
<span class="codeline" id="line-1174"><code>	stackguard1 uintptr</code></span>
<span class="codeline" id="line-1175"><code>	stktopsp    uintptr</code></span>
<span class="codeline" id="line-1176"><code>}</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>// setGsignalStack sets the gsignal stack of the current m to an</code></span>
<span class="codeline" id="line-1179"><code>// alternate signal stack returned from the sigaltstack system call.</code></span>
<span class="codeline" id="line-1180"><code>// It saves the old values in *old for use by restoreGsignalStack.</code></span>
<span class="codeline" id="line-1181"><code>// This is used when handling a signal if non-Go code has set the</code></span>
<span class="codeline" id="line-1182"><code>// alternate signal stack.</code></span>
<span class="codeline" id="line-1183"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1184"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1185"><code>func setGsignalStack(st *stackt, old *gsignalStack) {</code></span>
<span class="codeline" id="line-1186"><code>	g := getg()</code></span>
<span class="codeline" id="line-1187"><code>	if old != nil {</code></span>
<span class="codeline" id="line-1188"><code>		old.stack = g.m.gsignal.stack</code></span>
<span class="codeline" id="line-1189"><code>		old.stackguard0 = g.m.gsignal.stackguard0</code></span>
<span class="codeline" id="line-1190"><code>		old.stackguard1 = g.m.gsignal.stackguard1</code></span>
<span class="codeline" id="line-1191"><code>		old.stktopsp = g.m.gsignal.stktopsp</code></span>
<span class="codeline" id="line-1192"><code>	}</code></span>
<span class="codeline" id="line-1193"><code>	stsp := uintptr(unsafe.Pointer(st.ss_sp))</code></span>
<span class="codeline" id="line-1194"><code>	g.m.gsignal.stack.lo = stsp</code></span>
<span class="codeline" id="line-1195"><code>	g.m.gsignal.stack.hi = stsp + st.ss_size</code></span>
<span class="codeline" id="line-1196"><code>	g.m.gsignal.stackguard0 = stsp + _StackGuard</code></span>
<span class="codeline" id="line-1197"><code>	g.m.gsignal.stackguard1 = stsp + _StackGuard</code></span>
<span class="codeline" id="line-1198"><code>}</code></span>
<span class="codeline" id="line-1199"><code></code></span>
<span class="codeline" id="line-1200"><code>// restoreGsignalStack restores the gsignal stack to the value it had</code></span>
<span class="codeline" id="line-1201"><code>// before entering the signal handler.</code></span>
<span class="codeline" id="line-1202"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1203"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1204"><code>func restoreGsignalStack(st *gsignalStack) {</code></span>
<span class="codeline" id="line-1205"><code>	gp := getg().m.gsignal</code></span>
<span class="codeline" id="line-1206"><code>	gp.stack = st.stack</code></span>
<span class="codeline" id="line-1207"><code>	gp.stackguard0 = st.stackguard0</code></span>
<span class="codeline" id="line-1208"><code>	gp.stackguard1 = st.stackguard1</code></span>
<span class="codeline" id="line-1209"><code>	gp.stktopsp = st.stktopsp</code></span>
<span class="codeline" id="line-1210"><code>}</code></span>
<span class="codeline" id="line-1211"><code></code></span>
<span class="codeline" id="line-1212"><code>// signalstack sets the current thread's alternate signal stack to s.</code></span>
<span class="codeline" id="line-1213"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1214"><code>func signalstack(s *stack) {</code></span>
<span class="codeline" id="line-1215"><code>	st := stackt{ss_size: s.hi - s.lo}</code></span>
<span class="codeline" id="line-1216"><code>	setSignalstackSP(&amp;st, s.lo)</code></span>
<span class="codeline" id="line-1217"><code>	sigaltstack(&amp;st, nil)</code></span>
<span class="codeline" id="line-1218"><code>}</code></span>
<span class="codeline" id="line-1219"><code></code></span>
<span class="codeline" id="line-1220"><code>// setsigsegv is used on darwin/arm64 to fake a segmentation fault.</code></span>
<span class="codeline" id="line-1221"><code>//</code></span>
<span class="codeline" id="line-1222"><code>// This is exported via linkname to assembly in runtime/cgo.</code></span>
<span class="codeline" id="line-1223"><code>//</code></span>
<span class="codeline" id="line-1224"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1225"><code>//go:linkname setsigsegv</code></span>
<span class="codeline" id="line-1226"><code>func setsigsegv(pc uintptr) {</code></span>
<span class="codeline" id="line-1227"><code>	g := getg()</code></span>
<span class="codeline" id="line-1228"><code>	g.sig = _SIGSEGV</code></span>
<span class="codeline" id="line-1229"><code>	g.sigpc = pc</code></span>
<span class="codeline" id="line-1230"><code>	g.sigcode0 = _SEGV_MAPERR</code></span>
<span class="codeline" id="line-1231"><code>	g.sigcode1 = 0 // TODO: emulate si_addr</code></span>
<span class="codeline" id="line-1232"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>