<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: utf8.go in package unicode/utf8</title>
<link href="../../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	utf8.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/unicode/utf8.html">unicode/utf8</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package utf8 implements functions and constants to support text encoded in</code></span>
<span class="codeline" id="line-6"><code>// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.</code></span>
<span class="codeline" id="line-7"><code>// See https://en.wikipedia.org/wiki/UTF-8</code></span></div><span class="codeline" id="line-8"><code>package utf8</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>// The conditions RuneError==unicode.ReplacementChar and</code></span>
<span class="codeline" id="line-11"><code>// MaxRune==unicode.MaxRune are verified in the tests.</code></span>
<span class="codeline" id="line-12"><code>// Defining them locally avoids this package depending on package unicode.</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// Numbers fundamental to the encoding.</code></span>
<span class="codeline" id="line-15"><code>const (</code></span>
<span class="codeline" id="line-16"><code>	RuneError = '\uFFFD'     // the "error" Rune or "Unicode replacement character"</code></span>
<span class="codeline" id="line-17"><code>	RuneSelf  = 0x80         // characters below RuneSelf are represented as themselves in a single byte.</code></span>
<span class="codeline" id="line-18"><code>	MaxRune   = '\U0010FFFF' // Maximum valid Unicode code point.</code></span>
<span class="codeline" id="line-19"><code>	UTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// Code points in the surrogate range are not valid for UTF-8.</code></span>
<span class="codeline" id="line-23"><code>const (</code></span>
<span class="codeline" id="line-24"><code>	surrogateMin = 0xD800</code></span>
<span class="codeline" id="line-25"><code>	surrogateMax = 0xDFFF</code></span>
<span class="codeline" id="line-26"><code>)</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>const (</code></span>
<span class="codeline" id="line-29"><code>	t1 = 0b00000000</code></span>
<span class="codeline" id="line-30"><code>	tx = 0b10000000</code></span>
<span class="codeline" id="line-31"><code>	t2 = 0b11000000</code></span>
<span class="codeline" id="line-32"><code>	t3 = 0b11100000</code></span>
<span class="codeline" id="line-33"><code>	t4 = 0b11110000</code></span>
<span class="codeline" id="line-34"><code>	t5 = 0b11111000</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>	maskx = 0b00111111</code></span>
<span class="codeline" id="line-37"><code>	mask2 = 0b00011111</code></span>
<span class="codeline" id="line-38"><code>	mask3 = 0b00001111</code></span>
<span class="codeline" id="line-39"><code>	mask4 = 0b00000111</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>	rune1Max = 1&lt;&lt;7 - 1</code></span>
<span class="codeline" id="line-42"><code>	rune2Max = 1&lt;&lt;11 - 1</code></span>
<span class="codeline" id="line-43"><code>	rune3Max = 1&lt;&lt;16 - 1</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>	// The default lowest and highest continuation byte.</code></span>
<span class="codeline" id="line-46"><code>	locb = 0b10000000</code></span>
<span class="codeline" id="line-47"><code>	hicb = 0b10111111</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>	// These names of these constants are chosen to give nice alignment in the</code></span>
<span class="codeline" id="line-50"><code>	// table below. The first nibble is an index into acceptRanges or F for</code></span>
<span class="codeline" id="line-51"><code>	// special one-byte cases. The second nibble is the Rune length or the</code></span>
<span class="codeline" id="line-52"><code>	// Status for the special one-byte case.</code></span>
<span class="codeline" id="line-53"><code>	xx = 0xF1 // invalid: size 1</code></span>
<span class="codeline" id="line-54"><code>	as = 0xF0 // ASCII: size 1</code></span>
<span class="codeline" id="line-55"><code>	s1 = 0x02 // accept 0, size 2</code></span>
<span class="codeline" id="line-56"><code>	s2 = 0x13 // accept 1, size 3</code></span>
<span class="codeline" id="line-57"><code>	s3 = 0x03 // accept 0, size 3</code></span>
<span class="codeline" id="line-58"><code>	s4 = 0x23 // accept 2, size 3</code></span>
<span class="codeline" id="line-59"><code>	s5 = 0x34 // accept 3, size 4</code></span>
<span class="codeline" id="line-60"><code>	s6 = 0x04 // accept 0, size 4</code></span>
<span class="codeline" id="line-61"><code>	s7 = 0x44 // accept 4, size 4</code></span>
<span class="codeline" id="line-62"><code>)</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// first is information about the first byte in a UTF-8 sequence.</code></span>
<span class="codeline" id="line-65"><code>var first = [256]uint8{</code></span>
<span class="codeline" id="line-66"><code>	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</code></span>
<span class="codeline" id="line-67"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F</code></span>
<span class="codeline" id="line-68"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F</code></span>
<span class="codeline" id="line-69"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F</code></span>
<span class="codeline" id="line-70"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F</code></span>
<span class="codeline" id="line-71"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F</code></span>
<span class="codeline" id="line-72"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F</code></span>
<span class="codeline" id="line-73"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F</code></span>
<span class="codeline" id="line-74"><code>	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F</code></span>
<span class="codeline" id="line-75"><code>	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</code></span>
<span class="codeline" id="line-76"><code>	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F</code></span>
<span class="codeline" id="line-77"><code>	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F</code></span>
<span class="codeline" id="line-78"><code>	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF</code></span>
<span class="codeline" id="line-79"><code>	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF</code></span>
<span class="codeline" id="line-80"><code>	xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF</code></span>
<span class="codeline" id="line-81"><code>	s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF</code></span>
<span class="codeline" id="line-82"><code>	s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF</code></span>
<span class="codeline" id="line-83"><code>	s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF</code></span>
<span class="codeline" id="line-84"><code>}</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>// acceptRange gives the range of valid values for the second byte in a UTF-8</code></span>
<span class="codeline" id="line-87"><code>// sequence.</code></span>
<span class="codeline" id="line-88"><code>type acceptRange struct {</code></span>
<span class="codeline" id="line-89"><code>	lo uint8 // lowest value for second byte.</code></span>
<span class="codeline" id="line-90"><code>	hi uint8 // highest value for second byte.</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>// acceptRanges has size 16 to avoid bounds checks in the code that uses it.</code></span>
<span class="codeline" id="line-94"><code>var acceptRanges = [16]acceptRange{</code></span>
<span class="codeline" id="line-95"><code>	0: {locb, hicb},</code></span>
<span class="codeline" id="line-96"><code>	1: {0xA0, hicb},</code></span>
<span class="codeline" id="line-97"><code>	2: {locb, 0x9F},</code></span>
<span class="codeline" id="line-98"><code>	3: {0x90, hicb},</code></span>
<span class="codeline" id="line-99"><code>	4: {locb, 0x8F},</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.</code></span>
<span class="codeline" id="line-103"><code>// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</code></span>
<span class="codeline" id="line-104"><code>func FullRune(p []byte) bool {</code></span>
<span class="codeline" id="line-105"><code>	n := len(p)</code></span>
<span class="codeline" id="line-106"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-107"><code>		return false</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>	x := first[p[0]]</code></span>
<span class="codeline" id="line-110"><code>	if n &gt;= int(x&amp;7) {</code></span>
<span class="codeline" id="line-111"><code>		return true // ASCII, invalid or valid.</code></span>
<span class="codeline" id="line-112"><code>	}</code></span>
<span class="codeline" id="line-113"><code>	// Must be short or invalid.</code></span>
<span class="codeline" id="line-114"><code>	accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-115"><code>	if n &gt; 1 &amp;&amp; (p[1] &lt; accept.lo || accept.hi &lt; p[1]) {</code></span>
<span class="codeline" id="line-116"><code>		return true</code></span>
<span class="codeline" id="line-117"><code>	} else if n &gt; 2 &amp;&amp; (p[2] &lt; locb || hicb &lt; p[2]) {</code></span>
<span class="codeline" id="line-118"><code>		return true</code></span>
<span class="codeline" id="line-119"><code>	}</code></span>
<span class="codeline" id="line-120"><code>	return false</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// FullRuneInString is like FullRune but its input is a string.</code></span>
<span class="codeline" id="line-124"><code>func FullRuneInString(s string) bool {</code></span>
<span class="codeline" id="line-125"><code>	n := len(s)</code></span>
<span class="codeline" id="line-126"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-127"><code>		return false</code></span>
<span class="codeline" id="line-128"><code>	}</code></span>
<span class="codeline" id="line-129"><code>	x := first[s[0]]</code></span>
<span class="codeline" id="line-130"><code>	if n &gt;= int(x&amp;7) {</code></span>
<span class="codeline" id="line-131"><code>		return true // ASCII, invalid, or valid.</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	// Must be short or invalid.</code></span>
<span class="codeline" id="line-134"><code>	accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-135"><code>	if n &gt; 1 &amp;&amp; (s[1] &lt; accept.lo || accept.hi &lt; s[1]) {</code></span>
<span class="codeline" id="line-136"><code>		return true</code></span>
<span class="codeline" id="line-137"><code>	} else if n &gt; 2 &amp;&amp; (s[2] &lt; locb || hicb &lt; s[2]) {</code></span>
<span class="codeline" id="line-138"><code>		return true</code></span>
<span class="codeline" id="line-139"><code>	}</code></span>
<span class="codeline" id="line-140"><code>	return false</code></span>
<span class="codeline" id="line-141"><code>}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and</code></span>
<span class="codeline" id="line-144"><code>// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if</code></span>
<span class="codeline" id="line-145"><code>// the encoding is invalid, it returns (RuneError, 1). Both are impossible</code></span>
<span class="codeline" id="line-146"><code>// results for correct, non-empty UTF-8.</code></span>
<span class="codeline" id="line-147"><code>//</code></span>
<span class="codeline" id="line-148"><code>// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is</code></span>
<span class="codeline" id="line-149"><code>// out of range, or is not the shortest possible UTF-8 encoding for the</code></span>
<span class="codeline" id="line-150"><code>// value. No other validation is performed.</code></span>
<span class="codeline" id="line-151"><code>func DecodeRune(p []byte) (r rune, size int) {</code></span>
<span class="codeline" id="line-152"><code>	n := len(p)</code></span>
<span class="codeline" id="line-153"><code>	if n &lt; 1 {</code></span>
<span class="codeline" id="line-154"><code>		return RuneError, 0</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>	p0 := p[0]</code></span>
<span class="codeline" id="line-157"><code>	x := first[p0]</code></span>
<span class="codeline" id="line-158"><code>	if x &gt;= as {</code></span>
<span class="codeline" id="line-159"><code>		// The following code simulates an additional check for x == xx and</code></span>
<span class="codeline" id="line-160"><code>		// handling the ASCII and invalid cases accordingly. This mask-and-or</code></span>
<span class="codeline" id="line-161"><code>		// approach prevents an additional branch.</code></span>
<span class="codeline" id="line-162"><code>		mask := rune(x) &lt;&lt; 31 &gt;&gt; 31 // Create 0x0000 or 0xFFFF.</code></span>
<span class="codeline" id="line-163"><code>		return rune(p[0])&amp;^mask | RuneError&amp;mask, 1</code></span>
<span class="codeline" id="line-164"><code>	}</code></span>
<span class="codeline" id="line-165"><code>	sz := int(x &amp; 7)</code></span>
<span class="codeline" id="line-166"><code>	accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-167"><code>	if n &lt; sz {</code></span>
<span class="codeline" id="line-168"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-169"><code>	}</code></span>
<span class="codeline" id="line-170"><code>	b1 := p[1]</code></span>
<span class="codeline" id="line-171"><code>	if b1 &lt; accept.lo || accept.hi &lt; b1 {</code></span>
<span class="codeline" id="line-172"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code>	if sz &lt;= 2 { // &lt;= instead of == to help the compiler eliminate some bounds checks</code></span>
<span class="codeline" id="line-175"><code>		return rune(p0&amp;mask2)&lt;&lt;6 | rune(b1&amp;maskx), 2</code></span>
<span class="codeline" id="line-176"><code>	}</code></span>
<span class="codeline" id="line-177"><code>	b2 := p[2]</code></span>
<span class="codeline" id="line-178"><code>	if b2 &lt; locb || hicb &lt; b2 {</code></span>
<span class="codeline" id="line-179"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-180"><code>	}</code></span>
<span class="codeline" id="line-181"><code>	if sz &lt;= 3 {</code></span>
<span class="codeline" id="line-182"><code>		return rune(p0&amp;mask3)&lt;&lt;12 | rune(b1&amp;maskx)&lt;&lt;6 | rune(b2&amp;maskx), 3</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code>	b3 := p[3]</code></span>
<span class="codeline" id="line-185"><code>	if b3 &lt; locb || hicb &lt; b3 {</code></span>
<span class="codeline" id="line-186"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-187"><code>	}</code></span>
<span class="codeline" id="line-188"><code>	return rune(p0&amp;mask4)&lt;&lt;18 | rune(b1&amp;maskx)&lt;&lt;12 | rune(b2&amp;maskx)&lt;&lt;6 | rune(b3&amp;maskx), 4</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// DecodeRuneInString is like DecodeRune but its input is a string. If s is</code></span>
<span class="codeline" id="line-192"><code>// empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it</code></span>
<span class="codeline" id="line-193"><code>// returns (RuneError, 1). Both are impossible results for correct, non-empty</code></span>
<span class="codeline" id="line-194"><code>// UTF-8.</code></span>
<span class="codeline" id="line-195"><code>//</code></span>
<span class="codeline" id="line-196"><code>// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is</code></span>
<span class="codeline" id="line-197"><code>// out of range, or is not the shortest possible UTF-8 encoding for the</code></span>
<span class="codeline" id="line-198"><code>// value. No other validation is performed.</code></span>
<span class="codeline" id="line-199"><code>func DecodeRuneInString(s string) (r rune, size int) {</code></span>
<span class="codeline" id="line-200"><code>	n := len(s)</code></span>
<span class="codeline" id="line-201"><code>	if n &lt; 1 {</code></span>
<span class="codeline" id="line-202"><code>		return RuneError, 0</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>	s0 := s[0]</code></span>
<span class="codeline" id="line-205"><code>	x := first[s0]</code></span>
<span class="codeline" id="line-206"><code>	if x &gt;= as {</code></span>
<span class="codeline" id="line-207"><code>		// The following code simulates an additional check for x == xx and</code></span>
<span class="codeline" id="line-208"><code>		// handling the ASCII and invalid cases accordingly. This mask-and-or</code></span>
<span class="codeline" id="line-209"><code>		// approach prevents an additional branch.</code></span>
<span class="codeline" id="line-210"><code>		mask := rune(x) &lt;&lt; 31 &gt;&gt; 31 // Create 0x0000 or 0xFFFF.</code></span>
<span class="codeline" id="line-211"><code>		return rune(s[0])&amp;^mask | RuneError&amp;mask, 1</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code>	sz := int(x &amp; 7)</code></span>
<span class="codeline" id="line-214"><code>	accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-215"><code>	if n &lt; sz {</code></span>
<span class="codeline" id="line-216"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	s1 := s[1]</code></span>
<span class="codeline" id="line-219"><code>	if s1 &lt; accept.lo || accept.hi &lt; s1 {</code></span>
<span class="codeline" id="line-220"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	if sz &lt;= 2 { // &lt;= instead of == to help the compiler eliminate some bounds checks</code></span>
<span class="codeline" id="line-223"><code>		return rune(s0&amp;mask2)&lt;&lt;6 | rune(s1&amp;maskx), 2</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code>	s2 := s[2]</code></span>
<span class="codeline" id="line-226"><code>	if s2 &lt; locb || hicb &lt; s2 {</code></span>
<span class="codeline" id="line-227"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	if sz &lt;= 3 {</code></span>
<span class="codeline" id="line-230"><code>		return rune(s0&amp;mask3)&lt;&lt;12 | rune(s1&amp;maskx)&lt;&lt;6 | rune(s2&amp;maskx), 3</code></span>
<span class="codeline" id="line-231"><code>	}</code></span>
<span class="codeline" id="line-232"><code>	s3 := s[3]</code></span>
<span class="codeline" id="line-233"><code>	if s3 &lt; locb || hicb &lt; s3 {</code></span>
<span class="codeline" id="line-234"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-235"><code>	}</code></span>
<span class="codeline" id="line-236"><code>	return rune(s0&amp;mask4)&lt;&lt;18 | rune(s1&amp;maskx)&lt;&lt;12 | rune(s2&amp;maskx)&lt;&lt;6 | rune(s3&amp;maskx), 4</code></span>
<span class="codeline" id="line-237"><code>}</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and</code></span>
<span class="codeline" id="line-240"><code>// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if</code></span>
<span class="codeline" id="line-241"><code>// the encoding is invalid, it returns (RuneError, 1). Both are impossible</code></span>
<span class="codeline" id="line-242"><code>// results for correct, non-empty UTF-8.</code></span>
<span class="codeline" id="line-243"><code>//</code></span>
<span class="codeline" id="line-244"><code>// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is</code></span>
<span class="codeline" id="line-245"><code>// out of range, or is not the shortest possible UTF-8 encoding for the</code></span>
<span class="codeline" id="line-246"><code>// value. No other validation is performed.</code></span>
<span class="codeline" id="line-247"><code>func DecodeLastRune(p []byte) (r rune, size int) {</code></span>
<span class="codeline" id="line-248"><code>	end := len(p)</code></span>
<span class="codeline" id="line-249"><code>	if end == 0 {</code></span>
<span class="codeline" id="line-250"><code>		return RuneError, 0</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code>	start := end - 1</code></span>
<span class="codeline" id="line-253"><code>	r = rune(p[start])</code></span>
<span class="codeline" id="line-254"><code>	if r &lt; RuneSelf {</code></span>
<span class="codeline" id="line-255"><code>		return r, 1</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code>	// guard against O(n^2) behavior when traversing</code></span>
<span class="codeline" id="line-258"><code>	// backwards through strings with long sequences of</code></span>
<span class="codeline" id="line-259"><code>	// invalid UTF-8.</code></span>
<span class="codeline" id="line-260"><code>	lim := end - UTFMax</code></span>
<span class="codeline" id="line-261"><code>	if lim &lt; 0 {</code></span>
<span class="codeline" id="line-262"><code>		lim = 0</code></span>
<span class="codeline" id="line-263"><code>	}</code></span>
<span class="codeline" id="line-264"><code>	for start--; start &gt;= lim; start-- {</code></span>
<span class="codeline" id="line-265"><code>		if RuneStart(p[start]) {</code></span>
<span class="codeline" id="line-266"><code>			break</code></span>
<span class="codeline" id="line-267"><code>		}</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	if start &lt; 0 {</code></span>
<span class="codeline" id="line-270"><code>		start = 0</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	r, size = DecodeRune(p[start:end])</code></span>
<span class="codeline" id="line-273"><code>	if start+size != end {</code></span>
<span class="codeline" id="line-274"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-275"><code>	}</code></span>
<span class="codeline" id="line-276"><code>	return r, size</code></span>
<span class="codeline" id="line-277"><code>}</code></span>
<span class="codeline" id="line-278"><code></code></span>
<span class="codeline" id="line-279"><code>// DecodeLastRuneInString is like DecodeLastRune but its input is a string. If</code></span>
<span class="codeline" id="line-280"><code>// s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,</code></span>
<span class="codeline" id="line-281"><code>// it returns (RuneError, 1). Both are impossible results for correct,</code></span>
<span class="codeline" id="line-282"><code>// non-empty UTF-8.</code></span>
<span class="codeline" id="line-283"><code>//</code></span>
<span class="codeline" id="line-284"><code>// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is</code></span>
<span class="codeline" id="line-285"><code>// out of range, or is not the shortest possible UTF-8 encoding for the</code></span>
<span class="codeline" id="line-286"><code>// value. No other validation is performed.</code></span>
<span class="codeline" id="line-287"><code>func DecodeLastRuneInString(s string) (r rune, size int) {</code></span>
<span class="codeline" id="line-288"><code>	end := len(s)</code></span>
<span class="codeline" id="line-289"><code>	if end == 0 {</code></span>
<span class="codeline" id="line-290"><code>		return RuneError, 0</code></span>
<span class="codeline" id="line-291"><code>	}</code></span>
<span class="codeline" id="line-292"><code>	start := end - 1</code></span>
<span class="codeline" id="line-293"><code>	r = rune(s[start])</code></span>
<span class="codeline" id="line-294"><code>	if r &lt; RuneSelf {</code></span>
<span class="codeline" id="line-295"><code>		return r, 1</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	// guard against O(n^2) behavior when traversing</code></span>
<span class="codeline" id="line-298"><code>	// backwards through strings with long sequences of</code></span>
<span class="codeline" id="line-299"><code>	// invalid UTF-8.</code></span>
<span class="codeline" id="line-300"><code>	lim := end - UTFMax</code></span>
<span class="codeline" id="line-301"><code>	if lim &lt; 0 {</code></span>
<span class="codeline" id="line-302"><code>		lim = 0</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code>	for start--; start &gt;= lim; start-- {</code></span>
<span class="codeline" id="line-305"><code>		if RuneStart(s[start]) {</code></span>
<span class="codeline" id="line-306"><code>			break</code></span>
<span class="codeline" id="line-307"><code>		}</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>	if start &lt; 0 {</code></span>
<span class="codeline" id="line-310"><code>		start = 0</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code>	r, size = DecodeRuneInString(s[start:end])</code></span>
<span class="codeline" id="line-313"><code>	if start+size != end {</code></span>
<span class="codeline" id="line-314"><code>		return RuneError, 1</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code>	return r, size</code></span>
<span class="codeline" id="line-317"><code>}</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>// RuneLen returns the number of bytes required to encode the rune.</code></span>
<span class="codeline" id="line-320"><code>// It returns -1 if the rune is not a valid value to encode in UTF-8.</code></span>
<span class="codeline" id="line-321"><code>func RuneLen(r rune) int {</code></span>
<span class="codeline" id="line-322"><code>	switch {</code></span>
<span class="codeline" id="line-323"><code>	case r &lt; 0:</code></span>
<span class="codeline" id="line-324"><code>		return -1</code></span>
<span class="codeline" id="line-325"><code>	case r &lt;= rune1Max:</code></span>
<span class="codeline" id="line-326"><code>		return 1</code></span>
<span class="codeline" id="line-327"><code>	case r &lt;= rune2Max:</code></span>
<span class="codeline" id="line-328"><code>		return 2</code></span>
<span class="codeline" id="line-329"><code>	case surrogateMin &lt;= r &amp;&amp; r &lt;= surrogateMax:</code></span>
<span class="codeline" id="line-330"><code>		return -1</code></span>
<span class="codeline" id="line-331"><code>	case r &lt;= rune3Max:</code></span>
<span class="codeline" id="line-332"><code>		return 3</code></span>
<span class="codeline" id="line-333"><code>	case r &lt;= MaxRune:</code></span>
<span class="codeline" id="line-334"><code>		return 4</code></span>
<span class="codeline" id="line-335"><code>	}</code></span>
<span class="codeline" id="line-336"><code>	return -1</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.</code></span>
<span class="codeline" id="line-340"><code>// If the rune is out of range, it writes the encoding of RuneError.</code></span>
<span class="codeline" id="line-341"><code>// It returns the number of bytes written.</code></span>
<span class="codeline" id="line-342"><code>func EncodeRune(p []byte, r rune) int {</code></span>
<span class="codeline" id="line-343"><code>	// Negative values are erroneous. Making it unsigned addresses the problem.</code></span>
<span class="codeline" id="line-344"><code>	switch i := uint32(r); {</code></span>
<span class="codeline" id="line-345"><code>	case i &lt;= rune1Max:</code></span>
<span class="codeline" id="line-346"><code>		p[0] = byte(r)</code></span>
<span class="codeline" id="line-347"><code>		return 1</code></span>
<span class="codeline" id="line-348"><code>	case i &lt;= rune2Max:</code></span>
<span class="codeline" id="line-349"><code>		_ = p[1] // eliminate bounds checks</code></span>
<span class="codeline" id="line-350"><code>		p[0] = t2 | byte(r&gt;&gt;6)</code></span>
<span class="codeline" id="line-351"><code>		p[1] = tx | byte(r)&amp;maskx</code></span>
<span class="codeline" id="line-352"><code>		return 2</code></span>
<span class="codeline" id="line-353"><code>	case i &gt; MaxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax:</code></span>
<span class="codeline" id="line-354"><code>		r = RuneError</code></span>
<span class="codeline" id="line-355"><code>		fallthrough</code></span>
<span class="codeline" id="line-356"><code>	case i &lt;= rune3Max:</code></span>
<span class="codeline" id="line-357"><code>		_ = p[2] // eliminate bounds checks</code></span>
<span class="codeline" id="line-358"><code>		p[0] = t3 | byte(r&gt;&gt;12)</code></span>
<span class="codeline" id="line-359"><code>		p[1] = tx | byte(r&gt;&gt;6)&amp;maskx</code></span>
<span class="codeline" id="line-360"><code>		p[2] = tx | byte(r)&amp;maskx</code></span>
<span class="codeline" id="line-361"><code>		return 3</code></span>
<span class="codeline" id="line-362"><code>	default:</code></span>
<span class="codeline" id="line-363"><code>		_ = p[3] // eliminate bounds checks</code></span>
<span class="codeline" id="line-364"><code>		p[0] = t4 | byte(r&gt;&gt;18)</code></span>
<span class="codeline" id="line-365"><code>		p[1] = tx | byte(r&gt;&gt;12)&amp;maskx</code></span>
<span class="codeline" id="line-366"><code>		p[2] = tx | byte(r&gt;&gt;6)&amp;maskx</code></span>
<span class="codeline" id="line-367"><code>		p[3] = tx | byte(r)&amp;maskx</code></span>
<span class="codeline" id="line-368"><code>		return 4</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>// RuneCount returns the number of runes in p. Erroneous and short</code></span>
<span class="codeline" id="line-373"><code>// encodings are treated as single runes of width 1 byte.</code></span>
<span class="codeline" id="line-374"><code>func RuneCount(p []byte) int {</code></span>
<span class="codeline" id="line-375"><code>	np := len(p)</code></span>
<span class="codeline" id="line-376"><code>	var n int</code></span>
<span class="codeline" id="line-377"><code>	for i := 0; i &lt; np; {</code></span>
<span class="codeline" id="line-378"><code>		n++</code></span>
<span class="codeline" id="line-379"><code>		c := p[i]</code></span>
<span class="codeline" id="line-380"><code>		if c &lt; RuneSelf {</code></span>
<span class="codeline" id="line-381"><code>			// ASCII fast path</code></span>
<span class="codeline" id="line-382"><code>			i++</code></span>
<span class="codeline" id="line-383"><code>			continue</code></span>
<span class="codeline" id="line-384"><code>		}</code></span>
<span class="codeline" id="line-385"><code>		x := first[c]</code></span>
<span class="codeline" id="line-386"><code>		if x == xx {</code></span>
<span class="codeline" id="line-387"><code>			i++ // invalid.</code></span>
<span class="codeline" id="line-388"><code>			continue</code></span>
<span class="codeline" id="line-389"><code>		}</code></span>
<span class="codeline" id="line-390"><code>		size := int(x &amp; 7)</code></span>
<span class="codeline" id="line-391"><code>		if i+size &gt; np {</code></span>
<span class="codeline" id="line-392"><code>			i++ // Short or invalid.</code></span>
<span class="codeline" id="line-393"><code>			continue</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code>		accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-396"><code>		if c := p[i+1]; c &lt; accept.lo || accept.hi &lt; c {</code></span>
<span class="codeline" id="line-397"><code>			size = 1</code></span>
<span class="codeline" id="line-398"><code>		} else if size == 2 {</code></span>
<span class="codeline" id="line-399"><code>		} else if c := p[i+2]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-400"><code>			size = 1</code></span>
<span class="codeline" id="line-401"><code>		} else if size == 3 {</code></span>
<span class="codeline" id="line-402"><code>		} else if c := p[i+3]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-403"><code>			size = 1</code></span>
<span class="codeline" id="line-404"><code>		}</code></span>
<span class="codeline" id="line-405"><code>		i += size</code></span>
<span class="codeline" id="line-406"><code>	}</code></span>
<span class="codeline" id="line-407"><code>	return n</code></span>
<span class="codeline" id="line-408"><code>}</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>// RuneCountInString is like RuneCount but its input is a string.</code></span>
<span class="codeline" id="line-411"><code>func RuneCountInString(s string) (n int) {</code></span>
<span class="codeline" id="line-412"><code>	ns := len(s)</code></span>
<span class="codeline" id="line-413"><code>	for i := 0; i &lt; ns; n++ {</code></span>
<span class="codeline" id="line-414"><code>		c := s[i]</code></span>
<span class="codeline" id="line-415"><code>		if c &lt; RuneSelf {</code></span>
<span class="codeline" id="line-416"><code>			// ASCII fast path</code></span>
<span class="codeline" id="line-417"><code>			i++</code></span>
<span class="codeline" id="line-418"><code>			continue</code></span>
<span class="codeline" id="line-419"><code>		}</code></span>
<span class="codeline" id="line-420"><code>		x := first[c]</code></span>
<span class="codeline" id="line-421"><code>		if x == xx {</code></span>
<span class="codeline" id="line-422"><code>			i++ // invalid.</code></span>
<span class="codeline" id="line-423"><code>			continue</code></span>
<span class="codeline" id="line-424"><code>		}</code></span>
<span class="codeline" id="line-425"><code>		size := int(x &amp; 7)</code></span>
<span class="codeline" id="line-426"><code>		if i+size &gt; ns {</code></span>
<span class="codeline" id="line-427"><code>			i++ // Short or invalid.</code></span>
<span class="codeline" id="line-428"><code>			continue</code></span>
<span class="codeline" id="line-429"><code>		}</code></span>
<span class="codeline" id="line-430"><code>		accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-431"><code>		if c := s[i+1]; c &lt; accept.lo || accept.hi &lt; c {</code></span>
<span class="codeline" id="line-432"><code>			size = 1</code></span>
<span class="codeline" id="line-433"><code>		} else if size == 2 {</code></span>
<span class="codeline" id="line-434"><code>		} else if c := s[i+2]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-435"><code>			size = 1</code></span>
<span class="codeline" id="line-436"><code>		} else if size == 3 {</code></span>
<span class="codeline" id="line-437"><code>		} else if c := s[i+3]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-438"><code>			size = 1</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>		i += size</code></span>
<span class="codeline" id="line-441"><code>	}</code></span>
<span class="codeline" id="line-442"><code>	return n</code></span>
<span class="codeline" id="line-443"><code>}</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>// RuneStart reports whether the byte could be the first byte of an encoded,</code></span>
<span class="codeline" id="line-446"><code>// possibly invalid rune. Second and subsequent bytes always have the top two</code></span>
<span class="codeline" id="line-447"><code>// bits set to 10.</code></span>
<span class="codeline" id="line-448"><code>func RuneStart(b byte) bool { return b&amp;0xC0 != 0x80 }</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>// Valid reports whether p consists entirely of valid UTF-8-encoded runes.</code></span>
<span class="codeline" id="line-451"><code>func Valid(p []byte) bool {</code></span>
<span class="codeline" id="line-452"><code>	// Fast path. Check for and skip 8 bytes of ASCII characters per iteration.</code></span>
<span class="codeline" id="line-453"><code>	for len(p) &gt;= 8 {</code></span>
<span class="codeline" id="line-454"><code>		// Combining two 32 bit loads allows the same code to be used</code></span>
<span class="codeline" id="line-455"><code>		// for 32 and 64 bit platforms.</code></span>
<span class="codeline" id="line-456"><code>		// The compiler can generate a 32bit load for first32 and second32</code></span>
<span class="codeline" id="line-457"><code>		// on many platforms. See test/codegen/memcombine.go.</code></span>
<span class="codeline" id="line-458"><code>		first32 := uint32(p[0]) | uint32(p[1])&lt;&lt;8 | uint32(p[2])&lt;&lt;16 | uint32(p[3])&lt;&lt;24</code></span>
<span class="codeline" id="line-459"><code>		second32 := uint32(p[4]) | uint32(p[5])&lt;&lt;8 | uint32(p[6])&lt;&lt;16 | uint32(p[7])&lt;&lt;24</code></span>
<span class="codeline" id="line-460"><code>		if (first32|second32)&amp;0x80808080 != 0 {</code></span>
<span class="codeline" id="line-461"><code>			// Found a non ASCII byte (&gt;= RuneSelf).</code></span>
<span class="codeline" id="line-462"><code>			break</code></span>
<span class="codeline" id="line-463"><code>		}</code></span>
<span class="codeline" id="line-464"><code>		p = p[8:]</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code>	n := len(p)</code></span>
<span class="codeline" id="line-467"><code>	for i := 0; i &lt; n; {</code></span>
<span class="codeline" id="line-468"><code>		pi := p[i]</code></span>
<span class="codeline" id="line-469"><code>		if pi &lt; RuneSelf {</code></span>
<span class="codeline" id="line-470"><code>			i++</code></span>
<span class="codeline" id="line-471"><code>			continue</code></span>
<span class="codeline" id="line-472"><code>		}</code></span>
<span class="codeline" id="line-473"><code>		x := first[pi]</code></span>
<span class="codeline" id="line-474"><code>		if x == xx {</code></span>
<span class="codeline" id="line-475"><code>			return false // Illegal starter byte.</code></span>
<span class="codeline" id="line-476"><code>		}</code></span>
<span class="codeline" id="line-477"><code>		size := int(x &amp; 7)</code></span>
<span class="codeline" id="line-478"><code>		if i+size &gt; n {</code></span>
<span class="codeline" id="line-479"><code>			return false // Short or invalid.</code></span>
<span class="codeline" id="line-480"><code>		}</code></span>
<span class="codeline" id="line-481"><code>		accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-482"><code>		if c := p[i+1]; c &lt; accept.lo || accept.hi &lt; c {</code></span>
<span class="codeline" id="line-483"><code>			return false</code></span>
<span class="codeline" id="line-484"><code>		} else if size == 2 {</code></span>
<span class="codeline" id="line-485"><code>		} else if c := p[i+2]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-486"><code>			return false</code></span>
<span class="codeline" id="line-487"><code>		} else if size == 3 {</code></span>
<span class="codeline" id="line-488"><code>		} else if c := p[i+3]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-489"><code>			return false</code></span>
<span class="codeline" id="line-490"><code>		}</code></span>
<span class="codeline" id="line-491"><code>		i += size</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code>	return true</code></span>
<span class="codeline" id="line-494"><code>}</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>// ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</code></span>
<span class="codeline" id="line-497"><code>func ValidString(s string) bool {</code></span>
<span class="codeline" id="line-498"><code>	// Fast path. Check for and skip 8 bytes of ASCII characters per iteration.</code></span>
<span class="codeline" id="line-499"><code>	for len(s) &gt;= 8 {</code></span>
<span class="codeline" id="line-500"><code>		// Combining two 32 bit loads allows the same code to be used</code></span>
<span class="codeline" id="line-501"><code>		// for 32 and 64 bit platforms.</code></span>
<span class="codeline" id="line-502"><code>		// The compiler can generate a 32bit load for first32 and second32</code></span>
<span class="codeline" id="line-503"><code>		// on many platforms. See test/codegen/memcombine.go.</code></span>
<span class="codeline" id="line-504"><code>		first32 := uint32(s[0]) | uint32(s[1])&lt;&lt;8 | uint32(s[2])&lt;&lt;16 | uint32(s[3])&lt;&lt;24</code></span>
<span class="codeline" id="line-505"><code>		second32 := uint32(s[4]) | uint32(s[5])&lt;&lt;8 | uint32(s[6])&lt;&lt;16 | uint32(s[7])&lt;&lt;24</code></span>
<span class="codeline" id="line-506"><code>		if (first32|second32)&amp;0x80808080 != 0 {</code></span>
<span class="codeline" id="line-507"><code>			// Found a non ASCII byte (&gt;= RuneSelf).</code></span>
<span class="codeline" id="line-508"><code>			break</code></span>
<span class="codeline" id="line-509"><code>		}</code></span>
<span class="codeline" id="line-510"><code>		s = s[8:]</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code>	n := len(s)</code></span>
<span class="codeline" id="line-513"><code>	for i := 0; i &lt; n; {</code></span>
<span class="codeline" id="line-514"><code>		si := s[i]</code></span>
<span class="codeline" id="line-515"><code>		if si &lt; RuneSelf {</code></span>
<span class="codeline" id="line-516"><code>			i++</code></span>
<span class="codeline" id="line-517"><code>			continue</code></span>
<span class="codeline" id="line-518"><code>		}</code></span>
<span class="codeline" id="line-519"><code>		x := first[si]</code></span>
<span class="codeline" id="line-520"><code>		if x == xx {</code></span>
<span class="codeline" id="line-521"><code>			return false // Illegal starter byte.</code></span>
<span class="codeline" id="line-522"><code>		}</code></span>
<span class="codeline" id="line-523"><code>		size := int(x &amp; 7)</code></span>
<span class="codeline" id="line-524"><code>		if i+size &gt; n {</code></span>
<span class="codeline" id="line-525"><code>			return false // Short or invalid.</code></span>
<span class="codeline" id="line-526"><code>		}</code></span>
<span class="codeline" id="line-527"><code>		accept := acceptRanges[x&gt;&gt;4]</code></span>
<span class="codeline" id="line-528"><code>		if c := s[i+1]; c &lt; accept.lo || accept.hi &lt; c {</code></span>
<span class="codeline" id="line-529"><code>			return false</code></span>
<span class="codeline" id="line-530"><code>		} else if size == 2 {</code></span>
<span class="codeline" id="line-531"><code>		} else if c := s[i+2]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-532"><code>			return false</code></span>
<span class="codeline" id="line-533"><code>		} else if size == 3 {</code></span>
<span class="codeline" id="line-534"><code>		} else if c := s[i+3]; c &lt; locb || hicb &lt; c {</code></span>
<span class="codeline" id="line-535"><code>			return false</code></span>
<span class="codeline" id="line-536"><code>		}</code></span>
<span class="codeline" id="line-537"><code>		i += size</code></span>
<span class="codeline" id="line-538"><code>	}</code></span>
<span class="codeline" id="line-539"><code>	return true</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>// ValidRune reports whether r can be legally encoded as UTF-8.</code></span>
<span class="codeline" id="line-543"><code>// Code points that are out of range or a surrogate half are illegal.</code></span>
<span class="codeline" id="line-544"><code>func ValidRune(r rune) bool {</code></span>
<span class="codeline" id="line-545"><code>	switch {</code></span>
<span class="codeline" id="line-546"><code>	case 0 &lt;= r &amp;&amp; r &lt; surrogateMin:</code></span>
<span class="codeline" id="line-547"><code>		return true</code></span>
<span class="codeline" id="line-548"><code>	case surrogateMax &lt; r &amp;&amp; r &lt;= MaxRune:</code></span>
<span class="codeline" id="line-549"><code>		return true</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code>	return false</code></span>
<span class="codeline" id="line-552"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>