<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: bufio.go in package bufio</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	bufio.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/bufio.html">bufio</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</code></span>
<span class="codeline" id="line-6"><code>// object, creating another object (Reader or Writer) that also implements</code></span>
<span class="codeline" id="line-7"><code>// the interface but provides buffering and some help for textual I/O.</code></span></div><span class="codeline" id="line-8"><code>package bufio</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"bytes"</code></span>
<span class="codeline" id="line-12"><code>	"errors"</code></span>
<span class="codeline" id="line-13"><code>	"io"</code></span>
<span class="codeline" id="line-14"><code>	"strings"</code></span>
<span class="codeline" id="line-15"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>const (</code></span>
<span class="codeline" id="line-19"><code>	defaultBufSize = 4096</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>var (</code></span>
<span class="codeline" id="line-23"><code>	ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")</code></span>
<span class="codeline" id="line-24"><code>	ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")</code></span>
<span class="codeline" id="line-25"><code>	ErrBufferFull        = errors.New("bufio: buffer full")</code></span>
<span class="codeline" id="line-26"><code>	ErrNegativeCount     = errors.New("bufio: negative count")</code></span>
<span class="codeline" id="line-27"><code>)</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// Buffered input.</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// Reader implements buffering for an io.Reader object.</code></span>
<span class="codeline" id="line-32"><code>type Reader struct {</code></span>
<span class="codeline" id="line-33"><code>	buf          []byte</code></span>
<span class="codeline" id="line-34"><code>	rd           io.Reader // reader provided by the client</code></span>
<span class="codeline" id="line-35"><code>	r, w         int       // buf read and write positions</code></span>
<span class="codeline" id="line-36"><code>	err          error</code></span>
<span class="codeline" id="line-37"><code>	lastByte     int // last byte read for UnreadByte; -1 means invalid</code></span>
<span class="codeline" id="line-38"><code>	lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid</code></span>
<span class="codeline" id="line-39"><code>}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>const minReadBufferSize = 16</code></span>
<span class="codeline" id="line-42"><code>const maxConsecutiveEmptyReads = 100</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>// NewReaderSize returns a new Reader whose buffer has at least the specified</code></span>
<span class="codeline" id="line-45"><code>// size. If the argument io.Reader is already a Reader with large enough</code></span>
<span class="codeline" id="line-46"><code>// size, it returns the underlying Reader.</code></span>
<span class="codeline" id="line-47"><code>func NewReaderSize(rd io.Reader, size int) *Reader {</code></span>
<span class="codeline" id="line-48"><code>	// Is it already a Reader?</code></span>
<span class="codeline" id="line-49"><code>	b, ok := rd.(*Reader)</code></span>
<span class="codeline" id="line-50"><code>	if ok &amp;&amp; len(b.buf) &gt;= size {</code></span>
<span class="codeline" id="line-51"><code>		return b</code></span>
<span class="codeline" id="line-52"><code>	}</code></span>
<span class="codeline" id="line-53"><code>	if size &lt; minReadBufferSize {</code></span>
<span class="codeline" id="line-54"><code>		size = minReadBufferSize</code></span>
<span class="codeline" id="line-55"><code>	}</code></span>
<span class="codeline" id="line-56"><code>	r := new(Reader)</code></span>
<span class="codeline" id="line-57"><code>	r.reset(make([]byte, size), rd)</code></span>
<span class="codeline" id="line-58"><code>	return r</code></span>
<span class="codeline" id="line-59"><code>}</code></span>
<span class="codeline" id="line-60"><code></code></span>
<span class="codeline" id="line-61"><code>// NewReader returns a new Reader whose buffer has the default size.</code></span>
<span class="codeline" id="line-62"><code>func NewReader(rd io.Reader) *Reader {</code></span>
<span class="codeline" id="line-63"><code>	return NewReaderSize(rd, defaultBufSize)</code></span>
<span class="codeline" id="line-64"><code>}</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// Size returns the size of the underlying buffer in bytes.</code></span>
<span class="codeline" id="line-67"><code>func (b *Reader) Size() int { return len(b.buf) }</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>// Reset discards any buffered data, resets all state, and switches</code></span>
<span class="codeline" id="line-70"><code>// the buffered reader to read from r.</code></span>
<span class="codeline" id="line-71"><code>func (b *Reader) Reset(r io.Reader) {</code></span>
<span class="codeline" id="line-72"><code>	b.reset(b.buf, r)</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>func (b *Reader) reset(buf []byte, r io.Reader) {</code></span>
<span class="codeline" id="line-76"><code>	*b = Reader{</code></span>
<span class="codeline" id="line-77"><code>		buf:          buf,</code></span>
<span class="codeline" id="line-78"><code>		rd:           r,</code></span>
<span class="codeline" id="line-79"><code>		lastByte:     -1,</code></span>
<span class="codeline" id="line-80"><code>		lastRuneSize: -1,</code></span>
<span class="codeline" id="line-81"><code>	}</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>var errNegativeRead = errors.New("bufio: reader returned negative count from Read")</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>// fill reads a new chunk into the buffer.</code></span>
<span class="codeline" id="line-87"><code>func (b *Reader) fill() {</code></span>
<span class="codeline" id="line-88"><code>	// Slide existing data to beginning.</code></span>
<span class="codeline" id="line-89"><code>	if b.r &gt; 0 {</code></span>
<span class="codeline" id="line-90"><code>		copy(b.buf, b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-91"><code>		b.w -= b.r</code></span>
<span class="codeline" id="line-92"><code>		b.r = 0</code></span>
<span class="codeline" id="line-93"><code>	}</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>	if b.w &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-96"><code>		panic("bufio: tried to fill full buffer")</code></span>
<span class="codeline" id="line-97"><code>	}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>	// Read new data: try a limited number of times.</code></span>
<span class="codeline" id="line-100"><code>	for i := maxConsecutiveEmptyReads; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-101"><code>		n, err := b.rd.Read(b.buf[b.w:])</code></span>
<span class="codeline" id="line-102"><code>		if n &lt; 0 {</code></span>
<span class="codeline" id="line-103"><code>			panic(errNegativeRead)</code></span>
<span class="codeline" id="line-104"><code>		}</code></span>
<span class="codeline" id="line-105"><code>		b.w += n</code></span>
<span class="codeline" id="line-106"><code>		if err != nil {</code></span>
<span class="codeline" id="line-107"><code>			b.err = err</code></span>
<span class="codeline" id="line-108"><code>			return</code></span>
<span class="codeline" id="line-109"><code>		}</code></span>
<span class="codeline" id="line-110"><code>		if n &gt; 0 {</code></span>
<span class="codeline" id="line-111"><code>			return</code></span>
<span class="codeline" id="line-112"><code>		}</code></span>
<span class="codeline" id="line-113"><code>	}</code></span>
<span class="codeline" id="line-114"><code>	b.err = io.ErrNoProgress</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>func (b *Reader) readErr() error {</code></span>
<span class="codeline" id="line-118"><code>	err := b.err</code></span>
<span class="codeline" id="line-119"><code>	b.err = nil</code></span>
<span class="codeline" id="line-120"><code>	return err</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// Peek returns the next n bytes without advancing the reader. The bytes stop</code></span>
<span class="codeline" id="line-124"><code>// being valid at the next read call. If Peek returns fewer than n bytes, it</code></span>
<span class="codeline" id="line-125"><code>// also returns an error explaining why the read is short. The error is</code></span>
<span class="codeline" id="line-126"><code>// ErrBufferFull if n is larger than b's buffer size.</code></span>
<span class="codeline" id="line-127"><code>//</code></span>
<span class="codeline" id="line-128"><code>// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</code></span>
<span class="codeline" id="line-129"><code>// until the next read operation.</code></span>
<span class="codeline" id="line-130"><code>func (b *Reader) Peek(n int) ([]byte, error) {</code></span>
<span class="codeline" id="line-131"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-132"><code>		return nil, ErrNegativeCount</code></span>
<span class="codeline" id="line-133"><code>	}</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-136"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>	for b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; len(b.buf) &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-139"><code>		b.fill() // b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</code></span>
<span class="codeline" id="line-140"><code>	}</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	if n &gt; len(b.buf) {</code></span>
<span class="codeline" id="line-143"><code>		return b.buf[b.r:b.w], ErrBufferFull</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	// 0 &lt;= n &lt;= len(b.buf)</code></span>
<span class="codeline" id="line-147"><code>	var err error</code></span>
<span class="codeline" id="line-148"><code>	if avail := b.w - b.r; avail &lt; n {</code></span>
<span class="codeline" id="line-149"><code>		// not enough data in buffer</code></span>
<span class="codeline" id="line-150"><code>		n = avail</code></span>
<span class="codeline" id="line-151"><code>		err = b.readErr()</code></span>
<span class="codeline" id="line-152"><code>		if err == nil {</code></span>
<span class="codeline" id="line-153"><code>			err = ErrBufferFull</code></span>
<span class="codeline" id="line-154"><code>		}</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>	return b.buf[b.r : b.r+n], err</code></span>
<span class="codeline" id="line-157"><code>}</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>// Discard skips the next n bytes, returning the number of bytes discarded.</code></span>
<span class="codeline" id="line-160"><code>//</code></span>
<span class="codeline" id="line-161"><code>// If Discard skips fewer than n bytes, it also returns an error.</code></span>
<span class="codeline" id="line-162"><code>// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</code></span>
<span class="codeline" id="line-163"><code>// reading from the underlying io.Reader.</code></span>
<span class="codeline" id="line-164"><code>func (b *Reader) Discard(n int) (discarded int, err error) {</code></span>
<span class="codeline" id="line-165"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-166"><code>		return 0, ErrNegativeCount</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-169"><code>		return</code></span>
<span class="codeline" id="line-170"><code>	}</code></span>
<span class="codeline" id="line-171"><code>	remain := n</code></span>
<span class="codeline" id="line-172"><code>	for {</code></span>
<span class="codeline" id="line-173"><code>		skip := b.Buffered()</code></span>
<span class="codeline" id="line-174"><code>		if skip == 0 {</code></span>
<span class="codeline" id="line-175"><code>			b.fill()</code></span>
<span class="codeline" id="line-176"><code>			skip = b.Buffered()</code></span>
<span class="codeline" id="line-177"><code>		}</code></span>
<span class="codeline" id="line-178"><code>		if skip &gt; remain {</code></span>
<span class="codeline" id="line-179"><code>			skip = remain</code></span>
<span class="codeline" id="line-180"><code>		}</code></span>
<span class="codeline" id="line-181"><code>		b.r += skip</code></span>
<span class="codeline" id="line-182"><code>		remain -= skip</code></span>
<span class="codeline" id="line-183"><code>		if remain == 0 {</code></span>
<span class="codeline" id="line-184"><code>			return n, nil</code></span>
<span class="codeline" id="line-185"><code>		}</code></span>
<span class="codeline" id="line-186"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-187"><code>			return n - remain, b.readErr()</code></span>
<span class="codeline" id="line-188"><code>		}</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>// Read reads data into p.</code></span>
<span class="codeline" id="line-193"><code>// It returns the number of bytes read into p.</code></span>
<span class="codeline" id="line-194"><code>// The bytes are taken from at most one Read on the underlying Reader,</code></span>
<span class="codeline" id="line-195"><code>// hence n may be less than len(p).</code></span>
<span class="codeline" id="line-196"><code>// To read exactly len(p) bytes, use io.ReadFull(b, p).</code></span>
<span class="codeline" id="line-197"><code>// At EOF, the count will be zero and err will be io.EOF.</code></span>
<span class="codeline" id="line-198"><code>func (b *Reader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-199"><code>	n = len(p)</code></span>
<span class="codeline" id="line-200"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-201"><code>		if b.Buffered() &gt; 0 {</code></span>
<span class="codeline" id="line-202"><code>			return 0, nil</code></span>
<span class="codeline" id="line-203"><code>		}</code></span>
<span class="codeline" id="line-204"><code>		return 0, b.readErr()</code></span>
<span class="codeline" id="line-205"><code>	}</code></span>
<span class="codeline" id="line-206"><code>	if b.r == b.w {</code></span>
<span class="codeline" id="line-207"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-208"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-209"><code>		}</code></span>
<span class="codeline" id="line-210"><code>		if len(p) &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-211"><code>			// Large read, empty buffer.</code></span>
<span class="codeline" id="line-212"><code>			// Read directly into p to avoid copy.</code></span>
<span class="codeline" id="line-213"><code>			n, b.err = b.rd.Read(p)</code></span>
<span class="codeline" id="line-214"><code>			if n &lt; 0 {</code></span>
<span class="codeline" id="line-215"><code>				panic(errNegativeRead)</code></span>
<span class="codeline" id="line-216"><code>			}</code></span>
<span class="codeline" id="line-217"><code>			if n &gt; 0 {</code></span>
<span class="codeline" id="line-218"><code>				b.lastByte = int(p[n-1])</code></span>
<span class="codeline" id="line-219"><code>				b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-220"><code>			}</code></span>
<span class="codeline" id="line-221"><code>			return n, b.readErr()</code></span>
<span class="codeline" id="line-222"><code>		}</code></span>
<span class="codeline" id="line-223"><code>		// One read.</code></span>
<span class="codeline" id="line-224"><code>		// Do not use b.fill, which will loop.</code></span>
<span class="codeline" id="line-225"><code>		b.r = 0</code></span>
<span class="codeline" id="line-226"><code>		b.w = 0</code></span>
<span class="codeline" id="line-227"><code>		n, b.err = b.rd.Read(b.buf)</code></span>
<span class="codeline" id="line-228"><code>		if n &lt; 0 {</code></span>
<span class="codeline" id="line-229"><code>			panic(errNegativeRead)</code></span>
<span class="codeline" id="line-230"><code>		}</code></span>
<span class="codeline" id="line-231"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-232"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-233"><code>		}</code></span>
<span class="codeline" id="line-234"><code>		b.w += n</code></span>
<span class="codeline" id="line-235"><code>	}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>	// copy as much as we can</code></span>
<span class="codeline" id="line-238"><code>	n = copy(p, b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-239"><code>	b.r += n</code></span>
<span class="codeline" id="line-240"><code>	b.lastByte = int(b.buf[b.r-1])</code></span>
<span class="codeline" id="line-241"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-242"><code>	return n, nil</code></span>
<span class="codeline" id="line-243"><code>}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>// ReadByte reads and returns a single byte.</code></span>
<span class="codeline" id="line-246"><code>// If no byte is available, returns an error.</code></span>
<span class="codeline" id="line-247"><code>func (b *Reader) ReadByte() (byte, error) {</code></span>
<span class="codeline" id="line-248"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-249"><code>	for b.r == b.w {</code></span>
<span class="codeline" id="line-250"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-251"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-252"><code>		}</code></span>
<span class="codeline" id="line-253"><code>		b.fill() // buffer is empty</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code>	c := b.buf[b.r]</code></span>
<span class="codeline" id="line-256"><code>	b.r++</code></span>
<span class="codeline" id="line-257"><code>	b.lastByte = int(c)</code></span>
<span class="codeline" id="line-258"><code>	return c, nil</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</code></span>
<span class="codeline" id="line-262"><code>//</code></span>
<span class="codeline" id="line-263"><code>// UnreadByte returns an error if the most recent method called on the</code></span>
<span class="codeline" id="line-264"><code>// Reader was not a read operation. Notably, Peek is not considered a</code></span>
<span class="codeline" id="line-265"><code>// read operation.</code></span>
<span class="codeline" id="line-266"><code>func (b *Reader) UnreadByte() error {</code></span>
<span class="codeline" id="line-267"><code>	if b.lastByte &lt; 0 || b.r == 0 &amp;&amp; b.w &gt; 0 {</code></span>
<span class="codeline" id="line-268"><code>		return ErrInvalidUnreadByte</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	// b.r &gt; 0 || b.w == 0</code></span>
<span class="codeline" id="line-271"><code>	if b.r &gt; 0 {</code></span>
<span class="codeline" id="line-272"><code>		b.r--</code></span>
<span class="codeline" id="line-273"><code>	} else {</code></span>
<span class="codeline" id="line-274"><code>		// b.r == 0 &amp;&amp; b.w == 0</code></span>
<span class="codeline" id="line-275"><code>		b.w = 1</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code>	b.buf[b.r] = byte(b.lastByte)</code></span>
<span class="codeline" id="line-278"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-279"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-280"><code>	return nil</code></span>
<span class="codeline" id="line-281"><code>}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>// ReadRune reads a single UTF-8 encoded Unicode character and returns the</code></span>
<span class="codeline" id="line-284"><code>// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</code></span>
<span class="codeline" id="line-285"><code>// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</code></span>
<span class="codeline" id="line-286"><code>func (b *Reader) ReadRune() (r rune, size int, err error) {</code></span>
<span class="codeline" id="line-287"><code>	for b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == nil &amp;&amp; b.w-b.r &lt; len(b.buf) {</code></span>
<span class="codeline" id="line-288"><code>		b.fill() // b.w-b.r &lt; len(buf) =&gt; buffer is not full</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-291"><code>	if b.r == b.w {</code></span>
<span class="codeline" id="line-292"><code>		return 0, 0, b.readErr()</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	r, size = rune(b.buf[b.r]), 1</code></span>
<span class="codeline" id="line-295"><code>	if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-296"><code>		r, size = utf8.DecodeRune(b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>	b.r += size</code></span>
<span class="codeline" id="line-299"><code>	b.lastByte = int(b.buf[b.r-1])</code></span>
<span class="codeline" id="line-300"><code>	b.lastRuneSize = size</code></span>
<span class="codeline" id="line-301"><code>	return r, size, nil</code></span>
<span class="codeline" id="line-302"><code>}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>// UnreadRune unreads the last rune. If the most recent method called on</code></span>
<span class="codeline" id="line-305"><code>// the Reader was not a ReadRune, UnreadRune returns an error. (In this</code></span>
<span class="codeline" id="line-306"><code>// regard it is stricter than UnreadByte, which will unread the last byte</code></span>
<span class="codeline" id="line-307"><code>// from any read operation.)</code></span>
<span class="codeline" id="line-308"><code>func (b *Reader) UnreadRune() error {</code></span>
<span class="codeline" id="line-309"><code>	if b.lastRuneSize &lt; 0 || b.r &lt; b.lastRuneSize {</code></span>
<span class="codeline" id="line-310"><code>		return ErrInvalidUnreadRune</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code>	b.r -= b.lastRuneSize</code></span>
<span class="codeline" id="line-313"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-314"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-315"><code>	return nil</code></span>
<span class="codeline" id="line-316"><code>}</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>// Buffered returns the number of bytes that can be read from the current buffer.</code></span>
<span class="codeline" id="line-319"><code>func (b *Reader) Buffered() int { return b.w - b.r }</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>// ReadSlice reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-322"><code>// returning a slice pointing at the bytes in the buffer.</code></span>
<span class="codeline" id="line-323"><code>// The bytes stop being valid at the next read.</code></span>
<span class="codeline" id="line-324"><code>// If ReadSlice encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-325"><code>// it returns all the data in the buffer and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-326"><code>// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</code></span>
<span class="codeline" id="line-327"><code>// Because the data returned from ReadSlice will be overwritten</code></span>
<span class="codeline" id="line-328"><code>// by the next I/O operation, most clients should use</code></span>
<span class="codeline" id="line-329"><code>// ReadBytes or ReadString instead.</code></span>
<span class="codeline" id="line-330"><code>// ReadSlice returns err != nil if and only if line does not end in delim.</code></span>
<span class="codeline" id="line-331"><code>func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {</code></span>
<span class="codeline" id="line-332"><code>	s := 0 // search start index</code></span>
<span class="codeline" id="line-333"><code>	for {</code></span>
<span class="codeline" id="line-334"><code>		// Search buffer.</code></span>
<span class="codeline" id="line-335"><code>		if i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= 0 {</code></span>
<span class="codeline" id="line-336"><code>			i += s</code></span>
<span class="codeline" id="line-337"><code>			line = b.buf[b.r : b.r+i+1]</code></span>
<span class="codeline" id="line-338"><code>			b.r += i + 1</code></span>
<span class="codeline" id="line-339"><code>			break</code></span>
<span class="codeline" id="line-340"><code>		}</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>		// Pending error?</code></span>
<span class="codeline" id="line-343"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-344"><code>			line = b.buf[b.r:b.w]</code></span>
<span class="codeline" id="line-345"><code>			b.r = b.w</code></span>
<span class="codeline" id="line-346"><code>			err = b.readErr()</code></span>
<span class="codeline" id="line-347"><code>			break</code></span>
<span class="codeline" id="line-348"><code>		}</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>		// Buffer full?</code></span>
<span class="codeline" id="line-351"><code>		if b.Buffered() &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-352"><code>			b.r = b.w</code></span>
<span class="codeline" id="line-353"><code>			line = b.buf</code></span>
<span class="codeline" id="line-354"><code>			err = ErrBufferFull</code></span>
<span class="codeline" id="line-355"><code>			break</code></span>
<span class="codeline" id="line-356"><code>		}</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>		s = b.w - b.r // do not rescan area we scanned before</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>		b.fill() // buffer is not full</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>	// Handle last byte, if any.</code></span>
<span class="codeline" id="line-364"><code>	if i := len(line) - 1; i &gt;= 0 {</code></span>
<span class="codeline" id="line-365"><code>		b.lastByte = int(line[i])</code></span>
<span class="codeline" id="line-366"><code>		b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-367"><code>	}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>	return</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>// ReadLine is a low-level line-reading primitive. Most callers should use</code></span>
<span class="codeline" id="line-373"><code>// ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</code></span>
<span class="codeline" id="line-374"><code>//</code></span>
<span class="codeline" id="line-375"><code>// ReadLine tries to return a single line, not including the end-of-line bytes.</code></span>
<span class="codeline" id="line-376"><code>// If the line was too long for the buffer then isPrefix is set and the</code></span>
<span class="codeline" id="line-377"><code>// beginning of the line is returned. The rest of the line will be returned</code></span>
<span class="codeline" id="line-378"><code>// from future calls. isPrefix will be false when returning the last fragment</code></span>
<span class="codeline" id="line-379"><code>// of the line. The returned buffer is only valid until the next call to</code></span>
<span class="codeline" id="line-380"><code>// ReadLine. ReadLine either returns a non-nil line or it returns an error,</code></span>
<span class="codeline" id="line-381"><code>// never both.</code></span>
<span class="codeline" id="line-382"><code>//</code></span>
<span class="codeline" id="line-383"><code>// The text returned from ReadLine does not include the line end ("\r\n" or "\n").</code></span>
<span class="codeline" id="line-384"><code>// No indication or error is given if the input ends without a final line end.</code></span>
<span class="codeline" id="line-385"><code>// Calling UnreadByte after ReadLine will always unread the last byte read</code></span>
<span class="codeline" id="line-386"><code>// (possibly a character belonging to the line end) even if that byte is not</code></span>
<span class="codeline" id="line-387"><code>// part of the line returned by ReadLine.</code></span>
<span class="codeline" id="line-388"><code>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {</code></span>
<span class="codeline" id="line-389"><code>	line, err = b.ReadSlice('\n')</code></span>
<span class="codeline" id="line-390"><code>	if err == ErrBufferFull {</code></span>
<span class="codeline" id="line-391"><code>		// Handle the case where "\r\n" straddles the buffer.</code></span>
<span class="codeline" id="line-392"><code>		if len(line) &gt; 0 &amp;&amp; line[len(line)-1] == '\r' {</code></span>
<span class="codeline" id="line-393"><code>			// Put the '\r' back on buf and drop it from line.</code></span>
<span class="codeline" id="line-394"><code>			// Let the next call to ReadLine check for "\r\n".</code></span>
<span class="codeline" id="line-395"><code>			if b.r == 0 {</code></span>
<span class="codeline" id="line-396"><code>				// should be unreachable</code></span>
<span class="codeline" id="line-397"><code>				panic("bufio: tried to rewind past start of buffer")</code></span>
<span class="codeline" id="line-398"><code>			}</code></span>
<span class="codeline" id="line-399"><code>			b.r--</code></span>
<span class="codeline" id="line-400"><code>			line = line[:len(line)-1]</code></span>
<span class="codeline" id="line-401"><code>		}</code></span>
<span class="codeline" id="line-402"><code>		return line, true, nil</code></span>
<span class="codeline" id="line-403"><code>	}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>	if len(line) == 0 {</code></span>
<span class="codeline" id="line-406"><code>		if err != nil {</code></span>
<span class="codeline" id="line-407"><code>			line = nil</code></span>
<span class="codeline" id="line-408"><code>		}</code></span>
<span class="codeline" id="line-409"><code>		return</code></span>
<span class="codeline" id="line-410"><code>	}</code></span>
<span class="codeline" id="line-411"><code>	err = nil</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	if line[len(line)-1] == '\n' {</code></span>
<span class="codeline" id="line-414"><code>		drop := 1</code></span>
<span class="codeline" id="line-415"><code>		if len(line) &gt; 1 &amp;&amp; line[len(line)-2] == '\r' {</code></span>
<span class="codeline" id="line-416"><code>			drop = 2</code></span>
<span class="codeline" id="line-417"><code>		}</code></span>
<span class="codeline" id="line-418"><code>		line = line[:len(line)-drop]</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code>	return</code></span>
<span class="codeline" id="line-421"><code>}</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>// collectFragments reads until the first occurrence of delim in the input. It</code></span>
<span class="codeline" id="line-424"><code>// returns (slice of full buffers, remaining bytes before delim, total number</code></span>
<span class="codeline" id="line-425"><code>// of bytes in the combined first two elements, error).</code></span>
<span class="codeline" id="line-426"><code>// The complete result is equal to</code></span>
<span class="codeline" id="line-427"><code>// `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a</code></span>
<span class="codeline" id="line-428"><code>// length of `totalLen`. The result is structured in this way to allow callers</code></span>
<span class="codeline" id="line-429"><code>// to minimize allocations and copies.</code></span>
<span class="codeline" id="line-430"><code>func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error) {</code></span>
<span class="codeline" id="line-431"><code>	var frag []byte</code></span>
<span class="codeline" id="line-432"><code>	// Use ReadSlice to look for delim, accumulating full buffers.</code></span>
<span class="codeline" id="line-433"><code>	for {</code></span>
<span class="codeline" id="line-434"><code>		var e error</code></span>
<span class="codeline" id="line-435"><code>		frag, e = b.ReadSlice(delim)</code></span>
<span class="codeline" id="line-436"><code>		if e == nil { // got final fragment</code></span>
<span class="codeline" id="line-437"><code>			break</code></span>
<span class="codeline" id="line-438"><code>		}</code></span>
<span class="codeline" id="line-439"><code>		if e != ErrBufferFull { // unexpected error</code></span>
<span class="codeline" id="line-440"><code>			err = e</code></span>
<span class="codeline" id="line-441"><code>			break</code></span>
<span class="codeline" id="line-442"><code>		}</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>		// Make a copy of the buffer.</code></span>
<span class="codeline" id="line-445"><code>		buf := make([]byte, len(frag))</code></span>
<span class="codeline" id="line-446"><code>		copy(buf, frag)</code></span>
<span class="codeline" id="line-447"><code>		fullBuffers = append(fullBuffers, buf)</code></span>
<span class="codeline" id="line-448"><code>		totalLen += len(buf)</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>	totalLen += len(frag)</code></span>
<span class="codeline" id="line-452"><code>	return fullBuffers, frag, totalLen, err</code></span>
<span class="codeline" id="line-453"><code>}</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>// ReadBytes reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-456"><code>// returning a slice containing the data up to and including the delimiter.</code></span>
<span class="codeline" id="line-457"><code>// If ReadBytes encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-458"><code>// it returns the data read before the error and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-459"><code>// ReadBytes returns err != nil if and only if the returned data does not end in</code></span>
<span class="codeline" id="line-460"><code>// delim.</code></span>
<span class="codeline" id="line-461"><code>// For simple uses, a Scanner may be more convenient.</code></span>
<span class="codeline" id="line-462"><code>func (b *Reader) ReadBytes(delim byte) ([]byte, error) {</code></span>
<span class="codeline" id="line-463"><code>	full, frag, n, err := b.collectFragments(delim)</code></span>
<span class="codeline" id="line-464"><code>	// Allocate new buffer to hold the full pieces and the fragment.</code></span>
<span class="codeline" id="line-465"><code>	buf := make([]byte, n)</code></span>
<span class="codeline" id="line-466"><code>	n = 0</code></span>
<span class="codeline" id="line-467"><code>	// Copy full pieces and fragment in.</code></span>
<span class="codeline" id="line-468"><code>	for i := range full {</code></span>
<span class="codeline" id="line-469"><code>		n += copy(buf[n:], full[i])</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code>	copy(buf[n:], frag)</code></span>
<span class="codeline" id="line-472"><code>	return buf, err</code></span>
<span class="codeline" id="line-473"><code>}</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>// ReadString reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-476"><code>// returning a string containing the data up to and including the delimiter.</code></span>
<span class="codeline" id="line-477"><code>// If ReadString encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-478"><code>// it returns the data read before the error and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-479"><code>// ReadString returns err != nil if and only if the returned data does not end in</code></span>
<span class="codeline" id="line-480"><code>// delim.</code></span>
<span class="codeline" id="line-481"><code>// For simple uses, a Scanner may be more convenient.</code></span>
<span class="codeline" id="line-482"><code>func (b *Reader) ReadString(delim byte) (string, error) {</code></span>
<span class="codeline" id="line-483"><code>	full, frag, n, err := b.collectFragments(delim)</code></span>
<span class="codeline" id="line-484"><code>	// Allocate new buffer to hold the full pieces and the fragment.</code></span>
<span class="codeline" id="line-485"><code>	var buf strings.Builder</code></span>
<span class="codeline" id="line-486"><code>	buf.Grow(n)</code></span>
<span class="codeline" id="line-487"><code>	// Copy full pieces and fragment in.</code></span>
<span class="codeline" id="line-488"><code>	for _, fb := range full {</code></span>
<span class="codeline" id="line-489"><code>		buf.Write(fb)</code></span>
<span class="codeline" id="line-490"><code>	}</code></span>
<span class="codeline" id="line-491"><code>	buf.Write(frag)</code></span>
<span class="codeline" id="line-492"><code>	return buf.String(), err</code></span>
<span class="codeline" id="line-493"><code>}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>// WriteTo implements io.WriterTo.</code></span>
<span class="codeline" id="line-496"><code>// This may make multiple calls to the Read method of the underlying Reader.</code></span>
<span class="codeline" id="line-497"><code>// If the underlying reader supports the WriteTo method,</code></span>
<span class="codeline" id="line-498"><code>// this calls the underlying WriteTo without buffering.</code></span>
<span class="codeline" id="line-499"><code>func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {</code></span>
<span class="codeline" id="line-500"><code>	n, err = b.writeBuf(w)</code></span>
<span class="codeline" id="line-501"><code>	if err != nil {</code></span>
<span class="codeline" id="line-502"><code>		return</code></span>
<span class="codeline" id="line-503"><code>	}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>	if r, ok := b.rd.(io.WriterTo); ok {</code></span>
<span class="codeline" id="line-506"><code>		m, err := r.WriteTo(w)</code></span>
<span class="codeline" id="line-507"><code>		n += m</code></span>
<span class="codeline" id="line-508"><code>		return n, err</code></span>
<span class="codeline" id="line-509"><code>	}</code></span>
<span class="codeline" id="line-510"><code></code></span>
<span class="codeline" id="line-511"><code>	if w, ok := w.(io.ReaderFrom); ok {</code></span>
<span class="codeline" id="line-512"><code>		m, err := w.ReadFrom(b.rd)</code></span>
<span class="codeline" id="line-513"><code>		n += m</code></span>
<span class="codeline" id="line-514"><code>		return n, err</code></span>
<span class="codeline" id="line-515"><code>	}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>	if b.w-b.r &lt; len(b.buf) {</code></span>
<span class="codeline" id="line-518"><code>		b.fill() // buffer not full</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>	for b.r &lt; b.w {</code></span>
<span class="codeline" id="line-522"><code>		// b.r &lt; b.w =&gt; buffer is not empty</code></span>
<span class="codeline" id="line-523"><code>		m, err := b.writeBuf(w)</code></span>
<span class="codeline" id="line-524"><code>		n += m</code></span>
<span class="codeline" id="line-525"><code>		if err != nil {</code></span>
<span class="codeline" id="line-526"><code>			return n, err</code></span>
<span class="codeline" id="line-527"><code>		}</code></span>
<span class="codeline" id="line-528"><code>		b.fill() // buffer is empty</code></span>
<span class="codeline" id="line-529"><code>	}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>	if b.err == io.EOF {</code></span>
<span class="codeline" id="line-532"><code>		b.err = nil</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>	return n, b.readErr()</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>var errNegativeWrite = errors.New("bufio: writer returned negative count from Write")</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>// writeBuf writes the Reader's buffer to the writer.</code></span>
<span class="codeline" id="line-541"><code>func (b *Reader) writeBuf(w io.Writer) (int64, error) {</code></span>
<span class="codeline" id="line-542"><code>	n, err := w.Write(b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-543"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-544"><code>		panic(errNegativeWrite)</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code>	b.r += n</code></span>
<span class="codeline" id="line-547"><code>	return int64(n), err</code></span>
<span class="codeline" id="line-548"><code>}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>// buffered output</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>// Writer implements buffering for an io.Writer object.</code></span>
<span class="codeline" id="line-553"><code>// If an error occurs writing to a Writer, no more data will be</code></span>
<span class="codeline" id="line-554"><code>// accepted and all subsequent writes, and Flush, will return the error.</code></span>
<span class="codeline" id="line-555"><code>// After all data has been written, the client should call the</code></span>
<span class="codeline" id="line-556"><code>// Flush method to guarantee all data has been forwarded to</code></span>
<span class="codeline" id="line-557"><code>// the underlying io.Writer.</code></span>
<span class="codeline" id="line-558"><code>type Writer struct {</code></span>
<span class="codeline" id="line-559"><code>	err error</code></span>
<span class="codeline" id="line-560"><code>	buf []byte</code></span>
<span class="codeline" id="line-561"><code>	n   int</code></span>
<span class="codeline" id="line-562"><code>	wr  io.Writer</code></span>
<span class="codeline" id="line-563"><code>}</code></span>
<span class="codeline" id="line-564"><code></code></span>
<span class="codeline" id="line-565"><code>// NewWriterSize returns a new Writer whose buffer has at least the specified</code></span>
<span class="codeline" id="line-566"><code>// size. If the argument io.Writer is already a Writer with large enough</code></span>
<span class="codeline" id="line-567"><code>// size, it returns the underlying Writer.</code></span>
<span class="codeline" id="line-568"><code>func NewWriterSize(w io.Writer, size int) *Writer {</code></span>
<span class="codeline" id="line-569"><code>	// Is it already a Writer?</code></span>
<span class="codeline" id="line-570"><code>	b, ok := w.(*Writer)</code></span>
<span class="codeline" id="line-571"><code>	if ok &amp;&amp; len(b.buf) &gt;= size {</code></span>
<span class="codeline" id="line-572"><code>		return b</code></span>
<span class="codeline" id="line-573"><code>	}</code></span>
<span class="codeline" id="line-574"><code>	if size &lt;= 0 {</code></span>
<span class="codeline" id="line-575"><code>		size = defaultBufSize</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code>	return &amp;Writer{</code></span>
<span class="codeline" id="line-578"><code>		buf: make([]byte, size),</code></span>
<span class="codeline" id="line-579"><code>		wr:  w,</code></span>
<span class="codeline" id="line-580"><code>	}</code></span>
<span class="codeline" id="line-581"><code>}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>// NewWriter returns a new Writer whose buffer has the default size.</code></span>
<span class="codeline" id="line-584"><code>func NewWriter(w io.Writer) *Writer {</code></span>
<span class="codeline" id="line-585"><code>	return NewWriterSize(w, defaultBufSize)</code></span>
<span class="codeline" id="line-586"><code>}</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>// Size returns the size of the underlying buffer in bytes.</code></span>
<span class="codeline" id="line-589"><code>func (b *Writer) Size() int { return len(b.buf) }</code></span>
<span class="codeline" id="line-590"><code></code></span>
<span class="codeline" id="line-591"><code>// Reset discards any unflushed buffered data, clears any error, and</code></span>
<span class="codeline" id="line-592"><code>// resets b to write its output to w.</code></span>
<span class="codeline" id="line-593"><code>func (b *Writer) Reset(w io.Writer) {</code></span>
<span class="codeline" id="line-594"><code>	b.err = nil</code></span>
<span class="codeline" id="line-595"><code>	b.n = 0</code></span>
<span class="codeline" id="line-596"><code>	b.wr = w</code></span>
<span class="codeline" id="line-597"><code>}</code></span>
<span class="codeline" id="line-598"><code></code></span>
<span class="codeline" id="line-599"><code>// Flush writes any buffered data to the underlying io.Writer.</code></span>
<span class="codeline" id="line-600"><code>func (b *Writer) Flush() error {</code></span>
<span class="codeline" id="line-601"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-602"><code>		return b.err</code></span>
<span class="codeline" id="line-603"><code>	}</code></span>
<span class="codeline" id="line-604"><code>	if b.n == 0 {</code></span>
<span class="codeline" id="line-605"><code>		return nil</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	n, err := b.wr.Write(b.buf[0:b.n])</code></span>
<span class="codeline" id="line-608"><code>	if n &lt; b.n &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-609"><code>		err = io.ErrShortWrite</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code>	if err != nil {</code></span>
<span class="codeline" id="line-612"><code>		if n &gt; 0 &amp;&amp; n &lt; b.n {</code></span>
<span class="codeline" id="line-613"><code>			copy(b.buf[0:b.n-n], b.buf[n:b.n])</code></span>
<span class="codeline" id="line-614"><code>		}</code></span>
<span class="codeline" id="line-615"><code>		b.n -= n</code></span>
<span class="codeline" id="line-616"><code>		b.err = err</code></span>
<span class="codeline" id="line-617"><code>		return err</code></span>
<span class="codeline" id="line-618"><code>	}</code></span>
<span class="codeline" id="line-619"><code>	b.n = 0</code></span>
<span class="codeline" id="line-620"><code>	return nil</code></span>
<span class="codeline" id="line-621"><code>}</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>// Available returns how many bytes are unused in the buffer.</code></span>
<span class="codeline" id="line-624"><code>func (b *Writer) Available() int { return len(b.buf) - b.n }</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>// Buffered returns the number of bytes that have been written into the current buffer.</code></span>
<span class="codeline" id="line-627"><code>func (b *Writer) Buffered() int { return b.n }</code></span>
<span class="codeline" id="line-628"><code></code></span>
<span class="codeline" id="line-629"><code>// Write writes the contents of p into the buffer.</code></span>
<span class="codeline" id="line-630"><code>// It returns the number of bytes written.</code></span>
<span class="codeline" id="line-631"><code>// If nn &lt; len(p), it also returns an error explaining</code></span>
<span class="codeline" id="line-632"><code>// why the write is short.</code></span>
<span class="codeline" id="line-633"><code>func (b *Writer) Write(p []byte) (nn int, err error) {</code></span>
<span class="codeline" id="line-634"><code>	for len(p) &gt; b.Available() &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-635"><code>		var n int</code></span>
<span class="codeline" id="line-636"><code>		if b.Buffered() == 0 {</code></span>
<span class="codeline" id="line-637"><code>			// Large write, empty buffer.</code></span>
<span class="codeline" id="line-638"><code>			// Write directly from p to avoid copy.</code></span>
<span class="codeline" id="line-639"><code>			n, b.err = b.wr.Write(p)</code></span>
<span class="codeline" id="line-640"><code>		} else {</code></span>
<span class="codeline" id="line-641"><code>			n = copy(b.buf[b.n:], p)</code></span>
<span class="codeline" id="line-642"><code>			b.n += n</code></span>
<span class="codeline" id="line-643"><code>			b.Flush()</code></span>
<span class="codeline" id="line-644"><code>		}</code></span>
<span class="codeline" id="line-645"><code>		nn += n</code></span>
<span class="codeline" id="line-646"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-647"><code>	}</code></span>
<span class="codeline" id="line-648"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-649"><code>		return nn, b.err</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code>	n := copy(b.buf[b.n:], p)</code></span>
<span class="codeline" id="line-652"><code>	b.n += n</code></span>
<span class="codeline" id="line-653"><code>	nn += n</code></span>
<span class="codeline" id="line-654"><code>	return nn, nil</code></span>
<span class="codeline" id="line-655"><code>}</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>// WriteByte writes a single byte.</code></span>
<span class="codeline" id="line-658"><code>func (b *Writer) WriteByte(c byte) error {</code></span>
<span class="codeline" id="line-659"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-660"><code>		return b.err</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code>	if b.Available() &lt;= 0 &amp;&amp; b.Flush() != nil {</code></span>
<span class="codeline" id="line-663"><code>		return b.err</code></span>
<span class="codeline" id="line-664"><code>	}</code></span>
<span class="codeline" id="line-665"><code>	b.buf[b.n] = c</code></span>
<span class="codeline" id="line-666"><code>	b.n++</code></span>
<span class="codeline" id="line-667"><code>	return nil</code></span>
<span class="codeline" id="line-668"><code>}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>// WriteRune writes a single Unicode code point, returning</code></span>
<span class="codeline" id="line-671"><code>// the number of bytes written and any error.</code></span>
<span class="codeline" id="line-672"><code>func (b *Writer) WriteRune(r rune) (size int, err error) {</code></span>
<span class="codeline" id="line-673"><code>	if r &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-674"><code>		err = b.WriteByte(byte(r))</code></span>
<span class="codeline" id="line-675"><code>		if err != nil {</code></span>
<span class="codeline" id="line-676"><code>			return 0, err</code></span>
<span class="codeline" id="line-677"><code>		}</code></span>
<span class="codeline" id="line-678"><code>		return 1, nil</code></span>
<span class="codeline" id="line-679"><code>	}</code></span>
<span class="codeline" id="line-680"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-681"><code>		return 0, b.err</code></span>
<span class="codeline" id="line-682"><code>	}</code></span>
<span class="codeline" id="line-683"><code>	n := b.Available()</code></span>
<span class="codeline" id="line-684"><code>	if n &lt; utf8.UTFMax {</code></span>
<span class="codeline" id="line-685"><code>		if b.Flush(); b.err != nil {</code></span>
<span class="codeline" id="line-686"><code>			return 0, b.err</code></span>
<span class="codeline" id="line-687"><code>		}</code></span>
<span class="codeline" id="line-688"><code>		n = b.Available()</code></span>
<span class="codeline" id="line-689"><code>		if n &lt; utf8.UTFMax {</code></span>
<span class="codeline" id="line-690"><code>			// Can only happen if buffer is silly small.</code></span>
<span class="codeline" id="line-691"><code>			return b.WriteString(string(r))</code></span>
<span class="codeline" id="line-692"><code>		}</code></span>
<span class="codeline" id="line-693"><code>	}</code></span>
<span class="codeline" id="line-694"><code>	size = utf8.EncodeRune(b.buf[b.n:], r)</code></span>
<span class="codeline" id="line-695"><code>	b.n += size</code></span>
<span class="codeline" id="line-696"><code>	return size, nil</code></span>
<span class="codeline" id="line-697"><code>}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// WriteString writes a string.</code></span>
<span class="codeline" id="line-700"><code>// It returns the number of bytes written.</code></span>
<span class="codeline" id="line-701"><code>// If the count is less than len(s), it also returns an error explaining</code></span>
<span class="codeline" id="line-702"><code>// why the write is short.</code></span>
<span class="codeline" id="line-703"><code>func (b *Writer) WriteString(s string) (int, error) {</code></span>
<span class="codeline" id="line-704"><code>	nn := 0</code></span>
<span class="codeline" id="line-705"><code>	for len(s) &gt; b.Available() &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-706"><code>		n := copy(b.buf[b.n:], s)</code></span>
<span class="codeline" id="line-707"><code>		b.n += n</code></span>
<span class="codeline" id="line-708"><code>		nn += n</code></span>
<span class="codeline" id="line-709"><code>		s = s[n:]</code></span>
<span class="codeline" id="line-710"><code>		b.Flush()</code></span>
<span class="codeline" id="line-711"><code>	}</code></span>
<span class="codeline" id="line-712"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-713"><code>		return nn, b.err</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>	n := copy(b.buf[b.n:], s)</code></span>
<span class="codeline" id="line-716"><code>	b.n += n</code></span>
<span class="codeline" id="line-717"><code>	nn += n</code></span>
<span class="codeline" id="line-718"><code>	return nn, nil</code></span>
<span class="codeline" id="line-719"><code>}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>// ReadFrom implements io.ReaderFrom. If the underlying writer</code></span>
<span class="codeline" id="line-722"><code>// supports the ReadFrom method, and b has no buffered data yet,</code></span>
<span class="codeline" id="line-723"><code>// this calls the underlying ReadFrom without buffering.</code></span>
<span class="codeline" id="line-724"><code>func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {</code></span>
<span class="codeline" id="line-725"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-726"><code>		return 0, b.err</code></span>
<span class="codeline" id="line-727"><code>	}</code></span>
<span class="codeline" id="line-728"><code>	if b.Buffered() == 0 {</code></span>
<span class="codeline" id="line-729"><code>		if w, ok := b.wr.(io.ReaderFrom); ok {</code></span>
<span class="codeline" id="line-730"><code>			n, err = w.ReadFrom(r)</code></span>
<span class="codeline" id="line-731"><code>			b.err = err</code></span>
<span class="codeline" id="line-732"><code>			return n, err</code></span>
<span class="codeline" id="line-733"><code>		}</code></span>
<span class="codeline" id="line-734"><code>	}</code></span>
<span class="codeline" id="line-735"><code>	var m int</code></span>
<span class="codeline" id="line-736"><code>	for {</code></span>
<span class="codeline" id="line-737"><code>		if b.Available() == 0 {</code></span>
<span class="codeline" id="line-738"><code>			if err1 := b.Flush(); err1 != nil {</code></span>
<span class="codeline" id="line-739"><code>				return n, err1</code></span>
<span class="codeline" id="line-740"><code>			}</code></span>
<span class="codeline" id="line-741"><code>		}</code></span>
<span class="codeline" id="line-742"><code>		nr := 0</code></span>
<span class="codeline" id="line-743"><code>		for nr &lt; maxConsecutiveEmptyReads {</code></span>
<span class="codeline" id="line-744"><code>			m, err = r.Read(b.buf[b.n:])</code></span>
<span class="codeline" id="line-745"><code>			if m != 0 || err != nil {</code></span>
<span class="codeline" id="line-746"><code>				break</code></span>
<span class="codeline" id="line-747"><code>			}</code></span>
<span class="codeline" id="line-748"><code>			nr++</code></span>
<span class="codeline" id="line-749"><code>		}</code></span>
<span class="codeline" id="line-750"><code>		if nr == maxConsecutiveEmptyReads {</code></span>
<span class="codeline" id="line-751"><code>			return n, io.ErrNoProgress</code></span>
<span class="codeline" id="line-752"><code>		}</code></span>
<span class="codeline" id="line-753"><code>		b.n += m</code></span>
<span class="codeline" id="line-754"><code>		n += int64(m)</code></span>
<span class="codeline" id="line-755"><code>		if err != nil {</code></span>
<span class="codeline" id="line-756"><code>			break</code></span>
<span class="codeline" id="line-757"><code>		}</code></span>
<span class="codeline" id="line-758"><code>	}</code></span>
<span class="codeline" id="line-759"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-760"><code>		// If we filled the buffer exactly, flush preemptively.</code></span>
<span class="codeline" id="line-761"><code>		if b.Available() == 0 {</code></span>
<span class="codeline" id="line-762"><code>			err = b.Flush()</code></span>
<span class="codeline" id="line-763"><code>		} else {</code></span>
<span class="codeline" id="line-764"><code>			err = nil</code></span>
<span class="codeline" id="line-765"><code>		}</code></span>
<span class="codeline" id="line-766"><code>	}</code></span>
<span class="codeline" id="line-767"><code>	return n, err</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>// buffered input and output</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>// ReadWriter stores pointers to a Reader and a Writer.</code></span>
<span class="codeline" id="line-773"><code>// It implements io.ReadWriter.</code></span>
<span class="codeline" id="line-774"><code>type ReadWriter struct {</code></span>
<span class="codeline" id="line-775"><code>	*Reader</code></span>
<span class="codeline" id="line-776"><code>	*Writer</code></span>
<span class="codeline" id="line-777"><code>}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</code></span>
<span class="codeline" id="line-780"><code>func NewReadWriter(r *Reader, w *Writer) *ReadWriter {</code></span>
<span class="codeline" id="line-781"><code>	return &amp;ReadWriter{r, w}</code></span>
<span class="codeline" id="line-782"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>