<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: builtin.go in package builtin</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	builtin.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/builtin.html">builtin</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>	Package builtin provides documentation for Go's predeclared identifiers.</code></span>
<span class="codeline" id="line-7"><code>	The items documented here are not actually in package builtin</code></span>
<span class="codeline" id="line-8"><code>	but their descriptions here allow godoc to present documentation</code></span>
<span class="codeline" id="line-9"><code>	for the language's special identifiers.</code></span>
<span class="codeline" id="line-10"><code>*/</code></span></div><span class="codeline" id="line-11"><code>package builtin</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>// bool is the set of boolean values, true and false.</code></span>
<span class="codeline" id="line-14"><code>type bool bool</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// true and false are the two untyped boolean values.</code></span>
<span class="codeline" id="line-17"><code>const (</code></span>
<span class="codeline" id="line-18"><code>	true  = 0 == 0 // Untyped bool.</code></span>
<span class="codeline" id="line-19"><code>	false = 0 != 0 // Untyped bool.</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// uint8 is the set of all unsigned 8-bit integers.</code></span>
<span class="codeline" id="line-23"><code>// Range: 0 through 255.</code></span>
<span class="codeline" id="line-24"><code>type uint8 uint8</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>// uint16 is the set of all unsigned 16-bit integers.</code></span>
<span class="codeline" id="line-27"><code>// Range: 0 through 65535.</code></span>
<span class="codeline" id="line-28"><code>type uint16 uint16</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>// uint32 is the set of all unsigned 32-bit integers.</code></span>
<span class="codeline" id="line-31"><code>// Range: 0 through 4294967295.</code></span>
<span class="codeline" id="line-32"><code>type uint32 uint32</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// uint64 is the set of all unsigned 64-bit integers.</code></span>
<span class="codeline" id="line-35"><code>// Range: 0 through 18446744073709551615.</code></span>
<span class="codeline" id="line-36"><code>type uint64 uint64</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>// int8 is the set of all signed 8-bit integers.</code></span>
<span class="codeline" id="line-39"><code>// Range: -128 through 127.</code></span>
<span class="codeline" id="line-40"><code>type int8 int8</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>// int16 is the set of all signed 16-bit integers.</code></span>
<span class="codeline" id="line-43"><code>// Range: -32768 through 32767.</code></span>
<span class="codeline" id="line-44"><code>type int16 int16</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>// int32 is the set of all signed 32-bit integers.</code></span>
<span class="codeline" id="line-47"><code>// Range: -2147483648 through 2147483647.</code></span>
<span class="codeline" id="line-48"><code>type int32 int32</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>// int64 is the set of all signed 64-bit integers.</code></span>
<span class="codeline" id="line-51"><code>// Range: -9223372036854775808 through 9223372036854775807.</code></span>
<span class="codeline" id="line-52"><code>type int64 int64</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>// float32 is the set of all IEEE-754 32-bit floating-point numbers.</code></span>
<span class="codeline" id="line-55"><code>type float32 float32</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>// float64 is the set of all IEEE-754 64-bit floating-point numbers.</code></span>
<span class="codeline" id="line-58"><code>type float64 float64</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// complex64 is the set of all complex numbers with float32 real and</code></span>
<span class="codeline" id="line-61"><code>// imaginary parts.</code></span>
<span class="codeline" id="line-62"><code>type complex64 complex64</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// complex128 is the set of all complex numbers with float64 real and</code></span>
<span class="codeline" id="line-65"><code>// imaginary parts.</code></span>
<span class="codeline" id="line-66"><code>type complex128 complex128</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>// string is the set of all strings of 8-bit bytes, conventionally but not</code></span>
<span class="codeline" id="line-69"><code>// necessarily representing UTF-8-encoded text. A string may be empty, but</code></span>
<span class="codeline" id="line-70"><code>// not nil. Values of string type are immutable.</code></span>
<span class="codeline" id="line-71"><code>type string string</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// int is a signed integer type that is at least 32 bits in size. It is a</code></span>
<span class="codeline" id="line-74"><code>// distinct type, however, and not an alias for, say, int32.</code></span>
<span class="codeline" id="line-75"><code>type int int</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>// uint is an unsigned integer type that is at least 32 bits in size. It is a</code></span>
<span class="codeline" id="line-78"><code>// distinct type, however, and not an alias for, say, uint32.</code></span>
<span class="codeline" id="line-79"><code>type uint uint</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>// uintptr is an integer type that is large enough to hold the bit pattern of</code></span>
<span class="codeline" id="line-82"><code>// any pointer.</code></span>
<span class="codeline" id="line-83"><code>type uintptr uintptr</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</code></span>
<span class="codeline" id="line-86"><code>// used, by convention, to distinguish byte values from 8-bit unsigned</code></span>
<span class="codeline" id="line-87"><code>// integer values.</code></span>
<span class="codeline" id="line-88"><code>type byte = uint8</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>// rune is an alias for int32 and is equivalent to int32 in all ways. It is</code></span>
<span class="codeline" id="line-91"><code>// used, by convention, to distinguish character values from integer values.</code></span>
<span class="codeline" id="line-92"><code>type rune = int32</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>// iota is a predeclared identifier representing the untyped integer ordinal</code></span>
<span class="codeline" id="line-95"><code>// number of the current const specification in a (usually parenthesized)</code></span>
<span class="codeline" id="line-96"><code>// const declaration. It is zero-indexed.</code></span>
<span class="codeline" id="line-97"><code>const iota = 0 // Untyped int.</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>// nil is a predeclared identifier representing the zero value for a</code></span>
<span class="codeline" id="line-100"><code>// pointer, channel, func, interface, map, or slice type.</code></span>
<span class="codeline" id="line-101"><code>var nil Type // Type must be a pointer, channel, func, interface, map, or slice type</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>// Type is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-104"><code>// for any Go type, but represents the same type for any given function</code></span>
<span class="codeline" id="line-105"><code>// invocation.</code></span>
<span class="codeline" id="line-106"><code>type Type int</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>// Type1 is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-109"><code>// for any Go type, but represents the same type for any given function</code></span>
<span class="codeline" id="line-110"><code>// invocation.</code></span>
<span class="codeline" id="line-111"><code>type Type1 int</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>// IntegerType is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-114"><code>// for any integer type: int, uint, int8 etc.</code></span>
<span class="codeline" id="line-115"><code>type IntegerType int</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// FloatType is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-118"><code>// for either float type: float32 or float64.</code></span>
<span class="codeline" id="line-119"><code>type FloatType float32</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>// ComplexType is here for the purposes of documentation only. It is a</code></span>
<span class="codeline" id="line-122"><code>// stand-in for either complex type: complex64 or complex128.</code></span>
<span class="codeline" id="line-123"><code>type ComplexType complex64</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>// The append built-in function appends elements to the end of a slice. If</code></span>
<span class="codeline" id="line-126"><code>// it has sufficient capacity, the destination is resliced to accommodate the</code></span>
<span class="codeline" id="line-127"><code>// new elements. If it does not, a new underlying array will be allocated.</code></span>
<span class="codeline" id="line-128"><code>// Append returns the updated slice. It is therefore necessary to store the</code></span>
<span class="codeline" id="line-129"><code>// result of append, often in the variable holding the slice itself:</code></span>
<span class="codeline" id="line-130"><code>//	slice = append(slice, elem1, elem2)</code></span>
<span class="codeline" id="line-131"><code>//	slice = append(slice, anotherSlice...)</code></span>
<span class="codeline" id="line-132"><code>// As a special case, it is legal to append a string to a byte slice, like this:</code></span>
<span class="codeline" id="line-133"><code>//	slice = append([]byte("hello "), "world"...)</code></span>
<span class="codeline" id="line-134"><code>func append(slice []Type, elems ...Type) []Type</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// The copy built-in function copies elements from a source slice into a</code></span>
<span class="codeline" id="line-137"><code>// destination slice. (As a special case, it also will copy bytes from a</code></span>
<span class="codeline" id="line-138"><code>// string to a slice of bytes.) The source and destination may overlap. Copy</code></span>
<span class="codeline" id="line-139"><code>// returns the number of elements copied, which will be the minimum of</code></span>
<span class="codeline" id="line-140"><code>// len(src) and len(dst).</code></span>
<span class="codeline" id="line-141"><code>func copy(dst, src []Type) int</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// The delete built-in function deletes the element with the specified key</code></span>
<span class="codeline" id="line-144"><code>// (m[key]) from the map. If m is nil or there is no such element, delete</code></span>
<span class="codeline" id="line-145"><code>// is a no-op.</code></span>
<span class="codeline" id="line-146"><code>func delete(m map[Type]Type1, key Type)</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>// The len built-in function returns the length of v, according to its type:</code></span>
<span class="codeline" id="line-149"><code>//	Array: the number of elements in v.</code></span>
<span class="codeline" id="line-150"><code>//	Pointer to array: the number of elements in *v (even if v is nil).</code></span>
<span class="codeline" id="line-151"><code>//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.</code></span>
<span class="codeline" id="line-152"><code>//	String: the number of bytes in v.</code></span>
<span class="codeline" id="line-153"><code>//	Channel: the number of elements queued (unread) in the channel buffer;</code></span>
<span class="codeline" id="line-154"><code>//	         if v is nil, len(v) is zero.</code></span>
<span class="codeline" id="line-155"><code>// For some arguments, such as a string literal or a simple array expression, the</code></span>
<span class="codeline" id="line-156"><code>// result can be a constant. See the Go language specification's "Length and</code></span>
<span class="codeline" id="line-157"><code>// capacity" section for details.</code></span>
<span class="codeline" id="line-158"><code>func len(v Type) int</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// The cap built-in function returns the capacity of v, according to its type:</code></span>
<span class="codeline" id="line-161"><code>//	Array: the number of elements in v (same as len(v)).</code></span>
<span class="codeline" id="line-162"><code>//	Pointer to array: the number of elements in *v (same as len(v)).</code></span>
<span class="codeline" id="line-163"><code>//	Slice: the maximum length the slice can reach when resliced;</code></span>
<span class="codeline" id="line-164"><code>//	if v is nil, cap(v) is zero.</code></span>
<span class="codeline" id="line-165"><code>//	Channel: the channel buffer capacity, in units of elements;</code></span>
<span class="codeline" id="line-166"><code>//	if v is nil, cap(v) is zero.</code></span>
<span class="codeline" id="line-167"><code>// For some arguments, such as a simple array expression, the result can be a</code></span>
<span class="codeline" id="line-168"><code>// constant. See the Go language specification's "Length and capacity" section for</code></span>
<span class="codeline" id="line-169"><code>// details.</code></span>
<span class="codeline" id="line-170"><code>func cap(v Type) int</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// The make built-in function allocates and initializes an object of type</code></span>
<span class="codeline" id="line-173"><code>// slice, map, or chan (only). Like new, the first argument is a type, not a</code></span>
<span class="codeline" id="line-174"><code>// value. Unlike new, make's return type is the same as the type of its</code></span>
<span class="codeline" id="line-175"><code>// argument, not a pointer to it. The specification of the result depends on</code></span>
<span class="codeline" id="line-176"><code>// the type:</code></span>
<span class="codeline" id="line-177"><code>//	Slice: The size specifies the length. The capacity of the slice is</code></span>
<span class="codeline" id="line-178"><code>//	equal to its length. A second integer argument may be provided to</code></span>
<span class="codeline" id="line-179"><code>//	specify a different capacity; it must be no smaller than the</code></span>
<span class="codeline" id="line-180"><code>//	length. For example, make([]int, 0, 10) allocates an underlying array</code></span>
<span class="codeline" id="line-181"><code>//	of size 10 and returns a slice of length 0 and capacity 10 that is</code></span>
<span class="codeline" id="line-182"><code>//	backed by this underlying array.</code></span>
<span class="codeline" id="line-183"><code>//	Map: An empty map is allocated with enough space to hold the</code></span>
<span class="codeline" id="line-184"><code>//	specified number of elements. The size may be omitted, in which case</code></span>
<span class="codeline" id="line-185"><code>//	a small starting size is allocated.</code></span>
<span class="codeline" id="line-186"><code>//	Channel: The channel's buffer is initialized with the specified</code></span>
<span class="codeline" id="line-187"><code>//	buffer capacity. If zero, or the size is omitted, the channel is</code></span>
<span class="codeline" id="line-188"><code>//	unbuffered.</code></span>
<span class="codeline" id="line-189"><code>func make(t Type, size ...IntegerType) Type</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// The new built-in function allocates memory. The first argument is a type,</code></span>
<span class="codeline" id="line-192"><code>// not a value, and the value returned is a pointer to a newly</code></span>
<span class="codeline" id="line-193"><code>// allocated zero value of that type.</code></span>
<span class="codeline" id="line-194"><code>func new(Type) *Type</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// The complex built-in function constructs a complex value from two</code></span>
<span class="codeline" id="line-197"><code>// floating-point values. The real and imaginary parts must be of the same</code></span>
<span class="codeline" id="line-198"><code>// size, either float32 or float64 (or assignable to them), and the return</code></span>
<span class="codeline" id="line-199"><code>// value will be the corresponding complex type (complex64 for float32,</code></span>
<span class="codeline" id="line-200"><code>// complex128 for float64).</code></span>
<span class="codeline" id="line-201"><code>func complex(r, i FloatType) ComplexType</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// The real built-in function returns the real part of the complex number c.</code></span>
<span class="codeline" id="line-204"><code>// The return value will be floating point type corresponding to the type of c.</code></span>
<span class="codeline" id="line-205"><code>func real(c ComplexType) FloatType</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>// The imag built-in function returns the imaginary part of the complex</code></span>
<span class="codeline" id="line-208"><code>// number c. The return value will be floating point type corresponding to</code></span>
<span class="codeline" id="line-209"><code>// the type of c.</code></span>
<span class="codeline" id="line-210"><code>func imag(c ComplexType) FloatType</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>// The close built-in function closes a channel, which must be either</code></span>
<span class="codeline" id="line-213"><code>// bidirectional or send-only. It should be executed only by the sender,</code></span>
<span class="codeline" id="line-214"><code>// never the receiver, and has the effect of shutting down the channel after</code></span>
<span class="codeline" id="line-215"><code>// the last sent value is received. After the last value has been received</code></span>
<span class="codeline" id="line-216"><code>// from a closed channel c, any receive from c will succeed without</code></span>
<span class="codeline" id="line-217"><code>// blocking, returning the zero value for the channel element. The form</code></span>
<span class="codeline" id="line-218"><code>//	x, ok := &lt;-c</code></span>
<span class="codeline" id="line-219"><code>// will also set ok to false for a closed channel.</code></span>
<span class="codeline" id="line-220"><code>func close(c chan&lt;- Type)</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>// The panic built-in function stops normal execution of the current</code></span>
<span class="codeline" id="line-223"><code>// goroutine. When a function F calls panic, normal execution of F stops</code></span>
<span class="codeline" id="line-224"><code>// immediately. Any functions whose execution was deferred by F are run in</code></span>
<span class="codeline" id="line-225"><code>// the usual way, and then F returns to its caller. To the caller G, the</code></span>
<span class="codeline" id="line-226"><code>// invocation of F then behaves like a call to panic, terminating G's</code></span>
<span class="codeline" id="line-227"><code>// execution and running any deferred functions. This continues until all</code></span>
<span class="codeline" id="line-228"><code>// functions in the executing goroutine have stopped, in reverse order. At</code></span>
<span class="codeline" id="line-229"><code>// that point, the program is terminated with a non-zero exit code. This</code></span>
<span class="codeline" id="line-230"><code>// termination sequence is called panicking and can be controlled by the</code></span>
<span class="codeline" id="line-231"><code>// built-in function recover.</code></span>
<span class="codeline" id="line-232"><code>func panic(v interface{})</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// The recover built-in function allows a program to manage behavior of a</code></span>
<span class="codeline" id="line-235"><code>// panicking goroutine. Executing a call to recover inside a deferred</code></span>
<span class="codeline" id="line-236"><code>// function (but not any function called by it) stops the panicking sequence</code></span>
<span class="codeline" id="line-237"><code>// by restoring normal execution and retrieves the error value passed to the</code></span>
<span class="codeline" id="line-238"><code>// call of panic. If recover is called outside the deferred function it will</code></span>
<span class="codeline" id="line-239"><code>// not stop a panicking sequence. In this case, or when the goroutine is not</code></span>
<span class="codeline" id="line-240"><code>// panicking, or if the argument supplied to panic was nil, recover returns</code></span>
<span class="codeline" id="line-241"><code>// nil. Thus the return value from recover reports whether the goroutine is</code></span>
<span class="codeline" id="line-242"><code>// panicking.</code></span>
<span class="codeline" id="line-243"><code>func recover() interface{}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>// The print built-in function formats its arguments in an</code></span>
<span class="codeline" id="line-246"><code>// implementation-specific way and writes the result to standard error.</code></span>
<span class="codeline" id="line-247"><code>// Print is useful for bootstrapping and debugging; it is not guaranteed</code></span>
<span class="codeline" id="line-248"><code>// to stay in the language.</code></span>
<span class="codeline" id="line-249"><code>func print(args ...Type)</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>// The println built-in function formats its arguments in an</code></span>
<span class="codeline" id="line-252"><code>// implementation-specific way and writes the result to standard error.</code></span>
<span class="codeline" id="line-253"><code>// Spaces are always added between arguments and a newline is appended.</code></span>
<span class="codeline" id="line-254"><code>// Println is useful for bootstrapping and debugging; it is not guaranteed</code></span>
<span class="codeline" id="line-255"><code>// to stay in the language.</code></span>
<span class="codeline" id="line-256"><code>func println(args ...Type)</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>// The error built-in interface type is the conventional interface for</code></span>
<span class="codeline" id="line-259"><code>// representing an error condition, with the nil value representing no error.</code></span>
<span class="codeline" id="line-260"><code>type error interface {</code></span>
<span class="codeline" id="line-261"><code>	Error() string</code></span>
<span class="codeline" id="line-262"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>