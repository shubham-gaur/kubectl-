<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: strings.go in package strings</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	strings.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/strings.html">strings</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package strings implements simple functions to manipulate UTF-8 encoded strings.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// For information about UTF-8 strings in Go, see https://blog.golang.org/strings.</code></span></div><span class="codeline" id="line-8"><code>package strings</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"internal/bytealg"</code></span>
<span class="codeline" id="line-12"><code>	"unicode"</code></span>
<span class="codeline" id="line-13"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// explode splits s into a slice of UTF-8 strings,</code></span>
<span class="codeline" id="line-17"><code>// one string per Unicode character up to a maximum of n (n &lt; 0 means no limit).</code></span>
<span class="codeline" id="line-18"><code>// Invalid UTF-8 sequences become correct encodings of U+FFFD.</code></span>
<span class="codeline" id="line-19"><code>func explode(s string, n int) []string {</code></span>
<span class="codeline" id="line-20"><code>	l := utf8.RuneCountInString(s)</code></span>
<span class="codeline" id="line-21"><code>	if n &lt; 0 || n &gt; l {</code></span>
<span class="codeline" id="line-22"><code>		n = l</code></span>
<span class="codeline" id="line-23"><code>	}</code></span>
<span class="codeline" id="line-24"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-25"><code>	for i := 0; i &lt; n-1; i++ {</code></span>
<span class="codeline" id="line-26"><code>		ch, size := utf8.DecodeRuneInString(s)</code></span>
<span class="codeline" id="line-27"><code>		a[i] = s[:size]</code></span>
<span class="codeline" id="line-28"><code>		s = s[size:]</code></span>
<span class="codeline" id="line-29"><code>		if ch == utf8.RuneError {</code></span>
<span class="codeline" id="line-30"><code>			a[i] = string(utf8.RuneError)</code></span>
<span class="codeline" id="line-31"><code>		}</code></span>
<span class="codeline" id="line-32"><code>	}</code></span>
<span class="codeline" id="line-33"><code>	if n &gt; 0 {</code></span>
<span class="codeline" id="line-34"><code>		a[n-1] = s</code></span>
<span class="codeline" id="line-35"><code>	}</code></span>
<span class="codeline" id="line-36"><code>	return a</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// Count counts the number of non-overlapping instances of substr in s.</code></span>
<span class="codeline" id="line-40"><code>// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.</code></span>
<span class="codeline" id="line-41"><code>func Count(s, substr string) int {</code></span>
<span class="codeline" id="line-42"><code>	// special case</code></span>
<span class="codeline" id="line-43"><code>	if len(substr) == 0 {</code></span>
<span class="codeline" id="line-44"><code>		return utf8.RuneCountInString(s) + 1</code></span>
<span class="codeline" id="line-45"><code>	}</code></span>
<span class="codeline" id="line-46"><code>	if len(substr) == 1 {</code></span>
<span class="codeline" id="line-47"><code>		return bytealg.CountString(s, substr[0])</code></span>
<span class="codeline" id="line-48"><code>	}</code></span>
<span class="codeline" id="line-49"><code>	n := 0</code></span>
<span class="codeline" id="line-50"><code>	for {</code></span>
<span class="codeline" id="line-51"><code>		i := Index(s, substr)</code></span>
<span class="codeline" id="line-52"><code>		if i == -1 {</code></span>
<span class="codeline" id="line-53"><code>			return n</code></span>
<span class="codeline" id="line-54"><code>		}</code></span>
<span class="codeline" id="line-55"><code>		n++</code></span>
<span class="codeline" id="line-56"><code>		s = s[i+len(substr):]</code></span>
<span class="codeline" id="line-57"><code>	}</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// Contains reports whether substr is within s.</code></span>
<span class="codeline" id="line-61"><code>func Contains(s, substr string) bool {</code></span>
<span class="codeline" id="line-62"><code>	return Index(s, substr) &gt;= 0</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// ContainsAny reports whether any Unicode code points in chars are within s.</code></span>
<span class="codeline" id="line-66"><code>func ContainsAny(s, chars string) bool {</code></span>
<span class="codeline" id="line-67"><code>	return IndexAny(s, chars) &gt;= 0</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// ContainsRune reports whether the Unicode code point r is within s.</code></span>
<span class="codeline" id="line-71"><code>func ContainsRune(s string, r rune) bool {</code></span>
<span class="codeline" id="line-72"><code>	return IndexRune(s, r) &gt;= 0</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</code></span>
<span class="codeline" id="line-76"><code>func LastIndex(s, substr string) int {</code></span>
<span class="codeline" id="line-77"><code>	n := len(substr)</code></span>
<span class="codeline" id="line-78"><code>	switch {</code></span>
<span class="codeline" id="line-79"><code>	case n == 0:</code></span>
<span class="codeline" id="line-80"><code>		return len(s)</code></span>
<span class="codeline" id="line-81"><code>	case n == 1:</code></span>
<span class="codeline" id="line-82"><code>		return LastIndexByte(s, substr[0])</code></span>
<span class="codeline" id="line-83"><code>	case n == len(s):</code></span>
<span class="codeline" id="line-84"><code>		if substr == s {</code></span>
<span class="codeline" id="line-85"><code>			return 0</code></span>
<span class="codeline" id="line-86"><code>		}</code></span>
<span class="codeline" id="line-87"><code>		return -1</code></span>
<span class="codeline" id="line-88"><code>	case n &gt; len(s):</code></span>
<span class="codeline" id="line-89"><code>		return -1</code></span>
<span class="codeline" id="line-90"><code>	}</code></span>
<span class="codeline" id="line-91"><code>	// Rabin-Karp search from the end of the string</code></span>
<span class="codeline" id="line-92"><code>	hashss, pow := bytealg.HashStrRev(substr)</code></span>
<span class="codeline" id="line-93"><code>	last := len(s) - n</code></span>
<span class="codeline" id="line-94"><code>	var h uint32</code></span>
<span class="codeline" id="line-95"><code>	for i := len(s) - 1; i &gt;= last; i-- {</code></span>
<span class="codeline" id="line-96"><code>		h = h*bytealg.PrimeRK + uint32(s[i])</code></span>
<span class="codeline" id="line-97"><code>	}</code></span>
<span class="codeline" id="line-98"><code>	if h == hashss &amp;&amp; s[last:] == substr {</code></span>
<span class="codeline" id="line-99"><code>		return last</code></span>
<span class="codeline" id="line-100"><code>	}</code></span>
<span class="codeline" id="line-101"><code>	for i := last - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-102"><code>		h *= bytealg.PrimeRK</code></span>
<span class="codeline" id="line-103"><code>		h += uint32(s[i])</code></span>
<span class="codeline" id="line-104"><code>		h -= pow * uint32(s[i+n])</code></span>
<span class="codeline" id="line-105"><code>		if h == hashss &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-106"><code>			return i</code></span>
<span class="codeline" id="line-107"><code>		}</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>	return -1</code></span>
<span class="codeline" id="line-110"><code>}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</code></span>
<span class="codeline" id="line-113"><code>func IndexByte(s string, c byte) int {</code></span>
<span class="codeline" id="line-114"><code>	return bytealg.IndexByteString(s, c)</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// IndexRune returns the index of the first instance of the Unicode code point</code></span>
<span class="codeline" id="line-118"><code>// r, or -1 if rune is not present in s.</code></span>
<span class="codeline" id="line-119"><code>// If r is utf8.RuneError, it returns the first instance of any</code></span>
<span class="codeline" id="line-120"><code>// invalid UTF-8 byte sequence.</code></span>
<span class="codeline" id="line-121"><code>func IndexRune(s string, r rune) int {</code></span>
<span class="codeline" id="line-122"><code>	switch {</code></span>
<span class="codeline" id="line-123"><code>	case 0 &lt;= r &amp;&amp; r &lt; utf8.RuneSelf:</code></span>
<span class="codeline" id="line-124"><code>		return IndexByte(s, byte(r))</code></span>
<span class="codeline" id="line-125"><code>	case r == utf8.RuneError:</code></span>
<span class="codeline" id="line-126"><code>		for i, r := range s {</code></span>
<span class="codeline" id="line-127"><code>			if r == utf8.RuneError {</code></span>
<span class="codeline" id="line-128"><code>				return i</code></span>
<span class="codeline" id="line-129"><code>			}</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code>		return -1</code></span>
<span class="codeline" id="line-132"><code>	case !utf8.ValidRune(r):</code></span>
<span class="codeline" id="line-133"><code>		return -1</code></span>
<span class="codeline" id="line-134"><code>	default:</code></span>
<span class="codeline" id="line-135"><code>		return Index(s, string(r))</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// IndexAny returns the index of the first instance of any Unicode code point</code></span>
<span class="codeline" id="line-140"><code>// from chars in s, or -1 if no Unicode code point from chars is present in s.</code></span>
<span class="codeline" id="line-141"><code>func IndexAny(s, chars string) int {</code></span>
<span class="codeline" id="line-142"><code>	if chars == "" {</code></span>
<span class="codeline" id="line-143"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-144"><code>		return -1</code></span>
<span class="codeline" id="line-145"><code>	}</code></span>
<span class="codeline" id="line-146"><code>	if len(chars) == 1 {</code></span>
<span class="codeline" id="line-147"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-148"><code>		r := rune(chars[0])</code></span>
<span class="codeline" id="line-149"><code>		if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-150"><code>			r = utf8.RuneError</code></span>
<span class="codeline" id="line-151"><code>		}</code></span>
<span class="codeline" id="line-152"><code>		return IndexRune(s, r)</code></span>
<span class="codeline" id="line-153"><code>	}</code></span>
<span class="codeline" id="line-154"><code>	if len(s) &gt; 8 {</code></span>
<span class="codeline" id="line-155"><code>		if as, isASCII := makeASCIISet(chars); isASCII {</code></span>
<span class="codeline" id="line-156"><code>			for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-157"><code>				if as.contains(s[i]) {</code></span>
<span class="codeline" id="line-158"><code>					return i</code></span>
<span class="codeline" id="line-159"><code>				}</code></span>
<span class="codeline" id="line-160"><code>			}</code></span>
<span class="codeline" id="line-161"><code>			return -1</code></span>
<span class="codeline" id="line-162"><code>		}</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-165"><code>		if IndexRune(chars, c) &gt;= 0 {</code></span>
<span class="codeline" id="line-166"><code>			return i</code></span>
<span class="codeline" id="line-167"><code>		}</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>	return -1</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// LastIndexAny returns the index of the last instance of any Unicode code</code></span>
<span class="codeline" id="line-173"><code>// point from chars in s, or -1 if no Unicode code point from chars is</code></span>
<span class="codeline" id="line-174"><code>// present in s.</code></span>
<span class="codeline" id="line-175"><code>func LastIndexAny(s, chars string) int {</code></span>
<span class="codeline" id="line-176"><code>	if chars == "" {</code></span>
<span class="codeline" id="line-177"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-178"><code>		return -1</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>	if len(s) == 1 {</code></span>
<span class="codeline" id="line-181"><code>		rc := rune(s[0])</code></span>
<span class="codeline" id="line-182"><code>		if rc &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-183"><code>			rc = utf8.RuneError</code></span>
<span class="codeline" id="line-184"><code>		}</code></span>
<span class="codeline" id="line-185"><code>		if IndexRune(chars, rc) &gt;= 0 {</code></span>
<span class="codeline" id="line-186"><code>			return 0</code></span>
<span class="codeline" id="line-187"><code>		}</code></span>
<span class="codeline" id="line-188"><code>		return -1</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>	if len(s) &gt; 8 {</code></span>
<span class="codeline" id="line-191"><code>		if as, isASCII := makeASCIISet(chars); isASCII {</code></span>
<span class="codeline" id="line-192"><code>			for i := len(s) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-193"><code>				if as.contains(s[i]) {</code></span>
<span class="codeline" id="line-194"><code>					return i</code></span>
<span class="codeline" id="line-195"><code>				}</code></span>
<span class="codeline" id="line-196"><code>			}</code></span>
<span class="codeline" id="line-197"><code>			return -1</code></span>
<span class="codeline" id="line-198"><code>		}</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	if len(chars) == 1 {</code></span>
<span class="codeline" id="line-201"><code>		rc := rune(chars[0])</code></span>
<span class="codeline" id="line-202"><code>		if rc &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-203"><code>			rc = utf8.RuneError</code></span>
<span class="codeline" id="line-204"><code>		}</code></span>
<span class="codeline" id="line-205"><code>		for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-206"><code>			r, size := utf8.DecodeLastRuneInString(s[:i])</code></span>
<span class="codeline" id="line-207"><code>			i -= size</code></span>
<span class="codeline" id="line-208"><code>			if rc == r {</code></span>
<span class="codeline" id="line-209"><code>				return i</code></span>
<span class="codeline" id="line-210"><code>			}</code></span>
<span class="codeline" id="line-211"><code>		}</code></span>
<span class="codeline" id="line-212"><code>		return -1</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code>	for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-215"><code>		r, size := utf8.DecodeLastRuneInString(s[:i])</code></span>
<span class="codeline" id="line-216"><code>		i -= size</code></span>
<span class="codeline" id="line-217"><code>		if IndexRune(chars, r) &gt;= 0 {</code></span>
<span class="codeline" id="line-218"><code>			return i</code></span>
<span class="codeline" id="line-219"><code>		}</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code>	return -1</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</code></span>
<span class="codeline" id="line-225"><code>func LastIndexByte(s string, c byte) int {</code></span>
<span class="codeline" id="line-226"><code>	for i := len(s) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-227"><code>		if s[i] == c {</code></span>
<span class="codeline" id="line-228"><code>			return i</code></span>
<span class="codeline" id="line-229"><code>		}</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	return -1</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// Generic split: splits after each instance of sep,</code></span>
<span class="codeline" id="line-235"><code>// including sepSave bytes of sep in the subarrays.</code></span>
<span class="codeline" id="line-236"><code>func genSplit(s, sep string, sepSave, n int) []string {</code></span>
<span class="codeline" id="line-237"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-238"><code>		return nil</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code>	if sep == "" {</code></span>
<span class="codeline" id="line-241"><code>		return explode(s, n)</code></span>
<span class="codeline" id="line-242"><code>	}</code></span>
<span class="codeline" id="line-243"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-244"><code>		n = Count(s, sep) + 1</code></span>
<span class="codeline" id="line-245"><code>	}</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-248"><code>	n--</code></span>
<span class="codeline" id="line-249"><code>	i := 0</code></span>
<span class="codeline" id="line-250"><code>	for i &lt; n {</code></span>
<span class="codeline" id="line-251"><code>		m := Index(s, sep)</code></span>
<span class="codeline" id="line-252"><code>		if m &lt; 0 {</code></span>
<span class="codeline" id="line-253"><code>			break</code></span>
<span class="codeline" id="line-254"><code>		}</code></span>
<span class="codeline" id="line-255"><code>		a[i] = s[:m+sepSave]</code></span>
<span class="codeline" id="line-256"><code>		s = s[m+len(sep):]</code></span>
<span class="codeline" id="line-257"><code>		i++</code></span>
<span class="codeline" id="line-258"><code>	}</code></span>
<span class="codeline" id="line-259"><code>	a[i] = s</code></span>
<span class="codeline" id="line-260"><code>	return a[:i+1]</code></span>
<span class="codeline" id="line-261"><code>}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>// SplitN slices s into substrings separated by sep and returns a slice of</code></span>
<span class="codeline" id="line-264"><code>// the substrings between those separators.</code></span>
<span class="codeline" id="line-265"><code>//</code></span>
<span class="codeline" id="line-266"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-267"><code>//   n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-268"><code>//   n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-269"><code>//   n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-270"><code>//</code></span>
<span class="codeline" id="line-271"><code>// Edge cases for s and sep (for example, empty strings) are handled</code></span>
<span class="codeline" id="line-272"><code>// as described in the documentation for Split.</code></span>
<span class="codeline" id="line-273"><code>func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>// SplitAfterN slices s into substrings after each instance of sep and</code></span>
<span class="codeline" id="line-276"><code>// returns a slice of those substrings.</code></span>
<span class="codeline" id="line-277"><code>//</code></span>
<span class="codeline" id="line-278"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-279"><code>//   n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-280"><code>//   n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-281"><code>//   n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-282"><code>//</code></span>
<span class="codeline" id="line-283"><code>// Edge cases for s and sep (for example, empty strings) are handled</code></span>
<span class="codeline" id="line-284"><code>// as described in the documentation for SplitAfter.</code></span>
<span class="codeline" id="line-285"><code>func SplitAfterN(s, sep string, n int) []string {</code></span>
<span class="codeline" id="line-286"><code>	return genSplit(s, sep, len(sep), n)</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>// Split slices s into all substrings separated by sep and returns a slice of</code></span>
<span class="codeline" id="line-290"><code>// the substrings between those separators.</code></span>
<span class="codeline" id="line-291"><code>//</code></span>
<span class="codeline" id="line-292"><code>// If s does not contain sep and sep is not empty, Split returns a</code></span>
<span class="codeline" id="line-293"><code>// slice of length 1 whose only element is s.</code></span>
<span class="codeline" id="line-294"><code>//</code></span>
<span class="codeline" id="line-295"><code>// If sep is empty, Split splits after each UTF-8 sequence. If both s</code></span>
<span class="codeline" id="line-296"><code>// and sep are empty, Split returns an empty slice.</code></span>
<span class="codeline" id="line-297"><code>//</code></span>
<span class="codeline" id="line-298"><code>// It is equivalent to SplitN with a count of -1.</code></span>
<span class="codeline" id="line-299"><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// SplitAfter slices s into all substrings after each instance of sep and</code></span>
<span class="codeline" id="line-302"><code>// returns a slice of those substrings.</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>// If s does not contain sep and sep is not empty, SplitAfter returns</code></span>
<span class="codeline" id="line-305"><code>// a slice of length 1 whose only element is s.</code></span>
<span class="codeline" id="line-306"><code>//</code></span>
<span class="codeline" id="line-307"><code>// If sep is empty, SplitAfter splits after each UTF-8 sequence. If</code></span>
<span class="codeline" id="line-308"><code>// both s and sep are empty, SplitAfter returns an empty slice.</code></span>
<span class="codeline" id="line-309"><code>//</code></span>
<span class="codeline" id="line-310"><code>// It is equivalent to SplitAfterN with a count of -1.</code></span>
<span class="codeline" id="line-311"><code>func SplitAfter(s, sep string) []string {</code></span>
<span class="codeline" id="line-312"><code>	return genSplit(s, sep, len(sep), -1)</code></span>
<span class="codeline" id="line-313"><code>}</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>var asciiSpace = [256]uint8{'\t': 1, '\n': 1, '\v': 1, '\f': 1, '\r': 1, ' ': 1}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// Fields splits the string s around each instance of one or more consecutive white space</code></span>
<span class="codeline" id="line-318"><code>// characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an</code></span>
<span class="codeline" id="line-319"><code>// empty slice if s contains only white space.</code></span>
<span class="codeline" id="line-320"><code>func Fields(s string) []string {</code></span>
<span class="codeline" id="line-321"><code>	// First count the fields.</code></span>
<span class="codeline" id="line-322"><code>	// This is an exact count if s is ASCII, otherwise it is an approximation.</code></span>
<span class="codeline" id="line-323"><code>	n := 0</code></span>
<span class="codeline" id="line-324"><code>	wasSpace := 1</code></span>
<span class="codeline" id="line-325"><code>	// setBits is used to track which bits are set in the bytes of s.</code></span>
<span class="codeline" id="line-326"><code>	setBits := uint8(0)</code></span>
<span class="codeline" id="line-327"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-328"><code>		r := s[i]</code></span>
<span class="codeline" id="line-329"><code>		setBits |= r</code></span>
<span class="codeline" id="line-330"><code>		isSpace := int(asciiSpace[r])</code></span>
<span class="codeline" id="line-331"><code>		n += wasSpace &amp; ^isSpace</code></span>
<span class="codeline" id="line-332"><code>		wasSpace = isSpace</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>	if setBits &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-336"><code>		// Some runes in the input string are not ASCII.</code></span>
<span class="codeline" id="line-337"><code>		return FieldsFunc(s, unicode.IsSpace)</code></span>
<span class="codeline" id="line-338"><code>	}</code></span>
<span class="codeline" id="line-339"><code>	// ASCII fast path</code></span>
<span class="codeline" id="line-340"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-341"><code>	na := 0</code></span>
<span class="codeline" id="line-342"><code>	fieldStart := 0</code></span>
<span class="codeline" id="line-343"><code>	i := 0</code></span>
<span class="codeline" id="line-344"><code>	// Skip spaces in the front of the input.</code></span>
<span class="codeline" id="line-345"><code>	for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 {</code></span>
<span class="codeline" id="line-346"><code>		i++</code></span>
<span class="codeline" id="line-347"><code>	}</code></span>
<span class="codeline" id="line-348"><code>	fieldStart = i</code></span>
<span class="codeline" id="line-349"><code>	for i &lt; len(s) {</code></span>
<span class="codeline" id="line-350"><code>		if asciiSpace[s[i]] == 0 {</code></span>
<span class="codeline" id="line-351"><code>			i++</code></span>
<span class="codeline" id="line-352"><code>			continue</code></span>
<span class="codeline" id="line-353"><code>		}</code></span>
<span class="codeline" id="line-354"><code>		a[na] = s[fieldStart:i]</code></span>
<span class="codeline" id="line-355"><code>		na++</code></span>
<span class="codeline" id="line-356"><code>		i++</code></span>
<span class="codeline" id="line-357"><code>		// Skip spaces in between fields.</code></span>
<span class="codeline" id="line-358"><code>		for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 {</code></span>
<span class="codeline" id="line-359"><code>			i++</code></span>
<span class="codeline" id="line-360"><code>		}</code></span>
<span class="codeline" id="line-361"><code>		fieldStart = i</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>	if fieldStart &lt; len(s) { // Last field might end at EOF.</code></span>
<span class="codeline" id="line-364"><code>		a[na] = s[fieldStart:]</code></span>
<span class="codeline" id="line-365"><code>	}</code></span>
<span class="codeline" id="line-366"><code>	return a</code></span>
<span class="codeline" id="line-367"><code>}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)</code></span>
<span class="codeline" id="line-370"><code>// and returns an array of slices of s. If all code points in s satisfy f(c) or the</code></span>
<span class="codeline" id="line-371"><code>// string is empty, an empty slice is returned.</code></span>
<span class="codeline" id="line-372"><code>//</code></span>
<span class="codeline" id="line-373"><code>// FieldsFunc makes no guarantees about the order in which it calls f(c)</code></span>
<span class="codeline" id="line-374"><code>// and assumes that f always returns the same value for a given c.</code></span>
<span class="codeline" id="line-375"><code>func FieldsFunc(s string, f func(rune) bool) []string {</code></span>
<span class="codeline" id="line-376"><code>	// A span is used to record a slice of s of the form s[start:end].</code></span>
<span class="codeline" id="line-377"><code>	// The start index is inclusive and the end index is exclusive.</code></span>
<span class="codeline" id="line-378"><code>	type span struct {</code></span>
<span class="codeline" id="line-379"><code>		start int</code></span>
<span class="codeline" id="line-380"><code>		end   int</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code>	spans := make([]span, 0, 32)</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	// Find the field start and end indices.</code></span>
<span class="codeline" id="line-385"><code>	// Doing this in a separate pass (rather than slicing the string s</code></span>
<span class="codeline" id="line-386"><code>	// and collecting the result substrings right away) is significantly</code></span>
<span class="codeline" id="line-387"><code>	// more efficient, possibly due to cache effects.</code></span>
<span class="codeline" id="line-388"><code>	start := -1 // valid span start if &gt;= 0</code></span>
<span class="codeline" id="line-389"><code>	for end, rune := range s {</code></span>
<span class="codeline" id="line-390"><code>		if f(rune) {</code></span>
<span class="codeline" id="line-391"><code>			if start &gt;= 0 {</code></span>
<span class="codeline" id="line-392"><code>				spans = append(spans, span{start, end})</code></span>
<span class="codeline" id="line-393"><code>				// Set start to a negative value.</code></span>
<span class="codeline" id="line-394"><code>				// Note: using -1 here consistently and reproducibly</code></span>
<span class="codeline" id="line-395"><code>				// slows down this code by a several percent on amd64.</code></span>
<span class="codeline" id="line-396"><code>				start = ^start</code></span>
<span class="codeline" id="line-397"><code>			}</code></span>
<span class="codeline" id="line-398"><code>		} else {</code></span>
<span class="codeline" id="line-399"><code>			if start &lt; 0 {</code></span>
<span class="codeline" id="line-400"><code>				start = end</code></span>
<span class="codeline" id="line-401"><code>			}</code></span>
<span class="codeline" id="line-402"><code>		}</code></span>
<span class="codeline" id="line-403"><code>	}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>	// Last field might end at EOF.</code></span>
<span class="codeline" id="line-406"><code>	if start &gt;= 0 {</code></span>
<span class="codeline" id="line-407"><code>		spans = append(spans, span{start, len(s)})</code></span>
<span class="codeline" id="line-408"><code>	}</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>	// Create strings from recorded field indices.</code></span>
<span class="codeline" id="line-411"><code>	a := make([]string, len(spans))</code></span>
<span class="codeline" id="line-412"><code>	for i, span := range spans {</code></span>
<span class="codeline" id="line-413"><code>		a[i] = s[span.start:span.end]</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>	return a</code></span>
<span class="codeline" id="line-417"><code>}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>// Join concatenates the elements of its first argument to create a single string. The separator</code></span>
<span class="codeline" id="line-420"><code>// string sep is placed between elements in the resulting string.</code></span>
<span class="codeline" id="line-421"><code>func Join(elems []string, sep string) string {</code></span>
<span class="codeline" id="line-422"><code>	switch len(elems) {</code></span>
<span class="codeline" id="line-423"><code>	case 0:</code></span>
<span class="codeline" id="line-424"><code>		return ""</code></span>
<span class="codeline" id="line-425"><code>	case 1:</code></span>
<span class="codeline" id="line-426"><code>		return elems[0]</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	n := len(sep) * (len(elems) - 1)</code></span>
<span class="codeline" id="line-429"><code>	for i := 0; i &lt; len(elems); i++ {</code></span>
<span class="codeline" id="line-430"><code>		n += len(elems[i])</code></span>
<span class="codeline" id="line-431"><code>	}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>	var b Builder</code></span>
<span class="codeline" id="line-434"><code>	b.Grow(n)</code></span>
<span class="codeline" id="line-435"><code>	b.WriteString(elems[0])</code></span>
<span class="codeline" id="line-436"><code>	for _, s := range elems[1:] {</code></span>
<span class="codeline" id="line-437"><code>		b.WriteString(sep)</code></span>
<span class="codeline" id="line-438"><code>		b.WriteString(s)</code></span>
<span class="codeline" id="line-439"><code>	}</code></span>
<span class="codeline" id="line-440"><code>	return b.String()</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>// HasPrefix tests whether the string s begins with prefix.</code></span>
<span class="codeline" id="line-444"><code>func HasPrefix(s, prefix string) bool {</code></span>
<span class="codeline" id="line-445"><code>	return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix</code></span>
<span class="codeline" id="line-446"><code>}</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>// HasSuffix tests whether the string s ends with suffix.</code></span>
<span class="codeline" id="line-449"><code>func HasSuffix(s, suffix string) bool {</code></span>
<span class="codeline" id="line-450"><code>	return len(s) &gt;= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>// Map returns a copy of the string s with all its characters modified</code></span>
<span class="codeline" id="line-454"><code>// according to the mapping function. If mapping returns a negative value, the character is</code></span>
<span class="codeline" id="line-455"><code>// dropped from the string with no replacement.</code></span>
<span class="codeline" id="line-456"><code>func Map(mapping func(rune) rune, s string) string {</code></span>
<span class="codeline" id="line-457"><code>	// In the worst case, the string can grow when mapped, making</code></span>
<span class="codeline" id="line-458"><code>	// things unpleasant. But it's so rare we barge in assuming it's</code></span>
<span class="codeline" id="line-459"><code>	// fine. It could also shrink but that falls out naturally.</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	// The output buffer b is initialized on demand, the first</code></span>
<span class="codeline" id="line-462"><code>	// time a character differs.</code></span>
<span class="codeline" id="line-463"><code>	var b Builder</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-466"><code>		r := mapping(c)</code></span>
<span class="codeline" id="line-467"><code>		if r == c &amp;&amp; c != utf8.RuneError {</code></span>
<span class="codeline" id="line-468"><code>			continue</code></span>
<span class="codeline" id="line-469"><code>		}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>		var width int</code></span>
<span class="codeline" id="line-472"><code>		if c == utf8.RuneError {</code></span>
<span class="codeline" id="line-473"><code>			c, width = utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-474"><code>			if width != 1 &amp;&amp; r == c {</code></span>
<span class="codeline" id="line-475"><code>				continue</code></span>
<span class="codeline" id="line-476"><code>			}</code></span>
<span class="codeline" id="line-477"><code>		} else {</code></span>
<span class="codeline" id="line-478"><code>			width = utf8.RuneLen(c)</code></span>
<span class="codeline" id="line-479"><code>		}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>		b.Grow(len(s) + utf8.UTFMax)</code></span>
<span class="codeline" id="line-482"><code>		b.WriteString(s[:i])</code></span>
<span class="codeline" id="line-483"><code>		if r &gt;= 0 {</code></span>
<span class="codeline" id="line-484"><code>			b.WriteRune(r)</code></span>
<span class="codeline" id="line-485"><code>		}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>		s = s[i+width:]</code></span>
<span class="codeline" id="line-488"><code>		break</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code></code></span>
<span class="codeline" id="line-491"><code>	// Fast path for unchanged input</code></span>
<span class="codeline" id="line-492"><code>	if b.Cap() == 0 { // didn't call b.Grow above</code></span>
<span class="codeline" id="line-493"><code>		return s</code></span>
<span class="codeline" id="line-494"><code>	}</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>	for _, c := range s {</code></span>
<span class="codeline" id="line-497"><code>		r := mapping(c)</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>		if r &gt;= 0 {</code></span>
<span class="codeline" id="line-500"><code>			// common case</code></span>
<span class="codeline" id="line-501"><code>			// Due to inlining, it is more performant to determine if WriteByte should be</code></span>
<span class="codeline" id="line-502"><code>			// invoked rather than always call WriteRune</code></span>
<span class="codeline" id="line-503"><code>			if r &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-504"><code>				b.WriteByte(byte(r))</code></span>
<span class="codeline" id="line-505"><code>			} else {</code></span>
<span class="codeline" id="line-506"><code>				// r is not a ASCII rune.</code></span>
<span class="codeline" id="line-507"><code>				b.WriteRune(r)</code></span>
<span class="codeline" id="line-508"><code>			}</code></span>
<span class="codeline" id="line-509"><code>		}</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>	return b.String()</code></span>
<span class="codeline" id="line-513"><code>}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>// Repeat returns a new string consisting of count copies of the string s.</code></span>
<span class="codeline" id="line-516"><code>//</code></span>
<span class="codeline" id="line-517"><code>// It panics if count is negative or if</code></span>
<span class="codeline" id="line-518"><code>// the result of (len(s) * count) overflows.</code></span>
<span class="codeline" id="line-519"><code>func Repeat(s string, count int) string {</code></span>
<span class="codeline" id="line-520"><code>	if count == 0 {</code></span>
<span class="codeline" id="line-521"><code>		return ""</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	// Since we cannot return an error on overflow,</code></span>
<span class="codeline" id="line-525"><code>	// we should panic if the repeat will generate</code></span>
<span class="codeline" id="line-526"><code>	// an overflow.</code></span>
<span class="codeline" id="line-527"><code>	// See Issue golang.org/issue/16237</code></span>
<span class="codeline" id="line-528"><code>	if count &lt; 0 {</code></span>
<span class="codeline" id="line-529"><code>		panic("strings: negative Repeat count")</code></span>
<span class="codeline" id="line-530"><code>	} else if len(s)*count/count != len(s) {</code></span>
<span class="codeline" id="line-531"><code>		panic("strings: Repeat count causes overflow")</code></span>
<span class="codeline" id="line-532"><code>	}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>	n := len(s) * count</code></span>
<span class="codeline" id="line-535"><code>	var b Builder</code></span>
<span class="codeline" id="line-536"><code>	b.Grow(n)</code></span>
<span class="codeline" id="line-537"><code>	b.WriteString(s)</code></span>
<span class="codeline" id="line-538"><code>	for b.Len() &lt; n {</code></span>
<span class="codeline" id="line-539"><code>		if b.Len() &lt;= n/2 {</code></span>
<span class="codeline" id="line-540"><code>			b.WriteString(b.String())</code></span>
<span class="codeline" id="line-541"><code>		} else {</code></span>
<span class="codeline" id="line-542"><code>			b.WriteString(b.String()[:n-b.Len()])</code></span>
<span class="codeline" id="line-543"><code>			break</code></span>
<span class="codeline" id="line-544"><code>		}</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code>	return b.String()</code></span>
<span class="codeline" id="line-547"><code>}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>// ToUpper returns s with all Unicode letters mapped to their upper case.</code></span>
<span class="codeline" id="line-550"><code>func ToUpper(s string) string {</code></span>
<span class="codeline" id="line-551"><code>	isASCII, hasLower := true, false</code></span>
<span class="codeline" id="line-552"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-553"><code>		c := s[i]</code></span>
<span class="codeline" id="line-554"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-555"><code>			isASCII = false</code></span>
<span class="codeline" id="line-556"><code>			break</code></span>
<span class="codeline" id="line-557"><code>		}</code></span>
<span class="codeline" id="line-558"><code>		hasLower = hasLower || ('a' &lt;= c &amp;&amp; c &lt;= 'z')</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code></code></span>
<span class="codeline" id="line-561"><code>	if isASCII { // optimize for ASCII-only strings.</code></span>
<span class="codeline" id="line-562"><code>		if !hasLower {</code></span>
<span class="codeline" id="line-563"><code>			return s</code></span>
<span class="codeline" id="line-564"><code>		}</code></span>
<span class="codeline" id="line-565"><code>		var b Builder</code></span>
<span class="codeline" id="line-566"><code>		b.Grow(len(s))</code></span>
<span class="codeline" id="line-567"><code>		for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-568"><code>			c := s[i]</code></span>
<span class="codeline" id="line-569"><code>			if 'a' &lt;= c &amp;&amp; c &lt;= 'z' {</code></span>
<span class="codeline" id="line-570"><code>				c -= 'a' - 'A'</code></span>
<span class="codeline" id="line-571"><code>			}</code></span>
<span class="codeline" id="line-572"><code>			b.WriteByte(c)</code></span>
<span class="codeline" id="line-573"><code>		}</code></span>
<span class="codeline" id="line-574"><code>		return b.String()</code></span>
<span class="codeline" id="line-575"><code>	}</code></span>
<span class="codeline" id="line-576"><code>	return Map(unicode.ToUpper, s)</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// ToLower returns s with all Unicode letters mapped to their lower case.</code></span>
<span class="codeline" id="line-580"><code>func ToLower(s string) string {</code></span>
<span class="codeline" id="line-581"><code>	isASCII, hasUpper := true, false</code></span>
<span class="codeline" id="line-582"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-583"><code>		c := s[i]</code></span>
<span class="codeline" id="line-584"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-585"><code>			isASCII = false</code></span>
<span class="codeline" id="line-586"><code>			break</code></span>
<span class="codeline" id="line-587"><code>		}</code></span>
<span class="codeline" id="line-588"><code>		hasUpper = hasUpper || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code></code></span>
<span class="codeline" id="line-591"><code>	if isASCII { // optimize for ASCII-only strings.</code></span>
<span class="codeline" id="line-592"><code>		if !hasUpper {</code></span>
<span class="codeline" id="line-593"><code>			return s</code></span>
<span class="codeline" id="line-594"><code>		}</code></span>
<span class="codeline" id="line-595"><code>		var b Builder</code></span>
<span class="codeline" id="line-596"><code>		b.Grow(len(s))</code></span>
<span class="codeline" id="line-597"><code>		for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-598"><code>			c := s[i]</code></span>
<span class="codeline" id="line-599"><code>			if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-600"><code>				c += 'a' - 'A'</code></span>
<span class="codeline" id="line-601"><code>			}</code></span>
<span class="codeline" id="line-602"><code>			b.WriteByte(c)</code></span>
<span class="codeline" id="line-603"><code>		}</code></span>
<span class="codeline" id="line-604"><code>		return b.String()</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code>	return Map(unicode.ToLower, s)</code></span>
<span class="codeline" id="line-607"><code>}</code></span>
<span class="codeline" id="line-608"><code></code></span>
<span class="codeline" id="line-609"><code>// ToTitle returns a copy of the string s with all Unicode letters mapped to</code></span>
<span class="codeline" id="line-610"><code>// their Unicode title case.</code></span>
<span class="codeline" id="line-611"><code>func ToTitle(s string) string { return Map(unicode.ToTitle, s) }</code></span>
<span class="codeline" id="line-612"><code></code></span>
<span class="codeline" id="line-613"><code>// ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-614"><code>// upper case using the case mapping specified by c.</code></span>
<span class="codeline" id="line-615"><code>func ToUpperSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-616"><code>	return Map(c.ToUpper, s)</code></span>
<span class="codeline" id="line-617"><code>}</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>// ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-620"><code>// lower case using the case mapping specified by c.</code></span>
<span class="codeline" id="line-621"><code>func ToLowerSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-622"><code>	return Map(c.ToLower, s)</code></span>
<span class="codeline" id="line-623"><code>}</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>// ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-626"><code>// Unicode title case, giving priority to the special casing rules.</code></span>
<span class="codeline" id="line-627"><code>func ToTitleSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-628"><code>	return Map(c.ToTitle, s)</code></span>
<span class="codeline" id="line-629"><code>}</code></span>
<span class="codeline" id="line-630"><code></code></span>
<span class="codeline" id="line-631"><code>// ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences</code></span>
<span class="codeline" id="line-632"><code>// replaced by the replacement string, which may be empty.</code></span>
<span class="codeline" id="line-633"><code>func ToValidUTF8(s, replacement string) string {</code></span>
<span class="codeline" id="line-634"><code>	var b Builder</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-637"><code>		if c != utf8.RuneError {</code></span>
<span class="codeline" id="line-638"><code>			continue</code></span>
<span class="codeline" id="line-639"><code>		}</code></span>
<span class="codeline" id="line-640"><code></code></span>
<span class="codeline" id="line-641"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-642"><code>		if wid == 1 {</code></span>
<span class="codeline" id="line-643"><code>			b.Grow(len(s) + len(replacement))</code></span>
<span class="codeline" id="line-644"><code>			b.WriteString(s[:i])</code></span>
<span class="codeline" id="line-645"><code>			s = s[i:]</code></span>
<span class="codeline" id="line-646"><code>			break</code></span>
<span class="codeline" id="line-647"><code>		}</code></span>
<span class="codeline" id="line-648"><code>	}</code></span>
<span class="codeline" id="line-649"><code></code></span>
<span class="codeline" id="line-650"><code>	// Fast path for unchanged input</code></span>
<span class="codeline" id="line-651"><code>	if b.Cap() == 0 { // didn't call b.Grow above</code></span>
<span class="codeline" id="line-652"><code>		return s</code></span>
<span class="codeline" id="line-653"><code>	}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>	invalid := false // previous byte was from an invalid UTF-8 sequence</code></span>
<span class="codeline" id="line-656"><code>	for i := 0; i &lt; len(s); {</code></span>
<span class="codeline" id="line-657"><code>		c := s[i]</code></span>
<span class="codeline" id="line-658"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-659"><code>			i++</code></span>
<span class="codeline" id="line-660"><code>			invalid = false</code></span>
<span class="codeline" id="line-661"><code>			b.WriteByte(c)</code></span>
<span class="codeline" id="line-662"><code>			continue</code></span>
<span class="codeline" id="line-663"><code>		}</code></span>
<span class="codeline" id="line-664"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-665"><code>		if wid == 1 {</code></span>
<span class="codeline" id="line-666"><code>			i++</code></span>
<span class="codeline" id="line-667"><code>			if !invalid {</code></span>
<span class="codeline" id="line-668"><code>				invalid = true</code></span>
<span class="codeline" id="line-669"><code>				b.WriteString(replacement)</code></span>
<span class="codeline" id="line-670"><code>			}</code></span>
<span class="codeline" id="line-671"><code>			continue</code></span>
<span class="codeline" id="line-672"><code>		}</code></span>
<span class="codeline" id="line-673"><code>		invalid = false</code></span>
<span class="codeline" id="line-674"><code>		b.WriteString(s[i : i+wid])</code></span>
<span class="codeline" id="line-675"><code>		i += wid</code></span>
<span class="codeline" id="line-676"><code>	}</code></span>
<span class="codeline" id="line-677"><code></code></span>
<span class="codeline" id="line-678"><code>	return b.String()</code></span>
<span class="codeline" id="line-679"><code>}</code></span>
<span class="codeline" id="line-680"><code></code></span>
<span class="codeline" id="line-681"><code>// isSeparator reports whether the rune could mark a word boundary.</code></span>
<span class="codeline" id="line-682"><code>// TODO: update when package unicode captures more of the properties.</code></span>
<span class="codeline" id="line-683"><code>func isSeparator(r rune) bool {</code></span>
<span class="codeline" id="line-684"><code>	// ASCII alphanumerics and underscore are not separators</code></span>
<span class="codeline" id="line-685"><code>	if r &lt;= 0x7F {</code></span>
<span class="codeline" id="line-686"><code>		switch {</code></span>
<span class="codeline" id="line-687"><code>		case '0' &lt;= r &amp;&amp; r &lt;= '9':</code></span>
<span class="codeline" id="line-688"><code>			return false</code></span>
<span class="codeline" id="line-689"><code>		case 'a' &lt;= r &amp;&amp; r &lt;= 'z':</code></span>
<span class="codeline" id="line-690"><code>			return false</code></span>
<span class="codeline" id="line-691"><code>		case 'A' &lt;= r &amp;&amp; r &lt;= 'Z':</code></span>
<span class="codeline" id="line-692"><code>			return false</code></span>
<span class="codeline" id="line-693"><code>		case r == '_':</code></span>
<span class="codeline" id="line-694"><code>			return false</code></span>
<span class="codeline" id="line-695"><code>		}</code></span>
<span class="codeline" id="line-696"><code>		return true</code></span>
<span class="codeline" id="line-697"><code>	}</code></span>
<span class="codeline" id="line-698"><code>	// Letters and digits are not separators</code></span>
<span class="codeline" id="line-699"><code>	if unicode.IsLetter(r) || unicode.IsDigit(r) {</code></span>
<span class="codeline" id="line-700"><code>		return false</code></span>
<span class="codeline" id="line-701"><code>	}</code></span>
<span class="codeline" id="line-702"><code>	// Otherwise, all we can do for now is treat spaces as separators.</code></span>
<span class="codeline" id="line-703"><code>	return unicode.IsSpace(r)</code></span>
<span class="codeline" id="line-704"><code>}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>// Title returns a copy of the string s with all Unicode letters that begin words</code></span>
<span class="codeline" id="line-707"><code>// mapped to their Unicode title case.</code></span>
<span class="codeline" id="line-708"><code>//</code></span>
<span class="codeline" id="line-709"><code>// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.</code></span>
<span class="codeline" id="line-710"><code>func Title(s string) string {</code></span>
<span class="codeline" id="line-711"><code>	// Use a closure here to remember state.</code></span>
<span class="codeline" id="line-712"><code>	// Hackish but effective. Depends on Map scanning in order and calling</code></span>
<span class="codeline" id="line-713"><code>	// the closure once per rune.</code></span>
<span class="codeline" id="line-714"><code>	prev := ' '</code></span>
<span class="codeline" id="line-715"><code>	return Map(</code></span>
<span class="codeline" id="line-716"><code>		func(r rune) rune {</code></span>
<span class="codeline" id="line-717"><code>			if isSeparator(prev) {</code></span>
<span class="codeline" id="line-718"><code>				prev = r</code></span>
<span class="codeline" id="line-719"><code>				return unicode.ToTitle(r)</code></span>
<span class="codeline" id="line-720"><code>			}</code></span>
<span class="codeline" id="line-721"><code>			prev = r</code></span>
<span class="codeline" id="line-722"><code>			return r</code></span>
<span class="codeline" id="line-723"><code>		},</code></span>
<span class="codeline" id="line-724"><code>		s)</code></span>
<span class="codeline" id="line-725"><code>}</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>// TrimLeftFunc returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-728"><code>// Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-729"><code>func TrimLeftFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-730"><code>	i := indexFunc(s, f, false)</code></span>
<span class="codeline" id="line-731"><code>	if i == -1 {</code></span>
<span class="codeline" id="line-732"><code>		return ""</code></span>
<span class="codeline" id="line-733"><code>	}</code></span>
<span class="codeline" id="line-734"><code>	return s[i:]</code></span>
<span class="codeline" id="line-735"><code>}</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>// TrimRightFunc returns a slice of the string s with all trailing</code></span>
<span class="codeline" id="line-738"><code>// Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-739"><code>func TrimRightFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-740"><code>	i := lastIndexFunc(s, f, false)</code></span>
<span class="codeline" id="line-741"><code>	if i &gt;= 0 &amp;&amp; s[i] &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-742"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-743"><code>		i += wid</code></span>
<span class="codeline" id="line-744"><code>	} else {</code></span>
<span class="codeline" id="line-745"><code>		i++</code></span>
<span class="codeline" id="line-746"><code>	}</code></span>
<span class="codeline" id="line-747"><code>	return s[0:i]</code></span>
<span class="codeline" id="line-748"><code>}</code></span>
<span class="codeline" id="line-749"><code></code></span>
<span class="codeline" id="line-750"><code>// TrimFunc returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-751"><code>// and trailing Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-752"><code>func TrimFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-753"><code>	return TrimRightFunc(TrimLeftFunc(s, f), f)</code></span>
<span class="codeline" id="line-754"><code>}</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>// IndexFunc returns the index into s of the first Unicode</code></span>
<span class="codeline" id="line-757"><code>// code point satisfying f(c), or -1 if none do.</code></span>
<span class="codeline" id="line-758"><code>func IndexFunc(s string, f func(rune) bool) int {</code></span>
<span class="codeline" id="line-759"><code>	return indexFunc(s, f, true)</code></span>
<span class="codeline" id="line-760"><code>}</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>// LastIndexFunc returns the index into s of the last</code></span>
<span class="codeline" id="line-763"><code>// Unicode code point satisfying f(c), or -1 if none do.</code></span>
<span class="codeline" id="line-764"><code>func LastIndexFunc(s string, f func(rune) bool) int {</code></span>
<span class="codeline" id="line-765"><code>	return lastIndexFunc(s, f, true)</code></span>
<span class="codeline" id="line-766"><code>}</code></span>
<span class="codeline" id="line-767"><code></code></span>
<span class="codeline" id="line-768"><code>// indexFunc is the same as IndexFunc except that if</code></span>
<span class="codeline" id="line-769"><code>// truth==false, the sense of the predicate function is</code></span>
<span class="codeline" id="line-770"><code>// inverted.</code></span>
<span class="codeline" id="line-771"><code>func indexFunc(s string, f func(rune) bool, truth bool) int {</code></span>
<span class="codeline" id="line-772"><code>	for i, r := range s {</code></span>
<span class="codeline" id="line-773"><code>		if f(r) == truth {</code></span>
<span class="codeline" id="line-774"><code>			return i</code></span>
<span class="codeline" id="line-775"><code>		}</code></span>
<span class="codeline" id="line-776"><code>	}</code></span>
<span class="codeline" id="line-777"><code>	return -1</code></span>
<span class="codeline" id="line-778"><code>}</code></span>
<span class="codeline" id="line-779"><code></code></span>
<span class="codeline" id="line-780"><code>// lastIndexFunc is the same as LastIndexFunc except that if</code></span>
<span class="codeline" id="line-781"><code>// truth==false, the sense of the predicate function is</code></span>
<span class="codeline" id="line-782"><code>// inverted.</code></span>
<span class="codeline" id="line-783"><code>func lastIndexFunc(s string, f func(rune) bool, truth bool) int {</code></span>
<span class="codeline" id="line-784"><code>	for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-785"><code>		r, size := utf8.DecodeLastRuneInString(s[0:i])</code></span>
<span class="codeline" id="line-786"><code>		i -= size</code></span>
<span class="codeline" id="line-787"><code>		if f(r) == truth {</code></span>
<span class="codeline" id="line-788"><code>			return i</code></span>
<span class="codeline" id="line-789"><code>		}</code></span>
<span class="codeline" id="line-790"><code>	}</code></span>
<span class="codeline" id="line-791"><code>	return -1</code></span>
<span class="codeline" id="line-792"><code>}</code></span>
<span class="codeline" id="line-793"><code></code></span>
<span class="codeline" id="line-794"><code>// asciiSet is a 32-byte value, where each bit represents the presence of a</code></span>
<span class="codeline" id="line-795"><code>// given ASCII character in the set. The 128-bits of the lower 16 bytes,</code></span>
<span class="codeline" id="line-796"><code>// starting with the least-significant bit of the lowest word to the</code></span>
<span class="codeline" id="line-797"><code>// most-significant bit of the highest word, map to the full range of all</code></span>
<span class="codeline" id="line-798"><code>// 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,</code></span>
<span class="codeline" id="line-799"><code>// ensuring that any non-ASCII character will be reported as not in the set.</code></span>
<span class="codeline" id="line-800"><code>type asciiSet [8]uint32</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>// makeASCIISet creates a set of ASCII characters and reports whether all</code></span>
<span class="codeline" id="line-803"><code>// characters in chars are ASCII.</code></span>
<span class="codeline" id="line-804"><code>func makeASCIISet(chars string) (as asciiSet, ok bool) {</code></span>
<span class="codeline" id="line-805"><code>	for i := 0; i &lt; len(chars); i++ {</code></span>
<span class="codeline" id="line-806"><code>		c := chars[i]</code></span>
<span class="codeline" id="line-807"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-808"><code>			return as, false</code></span>
<span class="codeline" id="line-809"><code>		}</code></span>
<span class="codeline" id="line-810"><code>		as[c&gt;&gt;5] |= 1 &lt;&lt; uint(c&amp;31)</code></span>
<span class="codeline" id="line-811"><code>	}</code></span>
<span class="codeline" id="line-812"><code>	return as, true</code></span>
<span class="codeline" id="line-813"><code>}</code></span>
<span class="codeline" id="line-814"><code></code></span>
<span class="codeline" id="line-815"><code>// contains reports whether c is inside the set.</code></span>
<span class="codeline" id="line-816"><code>func (as *asciiSet) contains(c byte) bool {</code></span>
<span class="codeline" id="line-817"><code>	return (as[c&gt;&gt;5] &amp; (1 &lt;&lt; uint(c&amp;31))) != 0</code></span>
<span class="codeline" id="line-818"><code>}</code></span>
<span class="codeline" id="line-819"><code></code></span>
<span class="codeline" id="line-820"><code>func makeCutsetFunc(cutset string) func(rune) bool {</code></span>
<span class="codeline" id="line-821"><code>	if len(cutset) == 1 &amp;&amp; cutset[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-822"><code>		return func(r rune) bool {</code></span>
<span class="codeline" id="line-823"><code>			return r == rune(cutset[0])</code></span>
<span class="codeline" id="line-824"><code>		}</code></span>
<span class="codeline" id="line-825"><code>	}</code></span>
<span class="codeline" id="line-826"><code>	if as, isASCII := makeASCIISet(cutset); isASCII {</code></span>
<span class="codeline" id="line-827"><code>		return func(r rune) bool {</code></span>
<span class="codeline" id="line-828"><code>			return r &lt; utf8.RuneSelf &amp;&amp; as.contains(byte(r))</code></span>
<span class="codeline" id="line-829"><code>		}</code></span>
<span class="codeline" id="line-830"><code>	}</code></span>
<span class="codeline" id="line-831"><code>	return func(r rune) bool { return IndexRune(cutset, r) &gt;= 0 }</code></span>
<span class="codeline" id="line-832"><code>}</code></span>
<span class="codeline" id="line-833"><code></code></span>
<span class="codeline" id="line-834"><code>// Trim returns a slice of the string s with all leading and</code></span>
<span class="codeline" id="line-835"><code>// trailing Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-836"><code>func Trim(s, cutset string) string {</code></span>
<span class="codeline" id="line-837"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-838"><code>		return s</code></span>
<span class="codeline" id="line-839"><code>	}</code></span>
<span class="codeline" id="line-840"><code>	return TrimFunc(s, makeCutsetFunc(cutset))</code></span>
<span class="codeline" id="line-841"><code>}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>// TrimLeft returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-844"><code>// Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-845"><code>//</code></span>
<span class="codeline" id="line-846"><code>// To remove a prefix, use TrimPrefix instead.</code></span>
<span class="codeline" id="line-847"><code>func TrimLeft(s, cutset string) string {</code></span>
<span class="codeline" id="line-848"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-849"><code>		return s</code></span>
<span class="codeline" id="line-850"><code>	}</code></span>
<span class="codeline" id="line-851"><code>	return TrimLeftFunc(s, makeCutsetFunc(cutset))</code></span>
<span class="codeline" id="line-852"><code>}</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>// TrimRight returns a slice of the string s, with all trailing</code></span>
<span class="codeline" id="line-855"><code>// Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-856"><code>//</code></span>
<span class="codeline" id="line-857"><code>// To remove a suffix, use TrimSuffix instead.</code></span>
<span class="codeline" id="line-858"><code>func TrimRight(s, cutset string) string {</code></span>
<span class="codeline" id="line-859"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-860"><code>		return s</code></span>
<span class="codeline" id="line-861"><code>	}</code></span>
<span class="codeline" id="line-862"><code>	return TrimRightFunc(s, makeCutsetFunc(cutset))</code></span>
<span class="codeline" id="line-863"><code>}</code></span>
<span class="codeline" id="line-864"><code></code></span>
<span class="codeline" id="line-865"><code>// TrimSpace returns a slice of the string s, with all leading</code></span>
<span class="codeline" id="line-866"><code>// and trailing white space removed, as defined by Unicode.</code></span>
<span class="codeline" id="line-867"><code>func TrimSpace(s string) string {</code></span>
<span class="codeline" id="line-868"><code>	// Fast path for ASCII: look for the first ASCII non-space byte</code></span>
<span class="codeline" id="line-869"><code>	start := 0</code></span>
<span class="codeline" id="line-870"><code>	for ; start &lt; len(s); start++ {</code></span>
<span class="codeline" id="line-871"><code>		c := s[start]</code></span>
<span class="codeline" id="line-872"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-873"><code>			// If we run into a non-ASCII byte, fall back to the</code></span>
<span class="codeline" id="line-874"><code>			// slower unicode-aware method on the remaining bytes</code></span>
<span class="codeline" id="line-875"><code>			return TrimFunc(s[start:], unicode.IsSpace)</code></span>
<span class="codeline" id="line-876"><code>		}</code></span>
<span class="codeline" id="line-877"><code>		if asciiSpace[c] == 0 {</code></span>
<span class="codeline" id="line-878"><code>			break</code></span>
<span class="codeline" id="line-879"><code>		}</code></span>
<span class="codeline" id="line-880"><code>	}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>	// Now look for the first ASCII non-space byte from the end</code></span>
<span class="codeline" id="line-883"><code>	stop := len(s)</code></span>
<span class="codeline" id="line-884"><code>	for ; stop &gt; start; stop-- {</code></span>
<span class="codeline" id="line-885"><code>		c := s[stop-1]</code></span>
<span class="codeline" id="line-886"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-887"><code>			return TrimFunc(s[start:stop], unicode.IsSpace)</code></span>
<span class="codeline" id="line-888"><code>		}</code></span>
<span class="codeline" id="line-889"><code>		if asciiSpace[c] == 0 {</code></span>
<span class="codeline" id="line-890"><code>			break</code></span>
<span class="codeline" id="line-891"><code>		}</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>	// At this point s[start:stop] starts and ends with an ASCII</code></span>
<span class="codeline" id="line-895"><code>	// non-space bytes, so we're done. Non-ASCII cases have already</code></span>
<span class="codeline" id="line-896"><code>	// been handled above.</code></span>
<span class="codeline" id="line-897"><code>	return s[start:stop]</code></span>
<span class="codeline" id="line-898"><code>}</code></span>
<span class="codeline" id="line-899"><code></code></span>
<span class="codeline" id="line-900"><code>// TrimPrefix returns s without the provided leading prefix string.</code></span>
<span class="codeline" id="line-901"><code>// If s doesn't start with prefix, s is returned unchanged.</code></span>
<span class="codeline" id="line-902"><code>func TrimPrefix(s, prefix string) string {</code></span>
<span class="codeline" id="line-903"><code>	if HasPrefix(s, prefix) {</code></span>
<span class="codeline" id="line-904"><code>		return s[len(prefix):]</code></span>
<span class="codeline" id="line-905"><code>	}</code></span>
<span class="codeline" id="line-906"><code>	return s</code></span>
<span class="codeline" id="line-907"><code>}</code></span>
<span class="codeline" id="line-908"><code></code></span>
<span class="codeline" id="line-909"><code>// TrimSuffix returns s without the provided trailing suffix string.</code></span>
<span class="codeline" id="line-910"><code>// If s doesn't end with suffix, s is returned unchanged.</code></span>
<span class="codeline" id="line-911"><code>func TrimSuffix(s, suffix string) string {</code></span>
<span class="codeline" id="line-912"><code>	if HasSuffix(s, suffix) {</code></span>
<span class="codeline" id="line-913"><code>		return s[:len(s)-len(suffix)]</code></span>
<span class="codeline" id="line-914"><code>	}</code></span>
<span class="codeline" id="line-915"><code>	return s</code></span>
<span class="codeline" id="line-916"><code>}</code></span>
<span class="codeline" id="line-917"><code></code></span>
<span class="codeline" id="line-918"><code>// Replace returns a copy of the string s with the first n</code></span>
<span class="codeline" id="line-919"><code>// non-overlapping instances of old replaced by new.</code></span>
<span class="codeline" id="line-920"><code>// If old is empty, it matches at the beginning of the string</code></span>
<span class="codeline" id="line-921"><code>// and after each UTF-8 sequence, yielding up to k+1 replacements</code></span>
<span class="codeline" id="line-922"><code>// for a k-rune string.</code></span>
<span class="codeline" id="line-923"><code>// If n &lt; 0, there is no limit on the number of replacements.</code></span>
<span class="codeline" id="line-924"><code>func Replace(s, old, new string, n int) string {</code></span>
<span class="codeline" id="line-925"><code>	if old == new || n == 0 {</code></span>
<span class="codeline" id="line-926"><code>		return s // avoid allocation</code></span>
<span class="codeline" id="line-927"><code>	}</code></span>
<span class="codeline" id="line-928"><code></code></span>
<span class="codeline" id="line-929"><code>	// Compute number of replacements.</code></span>
<span class="codeline" id="line-930"><code>	if m := Count(s, old); m == 0 {</code></span>
<span class="codeline" id="line-931"><code>		return s // avoid allocation</code></span>
<span class="codeline" id="line-932"><code>	} else if n &lt; 0 || m &lt; n {</code></span>
<span class="codeline" id="line-933"><code>		n = m</code></span>
<span class="codeline" id="line-934"><code>	}</code></span>
<span class="codeline" id="line-935"><code></code></span>
<span class="codeline" id="line-936"><code>	// Apply replacements to buffer.</code></span>
<span class="codeline" id="line-937"><code>	var b Builder</code></span>
<span class="codeline" id="line-938"><code>	b.Grow(len(s) + n*(len(new)-len(old)))</code></span>
<span class="codeline" id="line-939"><code>	start := 0</code></span>
<span class="codeline" id="line-940"><code>	for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-941"><code>		j := start</code></span>
<span class="codeline" id="line-942"><code>		if len(old) == 0 {</code></span>
<span class="codeline" id="line-943"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-944"><code>				_, wid := utf8.DecodeRuneInString(s[start:])</code></span>
<span class="codeline" id="line-945"><code>				j += wid</code></span>
<span class="codeline" id="line-946"><code>			}</code></span>
<span class="codeline" id="line-947"><code>		} else {</code></span>
<span class="codeline" id="line-948"><code>			j += Index(s[start:], old)</code></span>
<span class="codeline" id="line-949"><code>		}</code></span>
<span class="codeline" id="line-950"><code>		b.WriteString(s[start:j])</code></span>
<span class="codeline" id="line-951"><code>		b.WriteString(new)</code></span>
<span class="codeline" id="line-952"><code>		start = j + len(old)</code></span>
<span class="codeline" id="line-953"><code>	}</code></span>
<span class="codeline" id="line-954"><code>	b.WriteString(s[start:])</code></span>
<span class="codeline" id="line-955"><code>	return b.String()</code></span>
<span class="codeline" id="line-956"><code>}</code></span>
<span class="codeline" id="line-957"><code></code></span>
<span class="codeline" id="line-958"><code>// ReplaceAll returns a copy of the string s with all</code></span>
<span class="codeline" id="line-959"><code>// non-overlapping instances of old replaced by new.</code></span>
<span class="codeline" id="line-960"><code>// If old is empty, it matches at the beginning of the string</code></span>
<span class="codeline" id="line-961"><code>// and after each UTF-8 sequence, yielding up to k+1 replacements</code></span>
<span class="codeline" id="line-962"><code>// for a k-rune string.</code></span>
<span class="codeline" id="line-963"><code>func ReplaceAll(s, old, new string) string {</code></span>
<span class="codeline" id="line-964"><code>	return Replace(s, old, new, -1)</code></span>
<span class="codeline" id="line-965"><code>}</code></span>
<span class="codeline" id="line-966"><code></code></span>
<span class="codeline" id="line-967"><code>// EqualFold reports whether s and t, interpreted as UTF-8 strings,</code></span>
<span class="codeline" id="line-968"><code>// are equal under Unicode case-folding, which is a more general</code></span>
<span class="codeline" id="line-969"><code>// form of case-insensitivity.</code></span>
<span class="codeline" id="line-970"><code>func EqualFold(s, t string) bool {</code></span>
<span class="codeline" id="line-971"><code>	for s != "" &amp;&amp; t != "" {</code></span>
<span class="codeline" id="line-972"><code>		// Extract first rune from each string.</code></span>
<span class="codeline" id="line-973"><code>		var sr, tr rune</code></span>
<span class="codeline" id="line-974"><code>		if s[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-975"><code>			sr, s = rune(s[0]), s[1:]</code></span>
<span class="codeline" id="line-976"><code>		} else {</code></span>
<span class="codeline" id="line-977"><code>			r, size := utf8.DecodeRuneInString(s)</code></span>
<span class="codeline" id="line-978"><code>			sr, s = r, s[size:]</code></span>
<span class="codeline" id="line-979"><code>		}</code></span>
<span class="codeline" id="line-980"><code>		if t[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-981"><code>			tr, t = rune(t[0]), t[1:]</code></span>
<span class="codeline" id="line-982"><code>		} else {</code></span>
<span class="codeline" id="line-983"><code>			r, size := utf8.DecodeRuneInString(t)</code></span>
<span class="codeline" id="line-984"><code>			tr, t = r, t[size:]</code></span>
<span class="codeline" id="line-985"><code>		}</code></span>
<span class="codeline" id="line-986"><code></code></span>
<span class="codeline" id="line-987"><code>		// If they match, keep going; if not, return false.</code></span>
<span class="codeline" id="line-988"><code></code></span>
<span class="codeline" id="line-989"><code>		// Easy case.</code></span>
<span class="codeline" id="line-990"><code>		if tr == sr {</code></span>
<span class="codeline" id="line-991"><code>			continue</code></span>
<span class="codeline" id="line-992"><code>		}</code></span>
<span class="codeline" id="line-993"><code></code></span>
<span class="codeline" id="line-994"><code>		// Make sr &lt; tr to simplify what follows.</code></span>
<span class="codeline" id="line-995"><code>		if tr &lt; sr {</code></span>
<span class="codeline" id="line-996"><code>			tr, sr = sr, tr</code></span>
<span class="codeline" id="line-997"><code>		}</code></span>
<span class="codeline" id="line-998"><code>		// Fast check for ASCII.</code></span>
<span class="codeline" id="line-999"><code>		if tr &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1000"><code>			// ASCII only, sr/tr must be upper/lower case</code></span>
<span class="codeline" id="line-1001"><code>			if 'A' &lt;= sr &amp;&amp; sr &lt;= 'Z' &amp;&amp; tr == sr+'a'-'A' {</code></span>
<span class="codeline" id="line-1002"><code>				continue</code></span>
<span class="codeline" id="line-1003"><code>			}</code></span>
<span class="codeline" id="line-1004"><code>			return false</code></span>
<span class="codeline" id="line-1005"><code>		}</code></span>
<span class="codeline" id="line-1006"><code></code></span>
<span class="codeline" id="line-1007"><code>		// General case. SimpleFold(x) returns the next equivalent rune &gt; x</code></span>
<span class="codeline" id="line-1008"><code>		// or wraps around to smaller values.</code></span>
<span class="codeline" id="line-1009"><code>		r := unicode.SimpleFold(sr)</code></span>
<span class="codeline" id="line-1010"><code>		for r != sr &amp;&amp; r &lt; tr {</code></span>
<span class="codeline" id="line-1011"><code>			r = unicode.SimpleFold(r)</code></span>
<span class="codeline" id="line-1012"><code>		}</code></span>
<span class="codeline" id="line-1013"><code>		if r == tr {</code></span>
<span class="codeline" id="line-1014"><code>			continue</code></span>
<span class="codeline" id="line-1015"><code>		}</code></span>
<span class="codeline" id="line-1016"><code>		return false</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code></code></span>
<span class="codeline" id="line-1019"><code>	// One string is empty. Are both?</code></span>
<span class="codeline" id="line-1020"><code>	return s == t</code></span>
<span class="codeline" id="line-1021"><code>}</code></span>
<span class="codeline" id="line-1022"><code></code></span>
<span class="codeline" id="line-1023"><code>// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</code></span>
<span class="codeline" id="line-1024"><code>func Index(s, substr string) int {</code></span>
<span class="codeline" id="line-1025"><code>	n := len(substr)</code></span>
<span class="codeline" id="line-1026"><code>	switch {</code></span>
<span class="codeline" id="line-1027"><code>	case n == 0:</code></span>
<span class="codeline" id="line-1028"><code>		return 0</code></span>
<span class="codeline" id="line-1029"><code>	case n == 1:</code></span>
<span class="codeline" id="line-1030"><code>		return IndexByte(s, substr[0])</code></span>
<span class="codeline" id="line-1031"><code>	case n == len(s):</code></span>
<span class="codeline" id="line-1032"><code>		if substr == s {</code></span>
<span class="codeline" id="line-1033"><code>			return 0</code></span>
<span class="codeline" id="line-1034"><code>		}</code></span>
<span class="codeline" id="line-1035"><code>		return -1</code></span>
<span class="codeline" id="line-1036"><code>	case n &gt; len(s):</code></span>
<span class="codeline" id="line-1037"><code>		return -1</code></span>
<span class="codeline" id="line-1038"><code>	case n &lt;= bytealg.MaxLen:</code></span>
<span class="codeline" id="line-1039"><code>		// Use brute force when s and substr both are small</code></span>
<span class="codeline" id="line-1040"><code>		if len(s) &lt;= bytealg.MaxBruteForce {</code></span>
<span class="codeline" id="line-1041"><code>			return bytealg.IndexString(s, substr)</code></span>
<span class="codeline" id="line-1042"><code>		}</code></span>
<span class="codeline" id="line-1043"><code>		c0 := substr[0]</code></span>
<span class="codeline" id="line-1044"><code>		c1 := substr[1]</code></span>
<span class="codeline" id="line-1045"><code>		i := 0</code></span>
<span class="codeline" id="line-1046"><code>		t := len(s) - n + 1</code></span>
<span class="codeline" id="line-1047"><code>		fails := 0</code></span>
<span class="codeline" id="line-1048"><code>		for i &lt; t {</code></span>
<span class="codeline" id="line-1049"><code>			if s[i] != c0 {</code></span>
<span class="codeline" id="line-1050"><code>				// IndexByte is faster than bytealg.IndexString, so use it as long as</code></span>
<span class="codeline" id="line-1051"><code>				// we're not getting lots of false positives.</code></span>
<span class="codeline" id="line-1052"><code>				o := IndexByte(s[i+1:t], c0)</code></span>
<span class="codeline" id="line-1053"><code>				if o &lt; 0 {</code></span>
<span class="codeline" id="line-1054"><code>					return -1</code></span>
<span class="codeline" id="line-1055"><code>				}</code></span>
<span class="codeline" id="line-1056"><code>				i += o + 1</code></span>
<span class="codeline" id="line-1057"><code>			}</code></span>
<span class="codeline" id="line-1058"><code>			if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-1059"><code>				return i</code></span>
<span class="codeline" id="line-1060"><code>			}</code></span>
<span class="codeline" id="line-1061"><code>			fails++</code></span>
<span class="codeline" id="line-1062"><code>			i++</code></span>
<span class="codeline" id="line-1063"><code>			// Switch to bytealg.IndexString when IndexByte produces too many false positives.</code></span>
<span class="codeline" id="line-1064"><code>			if fails &gt; bytealg.Cutover(i) {</code></span>
<span class="codeline" id="line-1065"><code>				r := bytealg.IndexString(s[i:], substr)</code></span>
<span class="codeline" id="line-1066"><code>				if r &gt;= 0 {</code></span>
<span class="codeline" id="line-1067"><code>					return r + i</code></span>
<span class="codeline" id="line-1068"><code>				}</code></span>
<span class="codeline" id="line-1069"><code>				return -1</code></span>
<span class="codeline" id="line-1070"><code>			}</code></span>
<span class="codeline" id="line-1071"><code>		}</code></span>
<span class="codeline" id="line-1072"><code>		return -1</code></span>
<span class="codeline" id="line-1073"><code>	}</code></span>
<span class="codeline" id="line-1074"><code>	c0 := substr[0]</code></span>
<span class="codeline" id="line-1075"><code>	c1 := substr[1]</code></span>
<span class="codeline" id="line-1076"><code>	i := 0</code></span>
<span class="codeline" id="line-1077"><code>	t := len(s) - n + 1</code></span>
<span class="codeline" id="line-1078"><code>	fails := 0</code></span>
<span class="codeline" id="line-1079"><code>	for i &lt; t {</code></span>
<span class="codeline" id="line-1080"><code>		if s[i] != c0 {</code></span>
<span class="codeline" id="line-1081"><code>			o := IndexByte(s[i+1:t], c0)</code></span>
<span class="codeline" id="line-1082"><code>			if o &lt; 0 {</code></span>
<span class="codeline" id="line-1083"><code>				return -1</code></span>
<span class="codeline" id="line-1084"><code>			}</code></span>
<span class="codeline" id="line-1085"><code>			i += o + 1</code></span>
<span class="codeline" id="line-1086"><code>		}</code></span>
<span class="codeline" id="line-1087"><code>		if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-1088"><code>			return i</code></span>
<span class="codeline" id="line-1089"><code>		}</code></span>
<span class="codeline" id="line-1090"><code>		i++</code></span>
<span class="codeline" id="line-1091"><code>		fails++</code></span>
<span class="codeline" id="line-1092"><code>		if fails &gt;= 4+i&gt;&gt;4 &amp;&amp; i &lt; t {</code></span>
<span class="codeline" id="line-1093"><code>			// See comment in ../bytes/bytes.go.</code></span>
<span class="codeline" id="line-1094"><code>			j := bytealg.IndexRabinKarp(s[i:], substr)</code></span>
<span class="codeline" id="line-1095"><code>			if j &lt; 0 {</code></span>
<span class="codeline" id="line-1096"><code>				return -1</code></span>
<span class="codeline" id="line-1097"><code>			}</code></span>
<span class="codeline" id="line-1098"><code>			return i + j</code></span>
<span class="codeline" id="line-1099"><code>		}</code></span>
<span class="codeline" id="line-1100"><code>	}</code></span>
<span class="codeline" id="line-1101"><code>	return -1</code></span>
<span class="codeline" id="line-1102"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>