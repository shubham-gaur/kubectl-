<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: time.go in package time</title>
<link href="../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	time.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/time.html">time</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package time provides functionality for measuring and displaying time.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The calendrical calculations always assume a Gregorian calendar, with</code></span>
<span class="codeline" id="line-8"><code>// no leap seconds.</code></span>
<span class="codeline" id="line-9"><code>//</code></span>
<span class="codeline" id="line-10"><code>// Monotonic Clocks</code></span>
<span class="codeline" id="line-11"><code>//</code></span>
<span class="codeline" id="line-12"><code>// Operating systems provide both a “wall clock,” which is subject to</code></span>
<span class="codeline" id="line-13"><code>// changes for clock synchronization, and a “monotonic clock,” which is</code></span>
<span class="codeline" id="line-14"><code>// not. The general rule is that the wall clock is for telling time and</code></span>
<span class="codeline" id="line-15"><code>// the monotonic clock is for measuring time. Rather than split the API,</code></span>
<span class="codeline" id="line-16"><code>// in this package the Time returned by time.Now contains both a wall</code></span>
<span class="codeline" id="line-17"><code>// clock reading and a monotonic clock reading; later time-telling</code></span>
<span class="codeline" id="line-18"><code>// operations use the wall clock reading, but later time-measuring</code></span>
<span class="codeline" id="line-19"><code>// operations, specifically comparisons and subtractions, use the</code></span>
<span class="codeline" id="line-20"><code>// monotonic clock reading.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// For example, this code always computes a positive elapsed time of</code></span>
<span class="codeline" id="line-23"><code>// approximately 20 milliseconds, even if the wall clock is changed during</code></span>
<span class="codeline" id="line-24"><code>// the operation being timed:</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>//	start := time.Now()</code></span>
<span class="codeline" id="line-27"><code>//	... operation that takes 20 milliseconds ...</code></span>
<span class="codeline" id="line-28"><code>//	t := time.Now()</code></span>
<span class="codeline" id="line-29"><code>//	elapsed := t.Sub(start)</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// Other idioms, such as time.Since(start), time.Until(deadline), and</code></span>
<span class="codeline" id="line-32"><code>// time.Now().Before(deadline), are similarly robust against wall clock</code></span>
<span class="codeline" id="line-33"><code>// resets.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// The rest of this section gives the precise details of how operations</code></span>
<span class="codeline" id="line-36"><code>// use monotonic clocks, but understanding those details is not required</code></span>
<span class="codeline" id="line-37"><code>// to use this package.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// The Time returned by time.Now contains a monotonic clock reading.</code></span>
<span class="codeline" id="line-40"><code>// If Time t has a monotonic clock reading, t.Add adds the same duration to</code></span>
<span class="codeline" id="line-41"><code>// both the wall clock and monotonic clock readings to compute the result.</code></span>
<span class="codeline" id="line-42"><code>// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time</code></span>
<span class="codeline" id="line-43"><code>// computations, they always strip any monotonic clock reading from their results.</code></span>
<span class="codeline" id="line-44"><code>// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation</code></span>
<span class="codeline" id="line-45"><code>// of the wall time, they also strip any monotonic clock reading from their results.</code></span>
<span class="codeline" id="line-46"><code>// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// If Times t and u both contain monotonic clock readings, the operations</code></span>
<span class="codeline" id="line-49"><code>// t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out</code></span>
<span class="codeline" id="line-50"><code>// using the monotonic clock readings alone, ignoring the wall clock</code></span>
<span class="codeline" id="line-51"><code>// readings. If either t or u contains no monotonic clock reading, these</code></span>
<span class="codeline" id="line-52"><code>// operations fall back to using the wall clock readings.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// On some systems the monotonic clock will stop if the computer goes to sleep.</code></span>
<span class="codeline" id="line-55"><code>// On such a system, t.Sub(u) may not accurately reflect the actual</code></span>
<span class="codeline" id="line-56"><code>// time that passed between t and u.</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// Because the monotonic clock reading has no meaning outside</code></span>
<span class="codeline" id="line-59"><code>// the current process, the serialized forms generated by t.GobEncode,</code></span>
<span class="codeline" id="line-60"><code>// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic</code></span>
<span class="codeline" id="line-61"><code>// clock reading, and t.Format provides no format for it. Similarly, the</code></span>
<span class="codeline" id="line-62"><code>// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,</code></span>
<span class="codeline" id="line-63"><code>// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.</code></span>
<span class="codeline" id="line-64"><code>// t.UnmarshalJSON, and t.UnmarshalText always create times with</code></span>
<span class="codeline" id="line-65"><code>// no monotonic clock reading.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// Note that the Go == operator compares not just the time instant but</code></span>
<span class="codeline" id="line-68"><code>// also the Location and the monotonic clock reading. See the</code></span>
<span class="codeline" id="line-69"><code>// documentation for the Time type for a discussion of equality</code></span>
<span class="codeline" id="line-70"><code>// testing for Time values.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>// For debugging, the result of t.String does include the monotonic</code></span>
<span class="codeline" id="line-73"><code>// clock reading if present. If t != u because of different monotonic clock readings,</code></span>
<span class="codeline" id="line-74"><code>// that difference will be visible when printing t.String() and u.String().</code></span>
<span class="codeline" id="line-75"><code>//</code></span></div><span class="codeline" id="line-76"><code>package time</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>import (</code></span>
<span class="codeline" id="line-79"><code>	"errors"</code></span>
<span class="codeline" id="line-80"><code>	_ "unsafe" // for go:linkname</code></span>
<span class="codeline" id="line-81"><code>)</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>// A Time represents an instant in time with nanosecond precision.</code></span>
<span class="codeline" id="line-84"><code>//</code></span>
<span class="codeline" id="line-85"><code>// Programs using times should typically store and pass them as values,</code></span>
<span class="codeline" id="line-86"><code>// not pointers. That is, time variables and struct fields should be of</code></span>
<span class="codeline" id="line-87"><code>// type time.Time, not *time.Time.</code></span>
<span class="codeline" id="line-88"><code>//</code></span>
<span class="codeline" id="line-89"><code>// A Time value can be used by multiple goroutines simultaneously except</code></span>
<span class="codeline" id="line-90"><code>// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and</code></span>
<span class="codeline" id="line-91"><code>// UnmarshalText are not concurrency-safe.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// Time instants can be compared using the Before, After, and Equal methods.</code></span>
<span class="codeline" id="line-94"><code>// The Sub method subtracts two instants, producing a Duration.</code></span>
<span class="codeline" id="line-95"><code>// The Add method adds a Time and a Duration, producing a Time.</code></span>
<span class="codeline" id="line-96"><code>//</code></span>
<span class="codeline" id="line-97"><code>// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.</code></span>
<span class="codeline" id="line-98"><code>// As this time is unlikely to come up in practice, the IsZero method gives</code></span>
<span class="codeline" id="line-99"><code>// a simple way of detecting a time that has not been initialized explicitly.</code></span>
<span class="codeline" id="line-100"><code>//</code></span>
<span class="codeline" id="line-101"><code>// Each Time has associated with it a Location, consulted when computing the</code></span>
<span class="codeline" id="line-102"><code>// presentation form of the time, such as in the Format, Hour, and Year methods.</code></span>
<span class="codeline" id="line-103"><code>// The methods Local, UTC, and In return a Time with a specific location.</code></span>
<span class="codeline" id="line-104"><code>// Changing the location in this way changes only the presentation; it does not</code></span>
<span class="codeline" id="line-105"><code>// change the instant in time being denoted and therefore does not affect the</code></span>
<span class="codeline" id="line-106"><code>// computations described in earlier paragraphs.</code></span>
<span class="codeline" id="line-107"><code>//</code></span>
<span class="codeline" id="line-108"><code>// Representations of a Time value saved by the GobEncode, MarshalBinary,</code></span>
<span class="codeline" id="line-109"><code>// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not</code></span>
<span class="codeline" id="line-110"><code>// the location name. They therefore lose information about Daylight Saving Time.</code></span>
<span class="codeline" id="line-111"><code>//</code></span>
<span class="codeline" id="line-112"><code>// In addition to the required “wall clock” reading, a Time may contain an optional</code></span>
<span class="codeline" id="line-113"><code>// reading of the current process's monotonic clock, to provide additional precision</code></span>
<span class="codeline" id="line-114"><code>// for comparison or subtraction.</code></span>
<span class="codeline" id="line-115"><code>// See the “Monotonic Clocks” section in the package documentation for details.</code></span>
<span class="codeline" id="line-116"><code>//</code></span>
<span class="codeline" id="line-117"><code>// Note that the Go == operator compares not just the time instant but also the</code></span>
<span class="codeline" id="line-118"><code>// Location and the monotonic clock reading. Therefore, Time values should not</code></span>
<span class="codeline" id="line-119"><code>// be used as map or database keys without first guaranteeing that the</code></span>
<span class="codeline" id="line-120"><code>// identical Location has been set for all values, which can be achieved</code></span>
<span class="codeline" id="line-121"><code>// through use of the UTC or Local method, and that the monotonic clock reading</code></span>
<span class="codeline" id="line-122"><code>// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)</code></span>
<span class="codeline" id="line-123"><code>// to t == u, since t.Equal uses the most accurate comparison available and</code></span>
<span class="codeline" id="line-124"><code>// correctly handles the case when only one of its arguments has a monotonic</code></span>
<span class="codeline" id="line-125"><code>// clock reading.</code></span>
<span class="codeline" id="line-126"><code>//</code></span>
<span class="codeline" id="line-127"><code>type Time struct {</code></span>
<span class="codeline" id="line-128"><code>	// wall and ext encode the wall time seconds, wall time nanoseconds,</code></span>
<span class="codeline" id="line-129"><code>	// and optional monotonic clock reading in nanoseconds.</code></span>
<span class="codeline" id="line-130"><code>	//</code></span>
<span class="codeline" id="line-131"><code>	// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</code></span>
<span class="codeline" id="line-132"><code>	// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</code></span>
<span class="codeline" id="line-133"><code>	// The nanoseconds field is in the range [0, 999999999].</code></span>
<span class="codeline" id="line-134"><code>	// If the hasMonotonic bit is 0, then the 33-bit field must be zero</code></span>
<span class="codeline" id="line-135"><code>	// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</code></span>
<span class="codeline" id="line-136"><code>	// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</code></span>
<span class="codeline" id="line-137"><code>	// unsigned wall seconds since Jan 1 year 1885, and ext holds a</code></span>
<span class="codeline" id="line-138"><code>	// signed 64-bit monotonic clock reading, nanoseconds since process start.</code></span>
<span class="codeline" id="line-139"><code>	wall uint64</code></span>
<span class="codeline" id="line-140"><code>	ext  int64</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	// loc specifies the Location that should be used to</code></span>
<span class="codeline" id="line-143"><code>	// determine the minute, hour, month, day, and year</code></span>
<span class="codeline" id="line-144"><code>	// that correspond to this Time.</code></span>
<span class="codeline" id="line-145"><code>	// The nil location means UTC.</code></span>
<span class="codeline" id="line-146"><code>	// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</code></span>
<span class="codeline" id="line-147"><code>	loc *Location</code></span>
<span class="codeline" id="line-148"><code>}</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>const (</code></span>
<span class="codeline" id="line-151"><code>	hasMonotonic = 1 &lt;&lt; 63</code></span>
<span class="codeline" id="line-152"><code>	maxWall      = wallToInternal + (1&lt;&lt;33 - 1) // year 2157</code></span>
<span class="codeline" id="line-153"><code>	minWall      = wallToInternal               // year 1885</code></span>
<span class="codeline" id="line-154"><code>	nsecMask     = 1&lt;&lt;30 - 1</code></span>
<span class="codeline" id="line-155"><code>	nsecShift    = 30</code></span>
<span class="codeline" id="line-156"><code>)</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>// These helpers for manipulating the wall and monotonic clock readings</code></span>
<span class="codeline" id="line-159"><code>// take pointer receivers, even when they don't modify the time,</code></span>
<span class="codeline" id="line-160"><code>// to make them cheaper to call.</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>// nsec returns the time's nanoseconds.</code></span>
<span class="codeline" id="line-163"><code>func (t *Time) nsec() int32 {</code></span>
<span class="codeline" id="line-164"><code>	return int32(t.wall &amp; nsecMask)</code></span>
<span class="codeline" id="line-165"><code>}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// sec returns the time's seconds since Jan 1 year 1.</code></span>
<span class="codeline" id="line-168"><code>func (t *Time) sec() int64 {</code></span>
<span class="codeline" id="line-169"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-170"><code>		return wallToInternal + int64(t.wall&lt;&lt;1&gt;&gt;(nsecShift+1))</code></span>
<span class="codeline" id="line-171"><code>	}</code></span>
<span class="codeline" id="line-172"><code>	return t.ext</code></span>
<span class="codeline" id="line-173"><code>}</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>// unixSec returns the time's seconds since Jan 1 1970 (Unix time).</code></span>
<span class="codeline" id="line-176"><code>func (t *Time) unixSec() int64 { return t.sec() + internalToUnix }</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// addSec adds d seconds to the time.</code></span>
<span class="codeline" id="line-179"><code>func (t *Time) addSec(d int64) {</code></span>
<span class="codeline" id="line-180"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-181"><code>		sec := int64(t.wall &lt;&lt; 1 &gt;&gt; (nsecShift + 1))</code></span>
<span class="codeline" id="line-182"><code>		dsec := sec + d</code></span>
<span class="codeline" id="line-183"><code>		if 0 &lt;= dsec &amp;&amp; dsec &lt;= 1&lt;&lt;33-1 {</code></span>
<span class="codeline" id="line-184"><code>			t.wall = t.wall&amp;nsecMask | uint64(dsec)&lt;&lt;nsecShift | hasMonotonic</code></span>
<span class="codeline" id="line-185"><code>			return</code></span>
<span class="codeline" id="line-186"><code>		}</code></span>
<span class="codeline" id="line-187"><code>		// Wall second now out of range for packed field.</code></span>
<span class="codeline" id="line-188"><code>		// Move to ext.</code></span>
<span class="codeline" id="line-189"><code>		t.stripMono()</code></span>
<span class="codeline" id="line-190"><code>	}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	// TODO: Check for overflow.</code></span>
<span class="codeline" id="line-193"><code>	t.ext += d</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// setLoc sets the location associated with the time.</code></span>
<span class="codeline" id="line-197"><code>func (t *Time) setLoc(loc *Location) {</code></span>
<span class="codeline" id="line-198"><code>	if loc == &amp;utcLoc {</code></span>
<span class="codeline" id="line-199"><code>		loc = nil</code></span>
<span class="codeline" id="line-200"><code>	}</code></span>
<span class="codeline" id="line-201"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-202"><code>	t.loc = loc</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>// stripMono strips the monotonic clock reading in t.</code></span>
<span class="codeline" id="line-206"><code>func (t *Time) stripMono() {</code></span>
<span class="codeline" id="line-207"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-208"><code>		t.ext = t.sec()</code></span>
<span class="codeline" id="line-209"><code>		t.wall &amp;= nsecMask</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>}</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>// setMono sets the monotonic clock reading in t.</code></span>
<span class="codeline" id="line-214"><code>// If t cannot hold a monotonic clock reading,</code></span>
<span class="codeline" id="line-215"><code>// because its wall time is too large,</code></span>
<span class="codeline" id="line-216"><code>// setMono is a no-op.</code></span>
<span class="codeline" id="line-217"><code>func (t *Time) setMono(m int64) {</code></span>
<span class="codeline" id="line-218"><code>	if t.wall&amp;hasMonotonic == 0 {</code></span>
<span class="codeline" id="line-219"><code>		sec := t.ext</code></span>
<span class="codeline" id="line-220"><code>		if sec &lt; minWall || maxWall &lt; sec {</code></span>
<span class="codeline" id="line-221"><code>			return</code></span>
<span class="codeline" id="line-222"><code>		}</code></span>
<span class="codeline" id="line-223"><code>		t.wall |= hasMonotonic | uint64(sec-minWall)&lt;&lt;nsecShift</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code>	t.ext = m</code></span>
<span class="codeline" id="line-226"><code>}</code></span>
<span class="codeline" id="line-227"><code></code></span>
<span class="codeline" id="line-228"><code>// mono returns t's monotonic clock reading.</code></span>
<span class="codeline" id="line-229"><code>// It returns 0 for a missing reading.</code></span>
<span class="codeline" id="line-230"><code>// This function is used only for testing,</code></span>
<span class="codeline" id="line-231"><code>// so it's OK that technically 0 is a valid</code></span>
<span class="codeline" id="line-232"><code>// monotonic clock reading as well.</code></span>
<span class="codeline" id="line-233"><code>func (t *Time) mono() int64 {</code></span>
<span class="codeline" id="line-234"><code>	if t.wall&amp;hasMonotonic == 0 {</code></span>
<span class="codeline" id="line-235"><code>		return 0</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	return t.ext</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// After reports whether the time instant t is after u.</code></span>
<span class="codeline" id="line-241"><code>func (t Time) After(u Time) bool {</code></span>
<span class="codeline" id="line-242"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-243"><code>		return t.ext &gt; u.ext</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	ts := t.sec()</code></span>
<span class="codeline" id="line-246"><code>	us := u.sec()</code></span>
<span class="codeline" id="line-247"><code>	return ts &gt; us || ts == us &amp;&amp; t.nsec() &gt; u.nsec()</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// Before reports whether the time instant t is before u.</code></span>
<span class="codeline" id="line-251"><code>func (t Time) Before(u Time) bool {</code></span>
<span class="codeline" id="line-252"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-253"><code>		return t.ext &lt; u.ext</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code>	ts := t.sec()</code></span>
<span class="codeline" id="line-256"><code>	us := u.sec()</code></span>
<span class="codeline" id="line-257"><code>	return ts &lt; us || ts == us &amp;&amp; t.nsec() &lt; u.nsec()</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// Equal reports whether t and u represent the same time instant.</code></span>
<span class="codeline" id="line-261"><code>// Two times can be equal even if they are in different locations.</code></span>
<span class="codeline" id="line-262"><code>// For example, 6:00 +0200 and 4:00 UTC are Equal.</code></span>
<span class="codeline" id="line-263"><code>// See the documentation on the Time type for the pitfalls of using == with</code></span>
<span class="codeline" id="line-264"><code>// Time values; most code should use Equal instead.</code></span>
<span class="codeline" id="line-265"><code>func (t Time) Equal(u Time) bool {</code></span>
<span class="codeline" id="line-266"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-267"><code>		return t.ext == u.ext</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	return t.sec() == u.sec() &amp;&amp; t.nsec() == u.nsec()</code></span>
<span class="codeline" id="line-270"><code>}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>// A Month specifies a month of the year (January = 1, ...).</code></span>
<span class="codeline" id="line-273"><code>type Month int</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>const (</code></span>
<span class="codeline" id="line-276"><code>	January Month = 1 + iota</code></span>
<span class="codeline" id="line-277"><code>	February</code></span>
<span class="codeline" id="line-278"><code>	March</code></span>
<span class="codeline" id="line-279"><code>	April</code></span>
<span class="codeline" id="line-280"><code>	May</code></span>
<span class="codeline" id="line-281"><code>	June</code></span>
<span class="codeline" id="line-282"><code>	July</code></span>
<span class="codeline" id="line-283"><code>	August</code></span>
<span class="codeline" id="line-284"><code>	September</code></span>
<span class="codeline" id="line-285"><code>	October</code></span>
<span class="codeline" id="line-286"><code>	November</code></span>
<span class="codeline" id="line-287"><code>	December</code></span>
<span class="codeline" id="line-288"><code>)</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>// String returns the English name of the month ("January", "February", ...).</code></span>
<span class="codeline" id="line-291"><code>func (m Month) String() string {</code></span>
<span class="codeline" id="line-292"><code>	if January &lt;= m &amp;&amp; m &lt;= December {</code></span>
<span class="codeline" id="line-293"><code>		return longMonthNames[m-1]</code></span>
<span class="codeline" id="line-294"><code>	}</code></span>
<span class="codeline" id="line-295"><code>	buf := make([]byte, 20)</code></span>
<span class="codeline" id="line-296"><code>	n := fmtInt(buf, uint64(m))</code></span>
<span class="codeline" id="line-297"><code>	return "%!Month(" + string(buf[n:]) + ")"</code></span>
<span class="codeline" id="line-298"><code>}</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>// A Weekday specifies a day of the week (Sunday = 0, ...).</code></span>
<span class="codeline" id="line-301"><code>type Weekday int</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>const (</code></span>
<span class="codeline" id="line-304"><code>	Sunday Weekday = iota</code></span>
<span class="codeline" id="line-305"><code>	Monday</code></span>
<span class="codeline" id="line-306"><code>	Tuesday</code></span>
<span class="codeline" id="line-307"><code>	Wednesday</code></span>
<span class="codeline" id="line-308"><code>	Thursday</code></span>
<span class="codeline" id="line-309"><code>	Friday</code></span>
<span class="codeline" id="line-310"><code>	Saturday</code></span>
<span class="codeline" id="line-311"><code>)</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>// String returns the English name of the day ("Sunday", "Monday", ...).</code></span>
<span class="codeline" id="line-314"><code>func (d Weekday) String() string {</code></span>
<span class="codeline" id="line-315"><code>	if Sunday &lt;= d &amp;&amp; d &lt;= Saturday {</code></span>
<span class="codeline" id="line-316"><code>		return longDayNames[d]</code></span>
<span class="codeline" id="line-317"><code>	}</code></span>
<span class="codeline" id="line-318"><code>	buf := make([]byte, 20)</code></span>
<span class="codeline" id="line-319"><code>	n := fmtInt(buf, uint64(d))</code></span>
<span class="codeline" id="line-320"><code>	return "%!Weekday(" + string(buf[n:]) + ")"</code></span>
<span class="codeline" id="line-321"><code>}</code></span>
<span class="codeline" id="line-322"><code></code></span>
<span class="codeline" id="line-323"><code>// Computations on time.</code></span>
<span class="codeline" id="line-324"><code>//</code></span>
<span class="codeline" id="line-325"><code>// The zero value for a Time is defined to be</code></span>
<span class="codeline" id="line-326"><code>//	January 1, year 1, 00:00:00.000000000 UTC</code></span>
<span class="codeline" id="line-327"><code>// which (1) looks like a zero, or as close as you can get in a date</code></span>
<span class="codeline" id="line-328"><code>// (1-1-1 00:00:00 UTC), (2) is unlikely enough to arise in practice to</code></span>
<span class="codeline" id="line-329"><code>// be a suitable "not set" sentinel, unlike Jan 1 1970, and (3) has a</code></span>
<span class="codeline" id="line-330"><code>// non-negative year even in time zones west of UTC, unlike 1-1-0</code></span>
<span class="codeline" id="line-331"><code>// 00:00:00 UTC, which would be 12-31-(-1) 19:00:00 in New York.</code></span>
<span class="codeline" id="line-332"><code>//</code></span>
<span class="codeline" id="line-333"><code>// The zero Time value does not force a specific epoch for the time</code></span>
<span class="codeline" id="line-334"><code>// representation. For example, to use the Unix epoch internally, we</code></span>
<span class="codeline" id="line-335"><code>// could define that to distinguish a zero value from Jan 1 1970, that</code></span>
<span class="codeline" id="line-336"><code>// time would be represented by sec=-1, nsec=1e9. However, it does</code></span>
<span class="codeline" id="line-337"><code>// suggest a representation, namely using 1-1-1 00:00:00 UTC as the</code></span>
<span class="codeline" id="line-338"><code>// epoch, and that's what we do.</code></span>
<span class="codeline" id="line-339"><code>//</code></span>
<span class="codeline" id="line-340"><code>// The Add and Sub computations are oblivious to the choice of epoch.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// The presentation computations - year, month, minute, and so on - all</code></span>
<span class="codeline" id="line-343"><code>// rely heavily on division and modulus by positive constants. For</code></span>
<span class="codeline" id="line-344"><code>// calendrical calculations we want these divisions to round down, even</code></span>
<span class="codeline" id="line-345"><code>// for negative values, so that the remainder is always positive, but</code></span>
<span class="codeline" id="line-346"><code>// Go's division (like most hardware division instructions) rounds to</code></span>
<span class="codeline" id="line-347"><code>// zero. We can still do those computations and then adjust the result</code></span>
<span class="codeline" id="line-348"><code>// for a negative numerator, but it's annoying to write the adjustment</code></span>
<span class="codeline" id="line-349"><code>// over and over. Instead, we can change to a different epoch so long</code></span>
<span class="codeline" id="line-350"><code>// ago that all the times we care about will be positive, and then round</code></span>
<span class="codeline" id="line-351"><code>// to zero and round down coincide. These presentation routines already</code></span>
<span class="codeline" id="line-352"><code>// have to add the zone offset, so adding the translation to the</code></span>
<span class="codeline" id="line-353"><code>// alternate epoch is cheap. For example, having a non-negative time t</code></span>
<span class="codeline" id="line-354"><code>// means that we can write</code></span>
<span class="codeline" id="line-355"><code>//</code></span>
<span class="codeline" id="line-356"><code>//	sec = t % 60</code></span>
<span class="codeline" id="line-357"><code>//</code></span>
<span class="codeline" id="line-358"><code>// instead of</code></span>
<span class="codeline" id="line-359"><code>//</code></span>
<span class="codeline" id="line-360"><code>//	sec = t % 60</code></span>
<span class="codeline" id="line-361"><code>//	if sec &lt; 0 {</code></span>
<span class="codeline" id="line-362"><code>//		sec += 60</code></span>
<span class="codeline" id="line-363"><code>//	}</code></span>
<span class="codeline" id="line-364"><code>//</code></span>
<span class="codeline" id="line-365"><code>// everywhere.</code></span>
<span class="codeline" id="line-366"><code>//</code></span>
<span class="codeline" id="line-367"><code>// The calendar runs on an exact 400 year cycle: a 400-year calendar</code></span>
<span class="codeline" id="line-368"><code>// printed for 1970-2369 will apply as well to 2370-2769. Even the days</code></span>
<span class="codeline" id="line-369"><code>// of the week match up. It simplifies the computations to choose the</code></span>
<span class="codeline" id="line-370"><code>// cycle boundaries so that the exceptional years are always delayed as</code></span>
<span class="codeline" id="line-371"><code>// long as possible. That means choosing a year equal to 1 mod 400, so</code></span>
<span class="codeline" id="line-372"><code>// that the first leap year is the 4th year, the first missed leap year</code></span>
<span class="codeline" id="line-373"><code>// is the 100th year, and the missed missed leap year is the 400th year.</code></span>
<span class="codeline" id="line-374"><code>// So we'd prefer instead to print a calendar for 2001-2400 and reuse it</code></span>
<span class="codeline" id="line-375"><code>// for 2401-2800.</code></span>
<span class="codeline" id="line-376"><code>//</code></span>
<span class="codeline" id="line-377"><code>// Finally, it's convenient if the delta between the Unix epoch and</code></span>
<span class="codeline" id="line-378"><code>// long-ago epoch is representable by an int64 constant.</code></span>
<span class="codeline" id="line-379"><code>//</code></span>
<span class="codeline" id="line-380"><code>// These three considerations—choose an epoch as early as possible, that</code></span>
<span class="codeline" id="line-381"><code>// uses a year equal to 1 mod 400, and that is no more than 2⁶³ seconds</code></span>
<span class="codeline" id="line-382"><code>// earlier than 1970—bring us to the year -292277022399. We refer to</code></span>
<span class="codeline" id="line-383"><code>// this year as the absolute zero year, and to times measured as a uint64</code></span>
<span class="codeline" id="line-384"><code>// seconds since this year as absolute times.</code></span>
<span class="codeline" id="line-385"><code>//</code></span>
<span class="codeline" id="line-386"><code>// Times measured as an int64 seconds since the year 1—the representation</code></span>
<span class="codeline" id="line-387"><code>// used for Time's sec field—are called internal times.</code></span>
<span class="codeline" id="line-388"><code>//</code></span>
<span class="codeline" id="line-389"><code>// Times measured as an int64 seconds since the year 1970 are called Unix</code></span>
<span class="codeline" id="line-390"><code>// times.</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>// It is tempting to just use the year 1 as the absolute epoch, defining</code></span>
<span class="codeline" id="line-393"><code>// that the routines are only valid for years &gt;= 1. However, the</code></span>
<span class="codeline" id="line-394"><code>// routines would then be invalid when displaying the epoch in time zones</code></span>
<span class="codeline" id="line-395"><code>// west of UTC, since it is year 0. It doesn't seem tenable to say that</code></span>
<span class="codeline" id="line-396"><code>// printing the zero time correctly isn't supported in half the time</code></span>
<span class="codeline" id="line-397"><code>// zones. By comparison, it's reasonable to mishandle some times in</code></span>
<span class="codeline" id="line-398"><code>// the year -292277022399.</code></span>
<span class="codeline" id="line-399"><code>//</code></span>
<span class="codeline" id="line-400"><code>// All this is opaque to clients of the API and can be changed if a</code></span>
<span class="codeline" id="line-401"><code>// better implementation presents itself.</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>const (</code></span>
<span class="codeline" id="line-404"><code>	// The unsigned zero year for internal calculations.</code></span>
<span class="codeline" id="line-405"><code>	// Must be 1 mod 400, and times before it will not compute correctly,</code></span>
<span class="codeline" id="line-406"><code>	// but otherwise can be changed at will.</code></span>
<span class="codeline" id="line-407"><code>	absoluteZeroYear = -292277022399</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>	// The year of the zero Time.</code></span>
<span class="codeline" id="line-410"><code>	// Assumed by the unixToInternal computation below.</code></span>
<span class="codeline" id="line-411"><code>	internalYear = 1</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	// Offsets to convert between internal and absolute or Unix times.</code></span>
<span class="codeline" id="line-414"><code>	absoluteToInternal int64 = (absoluteZeroYear - internalYear) * 365.2425 * secondsPerDay</code></span>
<span class="codeline" id="line-415"><code>	internalToAbsolute       = -absoluteToInternal</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	unixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay</code></span>
<span class="codeline" id="line-418"><code>	internalToUnix int64 = -unixToInternal</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	wallToInternal int64 = (1884*365 + 1884/4 - 1884/100 + 1884/400) * secondsPerDay</code></span>
<span class="codeline" id="line-421"><code>	internalToWall int64 = -wallToInternal</code></span>
<span class="codeline" id="line-422"><code>)</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>// IsZero reports whether t represents the zero time instant,</code></span>
<span class="codeline" id="line-425"><code>// January 1, year 1, 00:00:00 UTC.</code></span>
<span class="codeline" id="line-426"><code>func (t Time) IsZero() bool {</code></span>
<span class="codeline" id="line-427"><code>	return t.sec() == 0 &amp;&amp; t.nsec() == 0</code></span>
<span class="codeline" id="line-428"><code>}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>// abs returns the time t as an absolute time, adjusted by the zone offset.</code></span>
<span class="codeline" id="line-431"><code>// It is called when computing a presentation property like Month or Hour.</code></span>
<span class="codeline" id="line-432"><code>func (t Time) abs() uint64 {</code></span>
<span class="codeline" id="line-433"><code>	l := t.loc</code></span>
<span class="codeline" id="line-434"><code>	// Avoid function calls when possible.</code></span>
<span class="codeline" id="line-435"><code>	if l == nil || l == &amp;localLoc {</code></span>
<span class="codeline" id="line-436"><code>		l = l.get()</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>	sec := t.unixSec()</code></span>
<span class="codeline" id="line-439"><code>	if l != &amp;utcLoc {</code></span>
<span class="codeline" id="line-440"><code>		if l.cacheZone != nil &amp;&amp; l.cacheStart &lt;= sec &amp;&amp; sec &lt; l.cacheEnd {</code></span>
<span class="codeline" id="line-441"><code>			sec += int64(l.cacheZone.offset)</code></span>
<span class="codeline" id="line-442"><code>		} else {</code></span>
<span class="codeline" id="line-443"><code>			_, offset, _, _ := l.lookup(sec)</code></span>
<span class="codeline" id="line-444"><code>			sec += int64(offset)</code></span>
<span class="codeline" id="line-445"><code>		}</code></span>
<span class="codeline" id="line-446"><code>	}</code></span>
<span class="codeline" id="line-447"><code>	return uint64(sec + (unixToInternal + internalToAbsolute))</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>// locabs is a combination of the Zone and abs methods,</code></span>
<span class="codeline" id="line-451"><code>// extracting both return values from a single zone lookup.</code></span>
<span class="codeline" id="line-452"><code>func (t Time) locabs() (name string, offset int, abs uint64) {</code></span>
<span class="codeline" id="line-453"><code>	l := t.loc</code></span>
<span class="codeline" id="line-454"><code>	if l == nil || l == &amp;localLoc {</code></span>
<span class="codeline" id="line-455"><code>		l = l.get()</code></span>
<span class="codeline" id="line-456"><code>	}</code></span>
<span class="codeline" id="line-457"><code>	// Avoid function call if we hit the local time cache.</code></span>
<span class="codeline" id="line-458"><code>	sec := t.unixSec()</code></span>
<span class="codeline" id="line-459"><code>	if l != &amp;utcLoc {</code></span>
<span class="codeline" id="line-460"><code>		if l.cacheZone != nil &amp;&amp; l.cacheStart &lt;= sec &amp;&amp; sec &lt; l.cacheEnd {</code></span>
<span class="codeline" id="line-461"><code>			name = l.cacheZone.name</code></span>
<span class="codeline" id="line-462"><code>			offset = l.cacheZone.offset</code></span>
<span class="codeline" id="line-463"><code>		} else {</code></span>
<span class="codeline" id="line-464"><code>			name, offset, _, _ = l.lookup(sec)</code></span>
<span class="codeline" id="line-465"><code>		}</code></span>
<span class="codeline" id="line-466"><code>		sec += int64(offset)</code></span>
<span class="codeline" id="line-467"><code>	} else {</code></span>
<span class="codeline" id="line-468"><code>		name = "UTC"</code></span>
<span class="codeline" id="line-469"><code>	}</code></span>
<span class="codeline" id="line-470"><code>	abs = uint64(sec + (unixToInternal + internalToAbsolute))</code></span>
<span class="codeline" id="line-471"><code>	return</code></span>
<span class="codeline" id="line-472"><code>}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>// Date returns the year, month, and day in which t occurs.</code></span>
<span class="codeline" id="line-475"><code>func (t Time) Date() (year int, month Month, day int) {</code></span>
<span class="codeline" id="line-476"><code>	year, month, day, _ = t.date(true)</code></span>
<span class="codeline" id="line-477"><code>	return</code></span>
<span class="codeline" id="line-478"><code>}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>// Year returns the year in which t occurs.</code></span>
<span class="codeline" id="line-481"><code>func (t Time) Year() int {</code></span>
<span class="codeline" id="line-482"><code>	year, _, _, _ := t.date(false)</code></span>
<span class="codeline" id="line-483"><code>	return year</code></span>
<span class="codeline" id="line-484"><code>}</code></span>
<span class="codeline" id="line-485"><code></code></span>
<span class="codeline" id="line-486"><code>// Month returns the month of the year specified by t.</code></span>
<span class="codeline" id="line-487"><code>func (t Time) Month() Month {</code></span>
<span class="codeline" id="line-488"><code>	_, month, _, _ := t.date(true)</code></span>
<span class="codeline" id="line-489"><code>	return month</code></span>
<span class="codeline" id="line-490"><code>}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>// Day returns the day of the month specified by t.</code></span>
<span class="codeline" id="line-493"><code>func (t Time) Day() int {</code></span>
<span class="codeline" id="line-494"><code>	_, _, day, _ := t.date(true)</code></span>
<span class="codeline" id="line-495"><code>	return day</code></span>
<span class="codeline" id="line-496"><code>}</code></span>
<span class="codeline" id="line-497"><code></code></span>
<span class="codeline" id="line-498"><code>// Weekday returns the day of the week specified by t.</code></span>
<span class="codeline" id="line-499"><code>func (t Time) Weekday() Weekday {</code></span>
<span class="codeline" id="line-500"><code>	return absWeekday(t.abs())</code></span>
<span class="codeline" id="line-501"><code>}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// absWeekday is like Weekday but operates on an absolute time.</code></span>
<span class="codeline" id="line-504"><code>func absWeekday(abs uint64) Weekday {</code></span>
<span class="codeline" id="line-505"><code>	// January 1 of the absolute year, like January 1 of 2001, was a Monday.</code></span>
<span class="codeline" id="line-506"><code>	sec := (abs + uint64(Monday)*secondsPerDay) % secondsPerWeek</code></span>
<span class="codeline" id="line-507"><code>	return Weekday(int(sec) / secondsPerDay)</code></span>
<span class="codeline" id="line-508"><code>}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>// ISOWeek returns the ISO 8601 year and week number in which t occurs.</code></span>
<span class="codeline" id="line-511"><code>// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to</code></span>
<span class="codeline" id="line-512"><code>// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1</code></span>
<span class="codeline" id="line-513"><code>// of year n+1.</code></span>
<span class="codeline" id="line-514"><code>func (t Time) ISOWeek() (year, week int) {</code></span>
<span class="codeline" id="line-515"><code>	// According to the rule that the first calendar week of a calendar year is</code></span>
<span class="codeline" id="line-516"><code>	// the week including the first Thursday of that year, and that the last one is</code></span>
<span class="codeline" id="line-517"><code>	// the week immediately preceding the first calendar week of the next calendar year.</code></span>
<span class="codeline" id="line-518"><code>	// See https://www.iso.org/obp/ui#iso:std:iso:8601:-1:ed-1:v1:en:term:3.1.1.23 for details.</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>	// weeks start with Monday</code></span>
<span class="codeline" id="line-521"><code>	// Monday Tuesday Wednesday Thursday Friday Saturday Sunday</code></span>
<span class="codeline" id="line-522"><code>	// 1      2       3         4        5      6        7</code></span>
<span class="codeline" id="line-523"><code>	// +3     +2      +1        0        -1     -2       -3</code></span>
<span class="codeline" id="line-524"><code>	// the offset to Thursday</code></span>
<span class="codeline" id="line-525"><code>	abs := t.abs()</code></span>
<span class="codeline" id="line-526"><code>	d := Thursday - absWeekday(abs)</code></span>
<span class="codeline" id="line-527"><code>	// handle Sunday</code></span>
<span class="codeline" id="line-528"><code>	if d == 4 {</code></span>
<span class="codeline" id="line-529"><code>		d = -3</code></span>
<span class="codeline" id="line-530"><code>	}</code></span>
<span class="codeline" id="line-531"><code>	// find the Thursday of the calendar week</code></span>
<span class="codeline" id="line-532"><code>	abs += uint64(d) * secondsPerDay</code></span>
<span class="codeline" id="line-533"><code>	year, _, _, yday := absDate(abs, false)</code></span>
<span class="codeline" id="line-534"><code>	return year, yday/7 + 1</code></span>
<span class="codeline" id="line-535"><code>}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>// Clock returns the hour, minute, and second within the day specified by t.</code></span>
<span class="codeline" id="line-538"><code>func (t Time) Clock() (hour, min, sec int) {</code></span>
<span class="codeline" id="line-539"><code>	return absClock(t.abs())</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>// absClock is like clock but operates on an absolute time.</code></span>
<span class="codeline" id="line-543"><code>func absClock(abs uint64) (hour, min, sec int) {</code></span>
<span class="codeline" id="line-544"><code>	sec = int(abs % secondsPerDay)</code></span>
<span class="codeline" id="line-545"><code>	hour = sec / secondsPerHour</code></span>
<span class="codeline" id="line-546"><code>	sec -= hour * secondsPerHour</code></span>
<span class="codeline" id="line-547"><code>	min = sec / secondsPerMinute</code></span>
<span class="codeline" id="line-548"><code>	sec -= min * secondsPerMinute</code></span>
<span class="codeline" id="line-549"><code>	return</code></span>
<span class="codeline" id="line-550"><code>}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>// Hour returns the hour within the day specified by t, in the range [0, 23].</code></span>
<span class="codeline" id="line-553"><code>func (t Time) Hour() int {</code></span>
<span class="codeline" id="line-554"><code>	return int(t.abs()%secondsPerDay) / secondsPerHour</code></span>
<span class="codeline" id="line-555"><code>}</code></span>
<span class="codeline" id="line-556"><code></code></span>
<span class="codeline" id="line-557"><code>// Minute returns the minute offset within the hour specified by t, in the range [0, 59].</code></span>
<span class="codeline" id="line-558"><code>func (t Time) Minute() int {</code></span>
<span class="codeline" id="line-559"><code>	return int(t.abs()%secondsPerHour) / secondsPerMinute</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// Second returns the second offset within the minute specified by t, in the range [0, 59].</code></span>
<span class="codeline" id="line-563"><code>func (t Time) Second() int {</code></span>
<span class="codeline" id="line-564"><code>	return int(t.abs() % secondsPerMinute)</code></span>
<span class="codeline" id="line-565"><code>}</code></span>
<span class="codeline" id="line-566"><code></code></span>
<span class="codeline" id="line-567"><code>// Nanosecond returns the nanosecond offset within the second specified by t,</code></span>
<span class="codeline" id="line-568"><code>// in the range [0, 999999999].</code></span>
<span class="codeline" id="line-569"><code>func (t Time) Nanosecond() int {</code></span>
<span class="codeline" id="line-570"><code>	return int(t.nsec())</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,</code></span>
<span class="codeline" id="line-574"><code>// and [1,366] in leap years.</code></span>
<span class="codeline" id="line-575"><code>func (t Time) YearDay() int {</code></span>
<span class="codeline" id="line-576"><code>	_, _, _, yday := t.date(false)</code></span>
<span class="codeline" id="line-577"><code>	return yday + 1</code></span>
<span class="codeline" id="line-578"><code>}</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>// A Duration represents the elapsed time between two instants</code></span>
<span class="codeline" id="line-581"><code>// as an int64 nanosecond count. The representation limits the</code></span>
<span class="codeline" id="line-582"><code>// largest representable duration to approximately 290 years.</code></span>
<span class="codeline" id="line-583"><code>type Duration int64</code></span>
<span class="codeline" id="line-584"><code></code></span>
<span class="codeline" id="line-585"><code>const (</code></span>
<span class="codeline" id="line-586"><code>	minDuration Duration = -1 &lt;&lt; 63</code></span>
<span class="codeline" id="line-587"><code>	maxDuration Duration = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-588"><code>)</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>// Common durations. There is no definition for units of Day or larger</code></span>
<span class="codeline" id="line-591"><code>// to avoid confusion across daylight savings time zone transitions.</code></span>
<span class="codeline" id="line-592"><code>//</code></span>
<span class="codeline" id="line-593"><code>// To count the number of units in a Duration, divide:</code></span>
<span class="codeline" id="line-594"><code>//	second := time.Second</code></span>
<span class="codeline" id="line-595"><code>//	fmt.Print(int64(second/time.Millisecond)) // prints 1000</code></span>
<span class="codeline" id="line-596"><code>//</code></span>
<span class="codeline" id="line-597"><code>// To convert an integer number of units to a Duration, multiply:</code></span>
<span class="codeline" id="line-598"><code>//	seconds := 10</code></span>
<span class="codeline" id="line-599"><code>//	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</code></span>
<span class="codeline" id="line-600"><code>//</code></span>
<span class="codeline" id="line-601"><code>const (</code></span>
<span class="codeline" id="line-602"><code>	Nanosecond  Duration = 1</code></span>
<span class="codeline" id="line-603"><code>	Microsecond          = 1000 * Nanosecond</code></span>
<span class="codeline" id="line-604"><code>	Millisecond          = 1000 * Microsecond</code></span>
<span class="codeline" id="line-605"><code>	Second               = 1000 * Millisecond</code></span>
<span class="codeline" id="line-606"><code>	Minute               = 60 * Second</code></span>
<span class="codeline" id="line-607"><code>	Hour                 = 60 * Minute</code></span>
<span class="codeline" id="line-608"><code>)</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// String returns a string representing the duration in the form "72h3m0.5s".</code></span>
<span class="codeline" id="line-611"><code>// Leading zero units are omitted. As a special case, durations less than one</code></span>
<span class="codeline" id="line-612"><code>// second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure</code></span>
<span class="codeline" id="line-613"><code>// that the leading digit is non-zero. The zero duration formats as 0s.</code></span>
<span class="codeline" id="line-614"><code>func (d Duration) String() string {</code></span>
<span class="codeline" id="line-615"><code>	// Largest time is 2540400h10m10.000000000s</code></span>
<span class="codeline" id="line-616"><code>	var buf [32]byte</code></span>
<span class="codeline" id="line-617"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>	u := uint64(d)</code></span>
<span class="codeline" id="line-620"><code>	neg := d &lt; 0</code></span>
<span class="codeline" id="line-621"><code>	if neg {</code></span>
<span class="codeline" id="line-622"><code>		u = -u</code></span>
<span class="codeline" id="line-623"><code>	}</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>	if u &lt; uint64(Second) {</code></span>
<span class="codeline" id="line-626"><code>		// Special case: if duration is smaller than a second,</code></span>
<span class="codeline" id="line-627"><code>		// use smaller units, like 1.2ms</code></span>
<span class="codeline" id="line-628"><code>		var prec int</code></span>
<span class="codeline" id="line-629"><code>		w--</code></span>
<span class="codeline" id="line-630"><code>		buf[w] = 's'</code></span>
<span class="codeline" id="line-631"><code>		w--</code></span>
<span class="codeline" id="line-632"><code>		switch {</code></span>
<span class="codeline" id="line-633"><code>		case u == 0:</code></span>
<span class="codeline" id="line-634"><code>			return "0s"</code></span>
<span class="codeline" id="line-635"><code>		case u &lt; uint64(Microsecond):</code></span>
<span class="codeline" id="line-636"><code>			// print nanoseconds</code></span>
<span class="codeline" id="line-637"><code>			prec = 0</code></span>
<span class="codeline" id="line-638"><code>			buf[w] = 'n'</code></span>
<span class="codeline" id="line-639"><code>		case u &lt; uint64(Millisecond):</code></span>
<span class="codeline" id="line-640"><code>			// print microseconds</code></span>
<span class="codeline" id="line-641"><code>			prec = 3</code></span>
<span class="codeline" id="line-642"><code>			// U+00B5 'µ' micro sign == 0xC2 0xB5</code></span>
<span class="codeline" id="line-643"><code>			w-- // Need room for two bytes.</code></span>
<span class="codeline" id="line-644"><code>			copy(buf[w:], "µ")</code></span>
<span class="codeline" id="line-645"><code>		default:</code></span>
<span class="codeline" id="line-646"><code>			// print milliseconds</code></span>
<span class="codeline" id="line-647"><code>			prec = 6</code></span>
<span class="codeline" id="line-648"><code>			buf[w] = 'm'</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>		w, u = fmtFrac(buf[:w], u, prec)</code></span>
<span class="codeline" id="line-651"><code>		w = fmtInt(buf[:w], u)</code></span>
<span class="codeline" id="line-652"><code>	} else {</code></span>
<span class="codeline" id="line-653"><code>		w--</code></span>
<span class="codeline" id="line-654"><code>		buf[w] = 's'</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>		w, u = fmtFrac(buf[:w], u, 9)</code></span>
<span class="codeline" id="line-657"><code></code></span>
<span class="codeline" id="line-658"><code>		// u is now integer seconds</code></span>
<span class="codeline" id="line-659"><code>		w = fmtInt(buf[:w], u%60)</code></span>
<span class="codeline" id="line-660"><code>		u /= 60</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>		// u is now integer minutes</code></span>
<span class="codeline" id="line-663"><code>		if u &gt; 0 {</code></span>
<span class="codeline" id="line-664"><code>			w--</code></span>
<span class="codeline" id="line-665"><code>			buf[w] = 'm'</code></span>
<span class="codeline" id="line-666"><code>			w = fmtInt(buf[:w], u%60)</code></span>
<span class="codeline" id="line-667"><code>			u /= 60</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>			// u is now integer hours</code></span>
<span class="codeline" id="line-670"><code>			// Stop at hours because days can be different lengths.</code></span>
<span class="codeline" id="line-671"><code>			if u &gt; 0 {</code></span>
<span class="codeline" id="line-672"><code>				w--</code></span>
<span class="codeline" id="line-673"><code>				buf[w] = 'h'</code></span>
<span class="codeline" id="line-674"><code>				w = fmtInt(buf[:w], u)</code></span>
<span class="codeline" id="line-675"><code>			}</code></span>
<span class="codeline" id="line-676"><code>		}</code></span>
<span class="codeline" id="line-677"><code>	}</code></span>
<span class="codeline" id="line-678"><code></code></span>
<span class="codeline" id="line-679"><code>	if neg {</code></span>
<span class="codeline" id="line-680"><code>		w--</code></span>
<span class="codeline" id="line-681"><code>		buf[w] = '-'</code></span>
<span class="codeline" id="line-682"><code>	}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>	return string(buf[w:])</code></span>
<span class="codeline" id="line-685"><code>}</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>// fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the</code></span>
<span class="codeline" id="line-688"><code>// tail of buf, omitting trailing zeros. It omits the decimal</code></span>
<span class="codeline" id="line-689"><code>// point too when the fraction is 0. It returns the index where the</code></span>
<span class="codeline" id="line-690"><code>// output bytes begin and the value v/10**prec.</code></span>
<span class="codeline" id="line-691"><code>func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64) {</code></span>
<span class="codeline" id="line-692"><code>	// Omit trailing zeros up to and including decimal point.</code></span>
<span class="codeline" id="line-693"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-694"><code>	print := false</code></span>
<span class="codeline" id="line-695"><code>	for i := 0; i &lt; prec; i++ {</code></span>
<span class="codeline" id="line-696"><code>		digit := v % 10</code></span>
<span class="codeline" id="line-697"><code>		print = print || digit != 0</code></span>
<span class="codeline" id="line-698"><code>		if print {</code></span>
<span class="codeline" id="line-699"><code>			w--</code></span>
<span class="codeline" id="line-700"><code>			buf[w] = byte(digit) + '0'</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>		v /= 10</code></span>
<span class="codeline" id="line-703"><code>	}</code></span>
<span class="codeline" id="line-704"><code>	if print {</code></span>
<span class="codeline" id="line-705"><code>		w--</code></span>
<span class="codeline" id="line-706"><code>		buf[w] = '.'</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	return w, v</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>// fmtInt formats v into the tail of buf.</code></span>
<span class="codeline" id="line-712"><code>// It returns the index where the output begins.</code></span>
<span class="codeline" id="line-713"><code>func fmtInt(buf []byte, v uint64) int {</code></span>
<span class="codeline" id="line-714"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-715"><code>	if v == 0 {</code></span>
<span class="codeline" id="line-716"><code>		w--</code></span>
<span class="codeline" id="line-717"><code>		buf[w] = '0'</code></span>
<span class="codeline" id="line-718"><code>	} else {</code></span>
<span class="codeline" id="line-719"><code>		for v &gt; 0 {</code></span>
<span class="codeline" id="line-720"><code>			w--</code></span>
<span class="codeline" id="line-721"><code>			buf[w] = byte(v%10) + '0'</code></span>
<span class="codeline" id="line-722"><code>			v /= 10</code></span>
<span class="codeline" id="line-723"><code>		}</code></span>
<span class="codeline" id="line-724"><code>	}</code></span>
<span class="codeline" id="line-725"><code>	return w</code></span>
<span class="codeline" id="line-726"><code>}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>// Nanoseconds returns the duration as an integer nanosecond count.</code></span>
<span class="codeline" id="line-729"><code>func (d Duration) Nanoseconds() int64 { return int64(d) }</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>// Microseconds returns the duration as an integer microsecond count.</code></span>
<span class="codeline" id="line-732"><code>func (d Duration) Microseconds() int64 { return int64(d) / 1e3 }</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>// Milliseconds returns the duration as an integer millisecond count.</code></span>
<span class="codeline" id="line-735"><code>func (d Duration) Milliseconds() int64 { return int64(d) / 1e6 }</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>// These methods return float64 because the dominant</code></span>
<span class="codeline" id="line-738"><code>// use case is for printing a floating point number like 1.5s, and</code></span>
<span class="codeline" id="line-739"><code>// a truncation to integer would make them not useful in those cases.</code></span>
<span class="codeline" id="line-740"><code>// Splitting the integer and fraction ourselves guarantees that</code></span>
<span class="codeline" id="line-741"><code>// converting the returned float64 to an integer rounds the same</code></span>
<span class="codeline" id="line-742"><code>// way that a pure integer conversion would have, even in cases</code></span>
<span class="codeline" id="line-743"><code>// where, say, float64(d.Nanoseconds())/1e9 would have rounded</code></span>
<span class="codeline" id="line-744"><code>// differently.</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>// Seconds returns the duration as a floating point number of seconds.</code></span>
<span class="codeline" id="line-747"><code>func (d Duration) Seconds() float64 {</code></span>
<span class="codeline" id="line-748"><code>	sec := d / Second</code></span>
<span class="codeline" id="line-749"><code>	nsec := d % Second</code></span>
<span class="codeline" id="line-750"><code>	return float64(sec) + float64(nsec)/1e9</code></span>
<span class="codeline" id="line-751"><code>}</code></span>
<span class="codeline" id="line-752"><code></code></span>
<span class="codeline" id="line-753"><code>// Minutes returns the duration as a floating point number of minutes.</code></span>
<span class="codeline" id="line-754"><code>func (d Duration) Minutes() float64 {</code></span>
<span class="codeline" id="line-755"><code>	min := d / Minute</code></span>
<span class="codeline" id="line-756"><code>	nsec := d % Minute</code></span>
<span class="codeline" id="line-757"><code>	return float64(min) + float64(nsec)/(60*1e9)</code></span>
<span class="codeline" id="line-758"><code>}</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>// Hours returns the duration as a floating point number of hours.</code></span>
<span class="codeline" id="line-761"><code>func (d Duration) Hours() float64 {</code></span>
<span class="codeline" id="line-762"><code>	hour := d / Hour</code></span>
<span class="codeline" id="line-763"><code>	nsec := d % Hour</code></span>
<span class="codeline" id="line-764"><code>	return float64(hour) + float64(nsec)/(60*60*1e9)</code></span>
<span class="codeline" id="line-765"><code>}</code></span>
<span class="codeline" id="line-766"><code></code></span>
<span class="codeline" id="line-767"><code>// Truncate returns the result of rounding d toward zero to a multiple of m.</code></span>
<span class="codeline" id="line-768"><code>// If m &lt;= 0, Truncate returns d unchanged.</code></span>
<span class="codeline" id="line-769"><code>func (d Duration) Truncate(m Duration) Duration {</code></span>
<span class="codeline" id="line-770"><code>	if m &lt;= 0 {</code></span>
<span class="codeline" id="line-771"><code>		return d</code></span>
<span class="codeline" id="line-772"><code>	}</code></span>
<span class="codeline" id="line-773"><code>	return d - d%m</code></span>
<span class="codeline" id="line-774"><code>}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>// lessThanHalf reports whether x+x &lt; y but avoids overflow,</code></span>
<span class="codeline" id="line-777"><code>// assuming x and y are both positive (Duration is signed).</code></span>
<span class="codeline" id="line-778"><code>func lessThanHalf(x, y Duration) bool {</code></span>
<span class="codeline" id="line-779"><code>	return uint64(x)+uint64(x) &lt; uint64(y)</code></span>
<span class="codeline" id="line-780"><code>}</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>// Round returns the result of rounding d to the nearest multiple of m.</code></span>
<span class="codeline" id="line-783"><code>// The rounding behavior for halfway values is to round away from zero.</code></span>
<span class="codeline" id="line-784"><code>// If the result exceeds the maximum (or minimum)</code></span>
<span class="codeline" id="line-785"><code>// value that can be stored in a Duration,</code></span>
<span class="codeline" id="line-786"><code>// Round returns the maximum (or minimum) duration.</code></span>
<span class="codeline" id="line-787"><code>// If m &lt;= 0, Round returns d unchanged.</code></span>
<span class="codeline" id="line-788"><code>func (d Duration) Round(m Duration) Duration {</code></span>
<span class="codeline" id="line-789"><code>	if m &lt;= 0 {</code></span>
<span class="codeline" id="line-790"><code>		return d</code></span>
<span class="codeline" id="line-791"><code>	}</code></span>
<span class="codeline" id="line-792"><code>	r := d % m</code></span>
<span class="codeline" id="line-793"><code>	if d &lt; 0 {</code></span>
<span class="codeline" id="line-794"><code>		r = -r</code></span>
<span class="codeline" id="line-795"><code>		if lessThanHalf(r, m) {</code></span>
<span class="codeline" id="line-796"><code>			return d + r</code></span>
<span class="codeline" id="line-797"><code>		}</code></span>
<span class="codeline" id="line-798"><code>		if d1 := d - m + r; d1 &lt; d {</code></span>
<span class="codeline" id="line-799"><code>			return d1</code></span>
<span class="codeline" id="line-800"><code>		}</code></span>
<span class="codeline" id="line-801"><code>		return minDuration // overflow</code></span>
<span class="codeline" id="line-802"><code>	}</code></span>
<span class="codeline" id="line-803"><code>	if lessThanHalf(r, m) {</code></span>
<span class="codeline" id="line-804"><code>		return d - r</code></span>
<span class="codeline" id="line-805"><code>	}</code></span>
<span class="codeline" id="line-806"><code>	if d1 := d + m - r; d1 &gt; d {</code></span>
<span class="codeline" id="line-807"><code>		return d1</code></span>
<span class="codeline" id="line-808"><code>	}</code></span>
<span class="codeline" id="line-809"><code>	return maxDuration // overflow</code></span>
<span class="codeline" id="line-810"><code>}</code></span>
<span class="codeline" id="line-811"><code></code></span>
<span class="codeline" id="line-812"><code>// Add returns the time t+d.</code></span>
<span class="codeline" id="line-813"><code>func (t Time) Add(d Duration) Time {</code></span>
<span class="codeline" id="line-814"><code>	dsec := int64(d / 1e9)</code></span>
<span class="codeline" id="line-815"><code>	nsec := t.nsec() + int32(d%1e9)</code></span>
<span class="codeline" id="line-816"><code>	if nsec &gt;= 1e9 {</code></span>
<span class="codeline" id="line-817"><code>		dsec++</code></span>
<span class="codeline" id="line-818"><code>		nsec -= 1e9</code></span>
<span class="codeline" id="line-819"><code>	} else if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-820"><code>		dsec--</code></span>
<span class="codeline" id="line-821"><code>		nsec += 1e9</code></span>
<span class="codeline" id="line-822"><code>	}</code></span>
<span class="codeline" id="line-823"><code>	t.wall = t.wall&amp;^nsecMask | uint64(nsec) // update nsec</code></span>
<span class="codeline" id="line-824"><code>	t.addSec(dsec)</code></span>
<span class="codeline" id="line-825"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-826"><code>		te := t.ext + int64(d)</code></span>
<span class="codeline" id="line-827"><code>		if d &lt; 0 &amp;&amp; te &gt; t.ext || d &gt; 0 &amp;&amp; te &lt; t.ext {</code></span>
<span class="codeline" id="line-828"><code>			// Monotonic clock reading now out of range; degrade to wall-only.</code></span>
<span class="codeline" id="line-829"><code>			t.stripMono()</code></span>
<span class="codeline" id="line-830"><code>		} else {</code></span>
<span class="codeline" id="line-831"><code>			t.ext = te</code></span>
<span class="codeline" id="line-832"><code>		}</code></span>
<span class="codeline" id="line-833"><code>	}</code></span>
<span class="codeline" id="line-834"><code>	return t</code></span>
<span class="codeline" id="line-835"><code>}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>// Sub returns the duration t-u. If the result exceeds the maximum (or minimum)</code></span>
<span class="codeline" id="line-838"><code>// value that can be stored in a Duration, the maximum (or minimum) duration</code></span>
<span class="codeline" id="line-839"><code>// will be returned.</code></span>
<span class="codeline" id="line-840"><code>// To compute t-d for a duration d, use t.Add(-d).</code></span>
<span class="codeline" id="line-841"><code>func (t Time) Sub(u Time) Duration {</code></span>
<span class="codeline" id="line-842"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-843"><code>		te := t.ext</code></span>
<span class="codeline" id="line-844"><code>		ue := u.ext</code></span>
<span class="codeline" id="line-845"><code>		d := Duration(te - ue)</code></span>
<span class="codeline" id="line-846"><code>		if d &lt; 0 &amp;&amp; te &gt; ue {</code></span>
<span class="codeline" id="line-847"><code>			return maxDuration // t - u is positive out of range</code></span>
<span class="codeline" id="line-848"><code>		}</code></span>
<span class="codeline" id="line-849"><code>		if d &gt; 0 &amp;&amp; te &lt; ue {</code></span>
<span class="codeline" id="line-850"><code>			return minDuration // t - u is negative out of range</code></span>
<span class="codeline" id="line-851"><code>		}</code></span>
<span class="codeline" id="line-852"><code>		return d</code></span>
<span class="codeline" id="line-853"><code>	}</code></span>
<span class="codeline" id="line-854"><code>	d := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())</code></span>
<span class="codeline" id="line-855"><code>	// Check for overflow or underflow.</code></span>
<span class="codeline" id="line-856"><code>	switch {</code></span>
<span class="codeline" id="line-857"><code>	case u.Add(d).Equal(t):</code></span>
<span class="codeline" id="line-858"><code>		return d // d is correct</code></span>
<span class="codeline" id="line-859"><code>	case t.Before(u):</code></span>
<span class="codeline" id="line-860"><code>		return minDuration // t - u is negative out of range</code></span>
<span class="codeline" id="line-861"><code>	default:</code></span>
<span class="codeline" id="line-862"><code>		return maxDuration // t - u is positive out of range</code></span>
<span class="codeline" id="line-863"><code>	}</code></span>
<span class="codeline" id="line-864"><code>}</code></span>
<span class="codeline" id="line-865"><code></code></span>
<span class="codeline" id="line-866"><code>// Since returns the time elapsed since t.</code></span>
<span class="codeline" id="line-867"><code>// It is shorthand for time.Now().Sub(t).</code></span>
<span class="codeline" id="line-868"><code>func Since(t Time) Duration {</code></span>
<span class="codeline" id="line-869"><code>	var now Time</code></span>
<span class="codeline" id="line-870"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-871"><code>		// Common case optimization: if t has monotonic time, then Sub will use only it.</code></span>
<span class="codeline" id="line-872"><code>		now = Time{hasMonotonic, runtimeNano() - startNano, nil}</code></span>
<span class="codeline" id="line-873"><code>	} else {</code></span>
<span class="codeline" id="line-874"><code>		now = Now()</code></span>
<span class="codeline" id="line-875"><code>	}</code></span>
<span class="codeline" id="line-876"><code>	return now.Sub(t)</code></span>
<span class="codeline" id="line-877"><code>}</code></span>
<span class="codeline" id="line-878"><code></code></span>
<span class="codeline" id="line-879"><code>// Until returns the duration until t.</code></span>
<span class="codeline" id="line-880"><code>// It is shorthand for t.Sub(time.Now()).</code></span>
<span class="codeline" id="line-881"><code>func Until(t Time) Duration {</code></span>
<span class="codeline" id="line-882"><code>	var now Time</code></span>
<span class="codeline" id="line-883"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-884"><code>		// Common case optimization: if t has monotonic time, then Sub will use only it.</code></span>
<span class="codeline" id="line-885"><code>		now = Time{hasMonotonic, runtimeNano() - startNano, nil}</code></span>
<span class="codeline" id="line-886"><code>	} else {</code></span>
<span class="codeline" id="line-887"><code>		now = Now()</code></span>
<span class="codeline" id="line-888"><code>	}</code></span>
<span class="codeline" id="line-889"><code>	return t.Sub(now)</code></span>
<span class="codeline" id="line-890"><code>}</code></span>
<span class="codeline" id="line-891"><code></code></span>
<span class="codeline" id="line-892"><code>// AddDate returns the time corresponding to adding the</code></span>
<span class="codeline" id="line-893"><code>// given number of years, months, and days to t.</code></span>
<span class="codeline" id="line-894"><code>// For example, AddDate(-1, 2, 3) applied to January 1, 2011</code></span>
<span class="codeline" id="line-895"><code>// returns March 4, 2010.</code></span>
<span class="codeline" id="line-896"><code>//</code></span>
<span class="codeline" id="line-897"><code>// AddDate normalizes its result in the same way that Date does,</code></span>
<span class="codeline" id="line-898"><code>// so, for example, adding one month to October 31 yields</code></span>
<span class="codeline" id="line-899"><code>// December 1, the normalized form for November 31.</code></span>
<span class="codeline" id="line-900"><code>func (t Time) AddDate(years int, months int, days int) Time {</code></span>
<span class="codeline" id="line-901"><code>	year, month, day := t.Date()</code></span>
<span class="codeline" id="line-902"><code>	hour, min, sec := t.Clock()</code></span>
<span class="codeline" id="line-903"><code>	return Date(year+years, month+Month(months), day+days, hour, min, sec, int(t.nsec()), t.Location())</code></span>
<span class="codeline" id="line-904"><code>}</code></span>
<span class="codeline" id="line-905"><code></code></span>
<span class="codeline" id="line-906"><code>const (</code></span>
<span class="codeline" id="line-907"><code>	secondsPerMinute = 60</code></span>
<span class="codeline" id="line-908"><code>	secondsPerHour   = 60 * secondsPerMinute</code></span>
<span class="codeline" id="line-909"><code>	secondsPerDay    = 24 * secondsPerHour</code></span>
<span class="codeline" id="line-910"><code>	secondsPerWeek   = 7 * secondsPerDay</code></span>
<span class="codeline" id="line-911"><code>	daysPer400Years  = 365*400 + 97</code></span>
<span class="codeline" id="line-912"><code>	daysPer100Years  = 365*100 + 24</code></span>
<span class="codeline" id="line-913"><code>	daysPer4Years    = 365*4 + 1</code></span>
<span class="codeline" id="line-914"><code>)</code></span>
<span class="codeline" id="line-915"><code></code></span>
<span class="codeline" id="line-916"><code>// date computes the year, day of year, and when full=true,</code></span>
<span class="codeline" id="line-917"><code>// the month and day in which t occurs.</code></span>
<span class="codeline" id="line-918"><code>func (t Time) date(full bool) (year int, month Month, day int, yday int) {</code></span>
<span class="codeline" id="line-919"><code>	return absDate(t.abs(), full)</code></span>
<span class="codeline" id="line-920"><code>}</code></span>
<span class="codeline" id="line-921"><code></code></span>
<span class="codeline" id="line-922"><code>// absDate is like date but operates on an absolute time.</code></span>
<span class="codeline" id="line-923"><code>func absDate(abs uint64, full bool) (year int, month Month, day int, yday int) {</code></span>
<span class="codeline" id="line-924"><code>	// Split into time and day.</code></span>
<span class="codeline" id="line-925"><code>	d := abs / secondsPerDay</code></span>
<span class="codeline" id="line-926"><code></code></span>
<span class="codeline" id="line-927"><code>	// Account for 400 year cycles.</code></span>
<span class="codeline" id="line-928"><code>	n := d / daysPer400Years</code></span>
<span class="codeline" id="line-929"><code>	y := 400 * n</code></span>
<span class="codeline" id="line-930"><code>	d -= daysPer400Years * n</code></span>
<span class="codeline" id="line-931"><code></code></span>
<span class="codeline" id="line-932"><code>	// Cut off 100-year cycles.</code></span>
<span class="codeline" id="line-933"><code>	// The last cycle has one extra leap year, so on the last day</code></span>
<span class="codeline" id="line-934"><code>	// of that year, day / daysPer100Years will be 4 instead of 3.</code></span>
<span class="codeline" id="line-935"><code>	// Cut it back down to 3 by subtracting n&gt;&gt;2.</code></span>
<span class="codeline" id="line-936"><code>	n = d / daysPer100Years</code></span>
<span class="codeline" id="line-937"><code>	n -= n &gt;&gt; 2</code></span>
<span class="codeline" id="line-938"><code>	y += 100 * n</code></span>
<span class="codeline" id="line-939"><code>	d -= daysPer100Years * n</code></span>
<span class="codeline" id="line-940"><code></code></span>
<span class="codeline" id="line-941"><code>	// Cut off 4-year cycles.</code></span>
<span class="codeline" id="line-942"><code>	// The last cycle has a missing leap year, which does not</code></span>
<span class="codeline" id="line-943"><code>	// affect the computation.</code></span>
<span class="codeline" id="line-944"><code>	n = d / daysPer4Years</code></span>
<span class="codeline" id="line-945"><code>	y += 4 * n</code></span>
<span class="codeline" id="line-946"><code>	d -= daysPer4Years * n</code></span>
<span class="codeline" id="line-947"><code></code></span>
<span class="codeline" id="line-948"><code>	// Cut off years within a 4-year cycle.</code></span>
<span class="codeline" id="line-949"><code>	// The last year is a leap year, so on the last day of that year,</code></span>
<span class="codeline" id="line-950"><code>	// day / 365 will be 4 instead of 3. Cut it back down to 3</code></span>
<span class="codeline" id="line-951"><code>	// by subtracting n&gt;&gt;2.</code></span>
<span class="codeline" id="line-952"><code>	n = d / 365</code></span>
<span class="codeline" id="line-953"><code>	n -= n &gt;&gt; 2</code></span>
<span class="codeline" id="line-954"><code>	y += n</code></span>
<span class="codeline" id="line-955"><code>	d -= 365 * n</code></span>
<span class="codeline" id="line-956"><code></code></span>
<span class="codeline" id="line-957"><code>	year = int(int64(y) + absoluteZeroYear)</code></span>
<span class="codeline" id="line-958"><code>	yday = int(d)</code></span>
<span class="codeline" id="line-959"><code></code></span>
<span class="codeline" id="line-960"><code>	if !full {</code></span>
<span class="codeline" id="line-961"><code>		return</code></span>
<span class="codeline" id="line-962"><code>	}</code></span>
<span class="codeline" id="line-963"><code></code></span>
<span class="codeline" id="line-964"><code>	day = yday</code></span>
<span class="codeline" id="line-965"><code>	if isLeap(year) {</code></span>
<span class="codeline" id="line-966"><code>		// Leap year</code></span>
<span class="codeline" id="line-967"><code>		switch {</code></span>
<span class="codeline" id="line-968"><code>		case day &gt; 31+29-1:</code></span>
<span class="codeline" id="line-969"><code>			// After leap day; pretend it wasn't there.</code></span>
<span class="codeline" id="line-970"><code>			day--</code></span>
<span class="codeline" id="line-971"><code>		case day == 31+29-1:</code></span>
<span class="codeline" id="line-972"><code>			// Leap day.</code></span>
<span class="codeline" id="line-973"><code>			month = February</code></span>
<span class="codeline" id="line-974"><code>			day = 29</code></span>
<span class="codeline" id="line-975"><code>			return</code></span>
<span class="codeline" id="line-976"><code>		}</code></span>
<span class="codeline" id="line-977"><code>	}</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>	// Estimate month on assumption that every month has 31 days.</code></span>
<span class="codeline" id="line-980"><code>	// The estimate may be too low by at most one month, so adjust.</code></span>
<span class="codeline" id="line-981"><code>	month = Month(day / 31)</code></span>
<span class="codeline" id="line-982"><code>	end := int(daysBefore[month+1])</code></span>
<span class="codeline" id="line-983"><code>	var begin int</code></span>
<span class="codeline" id="line-984"><code>	if day &gt;= end {</code></span>
<span class="codeline" id="line-985"><code>		month++</code></span>
<span class="codeline" id="line-986"><code>		begin = end</code></span>
<span class="codeline" id="line-987"><code>	} else {</code></span>
<span class="codeline" id="line-988"><code>		begin = int(daysBefore[month])</code></span>
<span class="codeline" id="line-989"><code>	}</code></span>
<span class="codeline" id="line-990"><code></code></span>
<span class="codeline" id="line-991"><code>	month++ // because January is 1</code></span>
<span class="codeline" id="line-992"><code>	day = day - begin + 1</code></span>
<span class="codeline" id="line-993"><code>	return</code></span>
<span class="codeline" id="line-994"><code>}</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>// daysBefore[m] counts the number of days in a non-leap year</code></span>
<span class="codeline" id="line-997"><code>// before month m begins. There is an entry for m=12, counting</code></span>
<span class="codeline" id="line-998"><code>// the number of days before January of next year (365).</code></span>
<span class="codeline" id="line-999"><code>var daysBefore = [...]int32{</code></span>
<span class="codeline" id="line-1000"><code>	0,</code></span>
<span class="codeline" id="line-1001"><code>	31,</code></span>
<span class="codeline" id="line-1002"><code>	31 + 28,</code></span>
<span class="codeline" id="line-1003"><code>	31 + 28 + 31,</code></span>
<span class="codeline" id="line-1004"><code>	31 + 28 + 31 + 30,</code></span>
<span class="codeline" id="line-1005"><code>	31 + 28 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1006"><code>	31 + 28 + 31 + 30 + 31 + 30,</code></span>
<span class="codeline" id="line-1007"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1008"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,</code></span>
<span class="codeline" id="line-1009"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,</code></span>
<span class="codeline" id="line-1010"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1011"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,</code></span>
<span class="codeline" id="line-1012"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1013"><code>}</code></span>
<span class="codeline" id="line-1014"><code></code></span>
<span class="codeline" id="line-1015"><code>func daysIn(m Month, year int) int {</code></span>
<span class="codeline" id="line-1016"><code>	if m == February &amp;&amp; isLeap(year) {</code></span>
<span class="codeline" id="line-1017"><code>		return 29</code></span>
<span class="codeline" id="line-1018"><code>	}</code></span>
<span class="codeline" id="line-1019"><code>	return int(daysBefore[m] - daysBefore[m-1])</code></span>
<span class="codeline" id="line-1020"><code>}</code></span>
<span class="codeline" id="line-1021"><code></code></span>
<span class="codeline" id="line-1022"><code>// daysSinceEpoch takes a year and returns the number of days from</code></span>
<span class="codeline" id="line-1023"><code>// the absolute epoch to the start of that year.</code></span>
<span class="codeline" id="line-1024"><code>// This is basically (year - zeroYear) * 365, but accounting for leap days.</code></span>
<span class="codeline" id="line-1025"><code>func daysSinceEpoch(year int) uint64 {</code></span>
<span class="codeline" id="line-1026"><code>	y := uint64(int64(year) - absoluteZeroYear)</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>	// Add in days from 400-year cycles.</code></span>
<span class="codeline" id="line-1029"><code>	n := y / 400</code></span>
<span class="codeline" id="line-1030"><code>	y -= 400 * n</code></span>
<span class="codeline" id="line-1031"><code>	d := daysPer400Years * n</code></span>
<span class="codeline" id="line-1032"><code></code></span>
<span class="codeline" id="line-1033"><code>	// Add in 100-year cycles.</code></span>
<span class="codeline" id="line-1034"><code>	n = y / 100</code></span>
<span class="codeline" id="line-1035"><code>	y -= 100 * n</code></span>
<span class="codeline" id="line-1036"><code>	d += daysPer100Years * n</code></span>
<span class="codeline" id="line-1037"><code></code></span>
<span class="codeline" id="line-1038"><code>	// Add in 4-year cycles.</code></span>
<span class="codeline" id="line-1039"><code>	n = y / 4</code></span>
<span class="codeline" id="line-1040"><code>	y -= 4 * n</code></span>
<span class="codeline" id="line-1041"><code>	d += daysPer4Years * n</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>	// Add in non-leap years.</code></span>
<span class="codeline" id="line-1044"><code>	n = y</code></span>
<span class="codeline" id="line-1045"><code>	d += 365 * n</code></span>
<span class="codeline" id="line-1046"><code></code></span>
<span class="codeline" id="line-1047"><code>	return d</code></span>
<span class="codeline" id="line-1048"><code>}</code></span>
<span class="codeline" id="line-1049"><code></code></span>
<span class="codeline" id="line-1050"><code>// Provided by package runtime.</code></span>
<span class="codeline" id="line-1051"><code>func now() (sec int64, nsec int32, mono int64)</code></span>
<span class="codeline" id="line-1052"><code></code></span>
<span class="codeline" id="line-1053"><code>// runtimeNano returns the current value of the runtime clock in nanoseconds.</code></span>
<span class="codeline" id="line-1054"><code>//go:linkname runtimeNano runtime.nanotime</code></span>
<span class="codeline" id="line-1055"><code>func runtimeNano() int64</code></span>
<span class="codeline" id="line-1056"><code></code></span>
<span class="codeline" id="line-1057"><code>// Monotonic times are reported as offsets from startNano.</code></span>
<span class="codeline" id="line-1058"><code>// We initialize startNano to runtimeNano() - 1 so that on systems where</code></span>
<span class="codeline" id="line-1059"><code>// monotonic time resolution is fairly low (e.g. Windows 2008</code></span>
<span class="codeline" id="line-1060"><code>// which appears to have a default resolution of 15ms),</code></span>
<span class="codeline" id="line-1061"><code>// we avoid ever reporting a monotonic time of 0.</code></span>
<span class="codeline" id="line-1062"><code>// (Callers may want to use 0 as "time not set".)</code></span>
<span class="codeline" id="line-1063"><code>var startNano int64 = runtimeNano() - 1</code></span>
<span class="codeline" id="line-1064"><code></code></span>
<span class="codeline" id="line-1065"><code>// Now returns the current local time.</code></span>
<span class="codeline" id="line-1066"><code>func Now() Time {</code></span>
<span class="codeline" id="line-1067"><code>	sec, nsec, mono := now()</code></span>
<span class="codeline" id="line-1068"><code>	mono -= startNano</code></span>
<span class="codeline" id="line-1069"><code>	sec += unixToInternal - minWall</code></span>
<span class="codeline" id="line-1070"><code>	if uint64(sec)&gt;&gt;33 != 0 {</code></span>
<span class="codeline" id="line-1071"><code>		return Time{uint64(nsec), sec + minWall, Local}</code></span>
<span class="codeline" id="line-1072"><code>	}</code></span>
<span class="codeline" id="line-1073"><code>	return Time{hasMonotonic | uint64(sec)&lt;&lt;nsecShift | uint64(nsec), mono, Local}</code></span>
<span class="codeline" id="line-1074"><code>}</code></span>
<span class="codeline" id="line-1075"><code></code></span>
<span class="codeline" id="line-1076"><code>func unixTime(sec int64, nsec int32) Time {</code></span>
<span class="codeline" id="line-1077"><code>	return Time{uint64(nsec), sec + unixToInternal, Local}</code></span>
<span class="codeline" id="line-1078"><code>}</code></span>
<span class="codeline" id="line-1079"><code></code></span>
<span class="codeline" id="line-1080"><code>// UTC returns t with the location set to UTC.</code></span>
<span class="codeline" id="line-1081"><code>func (t Time) UTC() Time {</code></span>
<span class="codeline" id="line-1082"><code>	t.setLoc(&amp;utcLoc)</code></span>
<span class="codeline" id="line-1083"><code>	return t</code></span>
<span class="codeline" id="line-1084"><code>}</code></span>
<span class="codeline" id="line-1085"><code></code></span>
<span class="codeline" id="line-1086"><code>// Local returns t with the location set to local time.</code></span>
<span class="codeline" id="line-1087"><code>func (t Time) Local() Time {</code></span>
<span class="codeline" id="line-1088"><code>	t.setLoc(Local)</code></span>
<span class="codeline" id="line-1089"><code>	return t</code></span>
<span class="codeline" id="line-1090"><code>}</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>// In returns a copy of t representing the same time instant, but</code></span>
<span class="codeline" id="line-1093"><code>// with the copy's location information set to loc for display</code></span>
<span class="codeline" id="line-1094"><code>// purposes.</code></span>
<span class="codeline" id="line-1095"><code>//</code></span>
<span class="codeline" id="line-1096"><code>// In panics if loc is nil.</code></span>
<span class="codeline" id="line-1097"><code>func (t Time) In(loc *Location) Time {</code></span>
<span class="codeline" id="line-1098"><code>	if loc == nil {</code></span>
<span class="codeline" id="line-1099"><code>		panic("time: missing Location in call to Time.In")</code></span>
<span class="codeline" id="line-1100"><code>	}</code></span>
<span class="codeline" id="line-1101"><code>	t.setLoc(loc)</code></span>
<span class="codeline" id="line-1102"><code>	return t</code></span>
<span class="codeline" id="line-1103"><code>}</code></span>
<span class="codeline" id="line-1104"><code></code></span>
<span class="codeline" id="line-1105"><code>// Location returns the time zone information associated with t.</code></span>
<span class="codeline" id="line-1106"><code>func (t Time) Location() *Location {</code></span>
<span class="codeline" id="line-1107"><code>	l := t.loc</code></span>
<span class="codeline" id="line-1108"><code>	if l == nil {</code></span>
<span class="codeline" id="line-1109"><code>		l = UTC</code></span>
<span class="codeline" id="line-1110"><code>	}</code></span>
<span class="codeline" id="line-1111"><code>	return l</code></span>
<span class="codeline" id="line-1112"><code>}</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>// Zone computes the time zone in effect at time t, returning the abbreviated</code></span>
<span class="codeline" id="line-1115"><code>// name of the zone (such as "CET") and its offset in seconds east of UTC.</code></span>
<span class="codeline" id="line-1116"><code>func (t Time) Zone() (name string, offset int) {</code></span>
<span class="codeline" id="line-1117"><code>	name, offset, _, _ = t.loc.lookup(t.unixSec())</code></span>
<span class="codeline" id="line-1118"><code>	return</code></span>
<span class="codeline" id="line-1119"><code>}</code></span>
<span class="codeline" id="line-1120"><code></code></span>
<span class="codeline" id="line-1121"><code>// Unix returns t as a Unix time, the number of seconds elapsed</code></span>
<span class="codeline" id="line-1122"><code>// since January 1, 1970 UTC. The result does not depend on the</code></span>
<span class="codeline" id="line-1123"><code>// location associated with t.</code></span>
<span class="codeline" id="line-1124"><code>// Unix-like operating systems often record time as a 32-bit</code></span>
<span class="codeline" id="line-1125"><code>// count of seconds, but since the method here returns a 64-bit</code></span>
<span class="codeline" id="line-1126"><code>// value it is valid for billions of years into the past or future.</code></span>
<span class="codeline" id="line-1127"><code>func (t Time) Unix() int64 {</code></span>
<span class="codeline" id="line-1128"><code>	return t.unixSec()</code></span>
<span class="codeline" id="line-1129"><code>}</code></span>
<span class="codeline" id="line-1130"><code></code></span>
<span class="codeline" id="line-1131"><code>// UnixNano returns t as a Unix time, the number of nanoseconds elapsed</code></span>
<span class="codeline" id="line-1132"><code>// since January 1, 1970 UTC. The result is undefined if the Unix time</code></span>
<span class="codeline" id="line-1133"><code>// in nanoseconds cannot be represented by an int64 (a date before the year</code></span>
<span class="codeline" id="line-1134"><code>// 1678 or after 2262). Note that this means the result of calling UnixNano</code></span>
<span class="codeline" id="line-1135"><code>// on the zero Time is undefined. The result does not depend on the</code></span>
<span class="codeline" id="line-1136"><code>// location associated with t.</code></span>
<span class="codeline" id="line-1137"><code>func (t Time) UnixNano() int64 {</code></span>
<span class="codeline" id="line-1138"><code>	return (t.unixSec())*1e9 + int64(t.nsec())</code></span>
<span class="codeline" id="line-1139"><code>}</code></span>
<span class="codeline" id="line-1140"><code></code></span>
<span class="codeline" id="line-1141"><code>const timeBinaryVersion byte = 1</code></span>
<span class="codeline" id="line-1142"><code></code></span>
<span class="codeline" id="line-1143"><code>// MarshalBinary implements the encoding.BinaryMarshaler interface.</code></span>
<span class="codeline" id="line-1144"><code>func (t Time) MarshalBinary() ([]byte, error) {</code></span>
<span class="codeline" id="line-1145"><code>	var offsetMin int16 // minutes east of UTC. -1 is UTC.</code></span>
<span class="codeline" id="line-1146"><code></code></span>
<span class="codeline" id="line-1147"><code>	if t.Location() == UTC {</code></span>
<span class="codeline" id="line-1148"><code>		offsetMin = -1</code></span>
<span class="codeline" id="line-1149"><code>	} else {</code></span>
<span class="codeline" id="line-1150"><code>		_, offset := t.Zone()</code></span>
<span class="codeline" id="line-1151"><code>		if offset%60 != 0 {</code></span>
<span class="codeline" id="line-1152"><code>			return nil, errors.New("Time.MarshalBinary: zone offset has fractional minute")</code></span>
<span class="codeline" id="line-1153"><code>		}</code></span>
<span class="codeline" id="line-1154"><code>		offset /= 60</code></span>
<span class="codeline" id="line-1155"><code>		if offset &lt; -32768 || offset == -1 || offset &gt; 32767 {</code></span>
<span class="codeline" id="line-1156"><code>			return nil, errors.New("Time.MarshalBinary: unexpected zone offset")</code></span>
<span class="codeline" id="line-1157"><code>		}</code></span>
<span class="codeline" id="line-1158"><code>		offsetMin = int16(offset)</code></span>
<span class="codeline" id="line-1159"><code>	}</code></span>
<span class="codeline" id="line-1160"><code></code></span>
<span class="codeline" id="line-1161"><code>	sec := t.sec()</code></span>
<span class="codeline" id="line-1162"><code>	nsec := t.nsec()</code></span>
<span class="codeline" id="line-1163"><code>	enc := []byte{</code></span>
<span class="codeline" id="line-1164"><code>		timeBinaryVersion, // byte 0 : version</code></span>
<span class="codeline" id="line-1165"><code>		byte(sec &gt;&gt; 56),   // bytes 1-8: seconds</code></span>
<span class="codeline" id="line-1166"><code>		byte(sec &gt;&gt; 48),</code></span>
<span class="codeline" id="line-1167"><code>		byte(sec &gt;&gt; 40),</code></span>
<span class="codeline" id="line-1168"><code>		byte(sec &gt;&gt; 32),</code></span>
<span class="codeline" id="line-1169"><code>		byte(sec &gt;&gt; 24),</code></span>
<span class="codeline" id="line-1170"><code>		byte(sec &gt;&gt; 16),</code></span>
<span class="codeline" id="line-1171"><code>		byte(sec &gt;&gt; 8),</code></span>
<span class="codeline" id="line-1172"><code>		byte(sec),</code></span>
<span class="codeline" id="line-1173"><code>		byte(nsec &gt;&gt; 24), // bytes 9-12: nanoseconds</code></span>
<span class="codeline" id="line-1174"><code>		byte(nsec &gt;&gt; 16),</code></span>
<span class="codeline" id="line-1175"><code>		byte(nsec &gt;&gt; 8),</code></span>
<span class="codeline" id="line-1176"><code>		byte(nsec),</code></span>
<span class="codeline" id="line-1177"><code>		byte(offsetMin &gt;&gt; 8), // bytes 13-14: zone offset in minutes</code></span>
<span class="codeline" id="line-1178"><code>		byte(offsetMin),</code></span>
<span class="codeline" id="line-1179"><code>	}</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>	return enc, nil</code></span>
<span class="codeline" id="line-1182"><code>}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</code></span>
<span class="codeline" id="line-1185"><code>func (t *Time) UnmarshalBinary(data []byte) error {</code></span>
<span class="codeline" id="line-1186"><code>	buf := data</code></span>
<span class="codeline" id="line-1187"><code>	if len(buf) == 0 {</code></span>
<span class="codeline" id="line-1188"><code>		return errors.New("Time.UnmarshalBinary: no data")</code></span>
<span class="codeline" id="line-1189"><code>	}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>	if buf[0] != timeBinaryVersion {</code></span>
<span class="codeline" id="line-1192"><code>		return errors.New("Time.UnmarshalBinary: unsupported version")</code></span>
<span class="codeline" id="line-1193"><code>	}</code></span>
<span class="codeline" id="line-1194"><code></code></span>
<span class="codeline" id="line-1195"><code>	if len(buf) != /*version*/ 1+ /*sec*/ 8+ /*nsec*/ 4+ /*zone offset*/ 2 {</code></span>
<span class="codeline" id="line-1196"><code>		return errors.New("Time.UnmarshalBinary: invalid length")</code></span>
<span class="codeline" id="line-1197"><code>	}</code></span>
<span class="codeline" id="line-1198"><code></code></span>
<span class="codeline" id="line-1199"><code>	buf = buf[1:]</code></span>
<span class="codeline" id="line-1200"><code>	sec := int64(buf[7]) | int64(buf[6])&lt;&lt;8 | int64(buf[5])&lt;&lt;16 | int64(buf[4])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-1201"><code>		int64(buf[3])&lt;&lt;32 | int64(buf[2])&lt;&lt;40 | int64(buf[1])&lt;&lt;48 | int64(buf[0])&lt;&lt;56</code></span>
<span class="codeline" id="line-1202"><code></code></span>
<span class="codeline" id="line-1203"><code>	buf = buf[8:]</code></span>
<span class="codeline" id="line-1204"><code>	nsec := int32(buf[3]) | int32(buf[2])&lt;&lt;8 | int32(buf[1])&lt;&lt;16 | int32(buf[0])&lt;&lt;24</code></span>
<span class="codeline" id="line-1205"><code></code></span>
<span class="codeline" id="line-1206"><code>	buf = buf[4:]</code></span>
<span class="codeline" id="line-1207"><code>	offset := int(int16(buf[1])|int16(buf[0])&lt;&lt;8) * 60</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>	*t = Time{}</code></span>
<span class="codeline" id="line-1210"><code>	t.wall = uint64(nsec)</code></span>
<span class="codeline" id="line-1211"><code>	t.ext = sec</code></span>
<span class="codeline" id="line-1212"><code></code></span>
<span class="codeline" id="line-1213"><code>	if offset == -1*60 {</code></span>
<span class="codeline" id="line-1214"><code>		t.setLoc(&amp;utcLoc)</code></span>
<span class="codeline" id="line-1215"><code>	} else if _, localoff, _, _ := Local.lookup(t.unixSec()); offset == localoff {</code></span>
<span class="codeline" id="line-1216"><code>		t.setLoc(Local)</code></span>
<span class="codeline" id="line-1217"><code>	} else {</code></span>
<span class="codeline" id="line-1218"><code>		t.setLoc(FixedZone("", offset))</code></span>
<span class="codeline" id="line-1219"><code>	}</code></span>
<span class="codeline" id="line-1220"><code></code></span>
<span class="codeline" id="line-1221"><code>	return nil</code></span>
<span class="codeline" id="line-1222"><code>}</code></span>
<span class="codeline" id="line-1223"><code></code></span>
<span class="codeline" id="line-1224"><code>// TODO(rsc): Remove GobEncoder, GobDecoder, MarshalJSON, UnmarshalJSON in Go 2.</code></span>
<span class="codeline" id="line-1225"><code>// The same semantics will be provided by the generic MarshalBinary, MarshalText,</code></span>
<span class="codeline" id="line-1226"><code>// UnmarshalBinary, UnmarshalText.</code></span>
<span class="codeline" id="line-1227"><code></code></span>
<span class="codeline" id="line-1228"><code>// GobEncode implements the gob.GobEncoder interface.</code></span>
<span class="codeline" id="line-1229"><code>func (t Time) GobEncode() ([]byte, error) {</code></span>
<span class="codeline" id="line-1230"><code>	return t.MarshalBinary()</code></span>
<span class="codeline" id="line-1231"><code>}</code></span>
<span class="codeline" id="line-1232"><code></code></span>
<span class="codeline" id="line-1233"><code>// GobDecode implements the gob.GobDecoder interface.</code></span>
<span class="codeline" id="line-1234"><code>func (t *Time) GobDecode(data []byte) error {</code></span>
<span class="codeline" id="line-1235"><code>	return t.UnmarshalBinary(data)</code></span>
<span class="codeline" id="line-1236"><code>}</code></span>
<span class="codeline" id="line-1237"><code></code></span>
<span class="codeline" id="line-1238"><code>// MarshalJSON implements the json.Marshaler interface.</code></span>
<span class="codeline" id="line-1239"><code>// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</code></span>
<span class="codeline" id="line-1240"><code>func (t Time) MarshalJSON() ([]byte, error) {</code></span>
<span class="codeline" id="line-1241"><code>	if y := t.Year(); y &lt; 0 || y &gt;= 10000 {</code></span>
<span class="codeline" id="line-1242"><code>		// RFC 3339 is clear that years are 4 digits exactly.</code></span>
<span class="codeline" id="line-1243"><code>		// See golang.org/issue/4556#c15 for more discussion.</code></span>
<span class="codeline" id="line-1244"><code>		return nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]")</code></span>
<span class="codeline" id="line-1245"><code>	}</code></span>
<span class="codeline" id="line-1246"><code></code></span>
<span class="codeline" id="line-1247"><code>	b := make([]byte, 0, len(RFC3339Nano)+2)</code></span>
<span class="codeline" id="line-1248"><code>	b = append(b, '"')</code></span>
<span class="codeline" id="line-1249"><code>	b = t.AppendFormat(b, RFC3339Nano)</code></span>
<span class="codeline" id="line-1250"><code>	b = append(b, '"')</code></span>
<span class="codeline" id="line-1251"><code>	return b, nil</code></span>
<span class="codeline" id="line-1252"><code>}</code></span>
<span class="codeline" id="line-1253"><code></code></span>
<span class="codeline" id="line-1254"><code>// UnmarshalJSON implements the json.Unmarshaler interface.</code></span>
<span class="codeline" id="line-1255"><code>// The time is expected to be a quoted string in RFC 3339 format.</code></span>
<span class="codeline" id="line-1256"><code>func (t *Time) UnmarshalJSON(data []byte) error {</code></span>
<span class="codeline" id="line-1257"><code>	// Ignore null, like in the main JSON package.</code></span>
<span class="codeline" id="line-1258"><code>	if string(data) == "null" {</code></span>
<span class="codeline" id="line-1259"><code>		return nil</code></span>
<span class="codeline" id="line-1260"><code>	}</code></span>
<span class="codeline" id="line-1261"><code>	// Fractional seconds are handled implicitly by Parse.</code></span>
<span class="codeline" id="line-1262"><code>	var err error</code></span>
<span class="codeline" id="line-1263"><code>	*t, err = Parse(`"`+RFC3339+`"`, string(data))</code></span>
<span class="codeline" id="line-1264"><code>	return err</code></span>
<span class="codeline" id="line-1265"><code>}</code></span>
<span class="codeline" id="line-1266"><code></code></span>
<span class="codeline" id="line-1267"><code>// MarshalText implements the encoding.TextMarshaler interface.</code></span>
<span class="codeline" id="line-1268"><code>// The time is formatted in RFC 3339 format, with sub-second precision added if present.</code></span>
<span class="codeline" id="line-1269"><code>func (t Time) MarshalText() ([]byte, error) {</code></span>
<span class="codeline" id="line-1270"><code>	if y := t.Year(); y &lt; 0 || y &gt;= 10000 {</code></span>
<span class="codeline" id="line-1271"><code>		return nil, errors.New("Time.MarshalText: year outside of range [0,9999]")</code></span>
<span class="codeline" id="line-1272"><code>	}</code></span>
<span class="codeline" id="line-1273"><code></code></span>
<span class="codeline" id="line-1274"><code>	b := make([]byte, 0, len(RFC3339Nano))</code></span>
<span class="codeline" id="line-1275"><code>	return t.AppendFormat(b, RFC3339Nano), nil</code></span>
<span class="codeline" id="line-1276"><code>}</code></span>
<span class="codeline" id="line-1277"><code></code></span>
<span class="codeline" id="line-1278"><code>// UnmarshalText implements the encoding.TextUnmarshaler interface.</code></span>
<span class="codeline" id="line-1279"><code>// The time is expected to be in RFC 3339 format.</code></span>
<span class="codeline" id="line-1280"><code>func (t *Time) UnmarshalText(data []byte) error {</code></span>
<span class="codeline" id="line-1281"><code>	// Fractional seconds are handled implicitly by Parse.</code></span>
<span class="codeline" id="line-1282"><code>	var err error</code></span>
<span class="codeline" id="line-1283"><code>	*t, err = Parse(RFC3339, string(data))</code></span>
<span class="codeline" id="line-1284"><code>	return err</code></span>
<span class="codeline" id="line-1285"><code>}</code></span>
<span class="codeline" id="line-1286"><code></code></span>
<span class="codeline" id="line-1287"><code>// Unix returns the local Time corresponding to the given Unix time,</code></span>
<span class="codeline" id="line-1288"><code>// sec seconds and nsec nanoseconds since January 1, 1970 UTC.</code></span>
<span class="codeline" id="line-1289"><code>// It is valid to pass nsec outside the range [0, 999999999].</code></span>
<span class="codeline" id="line-1290"><code>// Not all sec values have a corresponding time value. One such</code></span>
<span class="codeline" id="line-1291"><code>// value is 1&lt;&lt;63-1 (the largest int64 value).</code></span>
<span class="codeline" id="line-1292"><code>func Unix(sec int64, nsec int64) Time {</code></span>
<span class="codeline" id="line-1293"><code>	if nsec &lt; 0 || nsec &gt;= 1e9 {</code></span>
<span class="codeline" id="line-1294"><code>		n := nsec / 1e9</code></span>
<span class="codeline" id="line-1295"><code>		sec += n</code></span>
<span class="codeline" id="line-1296"><code>		nsec -= n * 1e9</code></span>
<span class="codeline" id="line-1297"><code>		if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-1298"><code>			nsec += 1e9</code></span>
<span class="codeline" id="line-1299"><code>			sec--</code></span>
<span class="codeline" id="line-1300"><code>		}</code></span>
<span class="codeline" id="line-1301"><code>	}</code></span>
<span class="codeline" id="line-1302"><code>	return unixTime(sec, int32(nsec))</code></span>
<span class="codeline" id="line-1303"><code>}</code></span>
<span class="codeline" id="line-1304"><code></code></span>
<span class="codeline" id="line-1305"><code>func isLeap(year int) bool {</code></span>
<span class="codeline" id="line-1306"><code>	return year%4 == 0 &amp;&amp; (year%100 != 0 || year%400 == 0)</code></span>
<span class="codeline" id="line-1307"><code>}</code></span>
<span class="codeline" id="line-1308"><code></code></span>
<span class="codeline" id="line-1309"><code>// norm returns nhi, nlo such that</code></span>
<span class="codeline" id="line-1310"><code>//	hi * base + lo == nhi * base + nlo</code></span>
<span class="codeline" id="line-1311"><code>//	0 &lt;= nlo &lt; base</code></span>
<span class="codeline" id="line-1312"><code>func norm(hi, lo, base int) (nhi, nlo int) {</code></span>
<span class="codeline" id="line-1313"><code>	if lo &lt; 0 {</code></span>
<span class="codeline" id="line-1314"><code>		n := (-lo-1)/base + 1</code></span>
<span class="codeline" id="line-1315"><code>		hi -= n</code></span>
<span class="codeline" id="line-1316"><code>		lo += n * base</code></span>
<span class="codeline" id="line-1317"><code>	}</code></span>
<span class="codeline" id="line-1318"><code>	if lo &gt;= base {</code></span>
<span class="codeline" id="line-1319"><code>		n := lo / base</code></span>
<span class="codeline" id="line-1320"><code>		hi += n</code></span>
<span class="codeline" id="line-1321"><code>		lo -= n * base</code></span>
<span class="codeline" id="line-1322"><code>	}</code></span>
<span class="codeline" id="line-1323"><code>	return hi, lo</code></span>
<span class="codeline" id="line-1324"><code>}</code></span>
<span class="codeline" id="line-1325"><code></code></span>
<span class="codeline" id="line-1326"><code>// Date returns the Time corresponding to</code></span>
<span class="codeline" id="line-1327"><code>//	yyyy-mm-dd hh:mm:ss + nsec nanoseconds</code></span>
<span class="codeline" id="line-1328"><code>// in the appropriate zone for that time in the given location.</code></span>
<span class="codeline" id="line-1329"><code>//</code></span>
<span class="codeline" id="line-1330"><code>// The month, day, hour, min, sec, and nsec values may be outside</code></span>
<span class="codeline" id="line-1331"><code>// their usual ranges and will be normalized during the conversion.</code></span>
<span class="codeline" id="line-1332"><code>// For example, October 32 converts to November 1.</code></span>
<span class="codeline" id="line-1333"><code>//</code></span>
<span class="codeline" id="line-1334"><code>// A daylight savings time transition skips or repeats times.</code></span>
<span class="codeline" id="line-1335"><code>// For example, in the United States, March 13, 2011 2:15am never occurred,</code></span>
<span class="codeline" id="line-1336"><code>// while November 6, 2011 1:15am occurred twice. In such cases, the</code></span>
<span class="codeline" id="line-1337"><code>// choice of time zone, and therefore the time, is not well-defined.</code></span>
<span class="codeline" id="line-1338"><code>// Date returns a time that is correct in one of the two zones involved</code></span>
<span class="codeline" id="line-1339"><code>// in the transition, but it does not guarantee which.</code></span>
<span class="codeline" id="line-1340"><code>//</code></span>
<span class="codeline" id="line-1341"><code>// Date panics if loc is nil.</code></span>
<span class="codeline" id="line-1342"><code>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {</code></span>
<span class="codeline" id="line-1343"><code>	if loc == nil {</code></span>
<span class="codeline" id="line-1344"><code>		panic("time: missing Location in call to Date")</code></span>
<span class="codeline" id="line-1345"><code>	}</code></span>
<span class="codeline" id="line-1346"><code></code></span>
<span class="codeline" id="line-1347"><code>	// Normalize month, overflowing into year.</code></span>
<span class="codeline" id="line-1348"><code>	m := int(month) - 1</code></span>
<span class="codeline" id="line-1349"><code>	year, m = norm(year, m, 12)</code></span>
<span class="codeline" id="line-1350"><code>	month = Month(m) + 1</code></span>
<span class="codeline" id="line-1351"><code></code></span>
<span class="codeline" id="line-1352"><code>	// Normalize nsec, sec, min, hour, overflowing into day.</code></span>
<span class="codeline" id="line-1353"><code>	sec, nsec = norm(sec, nsec, 1e9)</code></span>
<span class="codeline" id="line-1354"><code>	min, sec = norm(min, sec, 60)</code></span>
<span class="codeline" id="line-1355"><code>	hour, min = norm(hour, min, 60)</code></span>
<span class="codeline" id="line-1356"><code>	day, hour = norm(day, hour, 24)</code></span>
<span class="codeline" id="line-1357"><code></code></span>
<span class="codeline" id="line-1358"><code>	// Compute days since the absolute epoch.</code></span>
<span class="codeline" id="line-1359"><code>	d := daysSinceEpoch(year)</code></span>
<span class="codeline" id="line-1360"><code></code></span>
<span class="codeline" id="line-1361"><code>	// Add in days before this month.</code></span>
<span class="codeline" id="line-1362"><code>	d += uint64(daysBefore[month-1])</code></span>
<span class="codeline" id="line-1363"><code>	if isLeap(year) &amp;&amp; month &gt;= March {</code></span>
<span class="codeline" id="line-1364"><code>		d++ // February 29</code></span>
<span class="codeline" id="line-1365"><code>	}</code></span>
<span class="codeline" id="line-1366"><code></code></span>
<span class="codeline" id="line-1367"><code>	// Add in days before today.</code></span>
<span class="codeline" id="line-1368"><code>	d += uint64(day - 1)</code></span>
<span class="codeline" id="line-1369"><code></code></span>
<span class="codeline" id="line-1370"><code>	// Add in time elapsed today.</code></span>
<span class="codeline" id="line-1371"><code>	abs := d * secondsPerDay</code></span>
<span class="codeline" id="line-1372"><code>	abs += uint64(hour*secondsPerHour + min*secondsPerMinute + sec)</code></span>
<span class="codeline" id="line-1373"><code></code></span>
<span class="codeline" id="line-1374"><code>	unix := int64(abs) + (absoluteToInternal + internalToUnix)</code></span>
<span class="codeline" id="line-1375"><code></code></span>
<span class="codeline" id="line-1376"><code>	// Look for zone offset for t, so we can adjust to UTC.</code></span>
<span class="codeline" id="line-1377"><code>	// The lookup function expects UTC, so we pass t in the</code></span>
<span class="codeline" id="line-1378"><code>	// hope that it will not be too close to a zone transition,</code></span>
<span class="codeline" id="line-1379"><code>	// and then adjust if it is.</code></span>
<span class="codeline" id="line-1380"><code>	_, offset, start, end := loc.lookup(unix)</code></span>
<span class="codeline" id="line-1381"><code>	if offset != 0 {</code></span>
<span class="codeline" id="line-1382"><code>		switch utc := unix - int64(offset); {</code></span>
<span class="codeline" id="line-1383"><code>		case utc &lt; start:</code></span>
<span class="codeline" id="line-1384"><code>			_, offset, _, _ = loc.lookup(start - 1)</code></span>
<span class="codeline" id="line-1385"><code>		case utc &gt;= end:</code></span>
<span class="codeline" id="line-1386"><code>			_, offset, _, _ = loc.lookup(end)</code></span>
<span class="codeline" id="line-1387"><code>		}</code></span>
<span class="codeline" id="line-1388"><code>		unix -= int64(offset)</code></span>
<span class="codeline" id="line-1389"><code>	}</code></span>
<span class="codeline" id="line-1390"><code></code></span>
<span class="codeline" id="line-1391"><code>	t := unixTime(unix, int32(nsec))</code></span>
<span class="codeline" id="line-1392"><code>	t.setLoc(loc)</code></span>
<span class="codeline" id="line-1393"><code>	return t</code></span>
<span class="codeline" id="line-1394"><code>}</code></span>
<span class="codeline" id="line-1395"><code></code></span>
<span class="codeline" id="line-1396"><code>// Truncate returns the result of rounding t down to a multiple of d (since the zero time).</code></span>
<span class="codeline" id="line-1397"><code>// If d &lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</code></span>
<span class="codeline" id="line-1398"><code>//</code></span>
<span class="codeline" id="line-1399"><code>// Truncate operates on the time as an absolute duration since the</code></span>
<span class="codeline" id="line-1400"><code>// zero time; it does not operate on the presentation form of the</code></span>
<span class="codeline" id="line-1401"><code>// time. Thus, Truncate(Hour) may return a time with a non-zero</code></span>
<span class="codeline" id="line-1402"><code>// minute, depending on the time's Location.</code></span>
<span class="codeline" id="line-1403"><code>func (t Time) Truncate(d Duration) Time {</code></span>
<span class="codeline" id="line-1404"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-1405"><code>	if d &lt;= 0 {</code></span>
<span class="codeline" id="line-1406"><code>		return t</code></span>
<span class="codeline" id="line-1407"><code>	}</code></span>
<span class="codeline" id="line-1408"><code>	_, r := div(t, d)</code></span>
<span class="codeline" id="line-1409"><code>	return t.Add(-r)</code></span>
<span class="codeline" id="line-1410"><code>}</code></span>
<span class="codeline" id="line-1411"><code></code></span>
<span class="codeline" id="line-1412"><code>// Round returns the result of rounding t to the nearest multiple of d (since the zero time).</code></span>
<span class="codeline" id="line-1413"><code>// The rounding behavior for halfway values is to round up.</code></span>
<span class="codeline" id="line-1414"><code>// If d &lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</code></span>
<span class="codeline" id="line-1415"><code>//</code></span>
<span class="codeline" id="line-1416"><code>// Round operates on the time as an absolute duration since the</code></span>
<span class="codeline" id="line-1417"><code>// zero time; it does not operate on the presentation form of the</code></span>
<span class="codeline" id="line-1418"><code>// time. Thus, Round(Hour) may return a time with a non-zero</code></span>
<span class="codeline" id="line-1419"><code>// minute, depending on the time's Location.</code></span>
<span class="codeline" id="line-1420"><code>func (t Time) Round(d Duration) Time {</code></span>
<span class="codeline" id="line-1421"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-1422"><code>	if d &lt;= 0 {</code></span>
<span class="codeline" id="line-1423"><code>		return t</code></span>
<span class="codeline" id="line-1424"><code>	}</code></span>
<span class="codeline" id="line-1425"><code>	_, r := div(t, d)</code></span>
<span class="codeline" id="line-1426"><code>	if lessThanHalf(r, d) {</code></span>
<span class="codeline" id="line-1427"><code>		return t.Add(-r)</code></span>
<span class="codeline" id="line-1428"><code>	}</code></span>
<span class="codeline" id="line-1429"><code>	return t.Add(d - r)</code></span>
<span class="codeline" id="line-1430"><code>}</code></span>
<span class="codeline" id="line-1431"><code></code></span>
<span class="codeline" id="line-1432"><code>// div divides t by d and returns the quotient parity and remainder.</code></span>
<span class="codeline" id="line-1433"><code>// We don't use the quotient parity anymore (round half up instead of round to even)</code></span>
<span class="codeline" id="line-1434"><code>// but it's still here in case we change our minds.</code></span>
<span class="codeline" id="line-1435"><code>func div(t Time, d Duration) (qmod2 int, r Duration) {</code></span>
<span class="codeline" id="line-1436"><code>	neg := false</code></span>
<span class="codeline" id="line-1437"><code>	nsec := t.nsec()</code></span>
<span class="codeline" id="line-1438"><code>	sec := t.sec()</code></span>
<span class="codeline" id="line-1439"><code>	if sec &lt; 0 {</code></span>
<span class="codeline" id="line-1440"><code>		// Operate on absolute value.</code></span>
<span class="codeline" id="line-1441"><code>		neg = true</code></span>
<span class="codeline" id="line-1442"><code>		sec = -sec</code></span>
<span class="codeline" id="line-1443"><code>		nsec = -nsec</code></span>
<span class="codeline" id="line-1444"><code>		if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-1445"><code>			nsec += 1e9</code></span>
<span class="codeline" id="line-1446"><code>			sec-- // sec &gt;= 1 before the -- so safe</code></span>
<span class="codeline" id="line-1447"><code>		}</code></span>
<span class="codeline" id="line-1448"><code>	}</code></span>
<span class="codeline" id="line-1449"><code></code></span>
<span class="codeline" id="line-1450"><code>	switch {</code></span>
<span class="codeline" id="line-1451"><code>	// Special case: 2d divides 1 second.</code></span>
<span class="codeline" id="line-1452"><code>	case d &lt; Second &amp;&amp; Second%(d+d) == 0:</code></span>
<span class="codeline" id="line-1453"><code>		qmod2 = int(nsec/int32(d)) &amp; 1</code></span>
<span class="codeline" id="line-1454"><code>		r = Duration(nsec % int32(d))</code></span>
<span class="codeline" id="line-1455"><code></code></span>
<span class="codeline" id="line-1456"><code>	// Special case: d is a multiple of 1 second.</code></span>
<span class="codeline" id="line-1457"><code>	case d%Second == 0:</code></span>
<span class="codeline" id="line-1458"><code>		d1 := int64(d / Second)</code></span>
<span class="codeline" id="line-1459"><code>		qmod2 = int(sec/d1) &amp; 1</code></span>
<span class="codeline" id="line-1460"><code>		r = Duration(sec%d1)*Second + Duration(nsec)</code></span>
<span class="codeline" id="line-1461"><code></code></span>
<span class="codeline" id="line-1462"><code>	// General case.</code></span>
<span class="codeline" id="line-1463"><code>	// This could be faster if more cleverness were applied,</code></span>
<span class="codeline" id="line-1464"><code>	// but it's really only here to avoid special case restrictions in the API.</code></span>
<span class="codeline" id="line-1465"><code>	// No one will care about these cases.</code></span>
<span class="codeline" id="line-1466"><code>	default:</code></span>
<span class="codeline" id="line-1467"><code>		// Compute nanoseconds as 128-bit number.</code></span>
<span class="codeline" id="line-1468"><code>		sec := uint64(sec)</code></span>
<span class="codeline" id="line-1469"><code>		tmp := (sec &gt;&gt; 32) * 1e9</code></span>
<span class="codeline" id="line-1470"><code>		u1 := tmp &gt;&gt; 32</code></span>
<span class="codeline" id="line-1471"><code>		u0 := tmp &lt;&lt; 32</code></span>
<span class="codeline" id="line-1472"><code>		tmp = (sec &amp; 0xFFFFFFFF) * 1e9</code></span>
<span class="codeline" id="line-1473"><code>		u0x, u0 := u0, u0+tmp</code></span>
<span class="codeline" id="line-1474"><code>		if u0 &lt; u0x {</code></span>
<span class="codeline" id="line-1475"><code>			u1++</code></span>
<span class="codeline" id="line-1476"><code>		}</code></span>
<span class="codeline" id="line-1477"><code>		u0x, u0 = u0, u0+uint64(nsec)</code></span>
<span class="codeline" id="line-1478"><code>		if u0 &lt; u0x {</code></span>
<span class="codeline" id="line-1479"><code>			u1++</code></span>
<span class="codeline" id="line-1480"><code>		}</code></span>
<span class="codeline" id="line-1481"><code></code></span>
<span class="codeline" id="line-1482"><code>		// Compute remainder by subtracting r&lt;&lt;k for decreasing k.</code></span>
<span class="codeline" id="line-1483"><code>		// Quotient parity is whether we subtract on last round.</code></span>
<span class="codeline" id="line-1484"><code>		d1 := uint64(d)</code></span>
<span class="codeline" id="line-1485"><code>		for d1&gt;&gt;63 != 1 {</code></span>
<span class="codeline" id="line-1486"><code>			d1 &lt;&lt;= 1</code></span>
<span class="codeline" id="line-1487"><code>		}</code></span>
<span class="codeline" id="line-1488"><code>		d0 := uint64(0)</code></span>
<span class="codeline" id="line-1489"><code>		for {</code></span>
<span class="codeline" id="line-1490"><code>			qmod2 = 0</code></span>
<span class="codeline" id="line-1491"><code>			if u1 &gt; d1 || u1 == d1 &amp;&amp; u0 &gt;= d0 {</code></span>
<span class="codeline" id="line-1492"><code>				// subtract</code></span>
<span class="codeline" id="line-1493"><code>				qmod2 = 1</code></span>
<span class="codeline" id="line-1494"><code>				u0x, u0 = u0, u0-d0</code></span>
<span class="codeline" id="line-1495"><code>				if u0 &gt; u0x {</code></span>
<span class="codeline" id="line-1496"><code>					u1--</code></span>
<span class="codeline" id="line-1497"><code>				}</code></span>
<span class="codeline" id="line-1498"><code>				u1 -= d1</code></span>
<span class="codeline" id="line-1499"><code>			}</code></span>
<span class="codeline" id="line-1500"><code>			if d1 == 0 &amp;&amp; d0 == uint64(d) {</code></span>
<span class="codeline" id="line-1501"><code>				break</code></span>
<span class="codeline" id="line-1502"><code>			}</code></span>
<span class="codeline" id="line-1503"><code>			d0 &gt;&gt;= 1</code></span>
<span class="codeline" id="line-1504"><code>			d0 |= (d1 &amp; 1) &lt;&lt; 63</code></span>
<span class="codeline" id="line-1505"><code>			d1 &gt;&gt;= 1</code></span>
<span class="codeline" id="line-1506"><code>		}</code></span>
<span class="codeline" id="line-1507"><code>		r = Duration(u0)</code></span>
<span class="codeline" id="line-1508"><code>	}</code></span>
<span class="codeline" id="line-1509"><code></code></span>
<span class="codeline" id="line-1510"><code>	if neg &amp;&amp; r != 0 {</code></span>
<span class="codeline" id="line-1511"><code>		// If input was negative and not an exact multiple of d, we computed q, r such that</code></span>
<span class="codeline" id="line-1512"><code>		//	q*d + r = -t</code></span>
<span class="codeline" id="line-1513"><code>		// But the right answers are given by -(q-1), d-r:</code></span>
<span class="codeline" id="line-1514"><code>		//	q*d + r = -t</code></span>
<span class="codeline" id="line-1515"><code>		//	-q*d - r = t</code></span>
<span class="codeline" id="line-1516"><code>		//	-(q-1)*d + (d - r) = t</code></span>
<span class="codeline" id="line-1517"><code>		qmod2 ^= 1</code></span>
<span class="codeline" id="line-1518"><code>		r = d - r</code></span>
<span class="codeline" id="line-1519"><code>	}</code></span>
<span class="codeline" id="line-1520"><code>	return</code></span>
<span class="codeline" id="line-1521"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>