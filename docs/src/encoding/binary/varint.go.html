<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: varint.go in package encoding/binary</title>
<link href="../../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	varint.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/binary.html">encoding/binary</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package binary</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// This file implements "varint" encoding of 64-bit integers.</code></span>
<span class="codeline" id="line-8"><code>// The encoding is:</code></span>
<span class="codeline" id="line-9"><code>// - unsigned integers are serialized 7 bits at a time, starting with the</code></span>
<span class="codeline" id="line-10"><code>//   least significant bits</code></span>
<span class="codeline" id="line-11"><code>// - the most significant bit (msb) in each output byte indicates if there</code></span>
<span class="codeline" id="line-12"><code>//   is a continuation byte (msb = 1)</code></span>
<span class="codeline" id="line-13"><code>// - signed integers are mapped to unsigned integers using "zig-zag"</code></span>
<span class="codeline" id="line-14"><code>//   encoding: Positive values x are written as 2*x + 0, negative values</code></span>
<span class="codeline" id="line-15"><code>//   are written as 2*(^x) + 1; that is, negative numbers are complemented</code></span>
<span class="codeline" id="line-16"><code>//   and whether to complement is encoded in bit 0.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// Design note:</code></span>
<span class="codeline" id="line-19"><code>// At most 10 bytes are needed for 64-bit values. The encoding could</code></span>
<span class="codeline" id="line-20"><code>// be more dense: a full 64-bit value needs an extra byte just to hold bit 63.</code></span>
<span class="codeline" id="line-21"><code>// Instead, the msb of the previous byte could be used to hold bit 63 since we</code></span>
<span class="codeline" id="line-22"><code>// know there can't be more than 64 bits. This is a trivial improvement and</code></span>
<span class="codeline" id="line-23"><code>// would reduce the maximum encoding length to 9 bytes. However, it breaks the</code></span>
<span class="codeline" id="line-24"><code>// invariant that the msb is always the "continuation bit" and thus makes the</code></span>
<span class="codeline" id="line-25"><code>// format incompatible with a varint encoding for larger numbers (say 128-bit).</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>import (</code></span>
<span class="codeline" id="line-28"><code>	"errors"</code></span>
<span class="codeline" id="line-29"><code>	"io"</code></span>
<span class="codeline" id="line-30"><code>)</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.</code></span>
<span class="codeline" id="line-33"><code>const (</code></span>
<span class="codeline" id="line-34"><code>	MaxVarintLen16 = 3</code></span>
<span class="codeline" id="line-35"><code>	MaxVarintLen32 = 5</code></span>
<span class="codeline" id="line-36"><code>	MaxVarintLen64 = 10</code></span>
<span class="codeline" id="line-37"><code>)</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// PutUvarint encodes a uint64 into buf and returns the number of bytes written.</code></span>
<span class="codeline" id="line-40"><code>// If the buffer is too small, PutUvarint will panic.</code></span>
<span class="codeline" id="line-41"><code>func PutUvarint(buf []byte, x uint64) int {</code></span>
<span class="codeline" id="line-42"><code>	i := 0</code></span>
<span class="codeline" id="line-43"><code>	for x &gt;= 0x80 {</code></span>
<span class="codeline" id="line-44"><code>		buf[i] = byte(x) | 0x80</code></span>
<span class="codeline" id="line-45"><code>		x &gt;&gt;= 7</code></span>
<span class="codeline" id="line-46"><code>		i++</code></span>
<span class="codeline" id="line-47"><code>	}</code></span>
<span class="codeline" id="line-48"><code>	buf[i] = byte(x)</code></span>
<span class="codeline" id="line-49"><code>	return i + 1</code></span>
<span class="codeline" id="line-50"><code>}</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>// Uvarint decodes a uint64 from buf and returns that value and the</code></span>
<span class="codeline" id="line-53"><code>// number of bytes read (&gt; 0). If an error occurred, the value is 0</code></span>
<span class="codeline" id="line-54"><code>// and the number of bytes n is &lt;= 0 meaning:</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>// 	n == 0: buf too small</code></span>
<span class="codeline" id="line-57"><code>// 	n  &lt; 0: value larger than 64 bits (overflow)</code></span>
<span class="codeline" id="line-58"><code>// 	        and -n is the number of bytes read</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>func Uvarint(buf []byte) (uint64, int) {</code></span>
<span class="codeline" id="line-61"><code>	var x uint64</code></span>
<span class="codeline" id="line-62"><code>	var s uint</code></span>
<span class="codeline" id="line-63"><code>	for i, b := range buf {</code></span>
<span class="codeline" id="line-64"><code>		if b &lt; 0x80 {</code></span>
<span class="codeline" id="line-65"><code>			if i &gt;= MaxVarintLen64 || i == MaxVarintLen64-1 &amp;&amp; b &gt; 1 {</code></span>
<span class="codeline" id="line-66"><code>				return 0, -(i + 1) // overflow</code></span>
<span class="codeline" id="line-67"><code>			}</code></span>
<span class="codeline" id="line-68"><code>			return x | uint64(b)&lt;&lt;s, i + 1</code></span>
<span class="codeline" id="line-69"><code>		}</code></span>
<span class="codeline" id="line-70"><code>		x |= uint64(b&amp;0x7f) &lt;&lt; s</code></span>
<span class="codeline" id="line-71"><code>		s += 7</code></span>
<span class="codeline" id="line-72"><code>	}</code></span>
<span class="codeline" id="line-73"><code>	return 0, 0</code></span>
<span class="codeline" id="line-74"><code>}</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>// PutVarint encodes an int64 into buf and returns the number of bytes written.</code></span>
<span class="codeline" id="line-77"><code>// If the buffer is too small, PutVarint will panic.</code></span>
<span class="codeline" id="line-78"><code>func PutVarint(buf []byte, x int64) int {</code></span>
<span class="codeline" id="line-79"><code>	ux := uint64(x) &lt;&lt; 1</code></span>
<span class="codeline" id="line-80"><code>	if x &lt; 0 {</code></span>
<span class="codeline" id="line-81"><code>		ux = ^ux</code></span>
<span class="codeline" id="line-82"><code>	}</code></span>
<span class="codeline" id="line-83"><code>	return PutUvarint(buf, ux)</code></span>
<span class="codeline" id="line-84"><code>}</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>// Varint decodes an int64 from buf and returns that value and the</code></span>
<span class="codeline" id="line-87"><code>// number of bytes read (&gt; 0). If an error occurred, the value is 0</code></span>
<span class="codeline" id="line-88"><code>// and the number of bytes n is &lt;= 0 with the following meaning:</code></span>
<span class="codeline" id="line-89"><code>//</code></span>
<span class="codeline" id="line-90"><code>// 	n == 0: buf too small</code></span>
<span class="codeline" id="line-91"><code>// 	n  &lt; 0: value larger than 64 bits (overflow)</code></span>
<span class="codeline" id="line-92"><code>// 	        and -n is the number of bytes read</code></span>
<span class="codeline" id="line-93"><code>//</code></span>
<span class="codeline" id="line-94"><code>func Varint(buf []byte) (int64, int) {</code></span>
<span class="codeline" id="line-95"><code>	ux, n := Uvarint(buf) // ok to continue in presence of error</code></span>
<span class="codeline" id="line-96"><code>	x := int64(ux &gt;&gt; 1)</code></span>
<span class="codeline" id="line-97"><code>	if ux&amp;1 != 0 {</code></span>
<span class="codeline" id="line-98"><code>		x = ^x</code></span>
<span class="codeline" id="line-99"><code>	}</code></span>
<span class="codeline" id="line-100"><code>	return x, n</code></span>
<span class="codeline" id="line-101"><code>}</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>var overflow = errors.New("binary: varint overflows a 64-bit integer")</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>// ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</code></span>
<span class="codeline" id="line-106"><code>func ReadUvarint(r io.ByteReader) (uint64, error) {</code></span>
<span class="codeline" id="line-107"><code>	var x uint64</code></span>
<span class="codeline" id="line-108"><code>	var s uint</code></span>
<span class="codeline" id="line-109"><code>	for i := 0; i &lt; MaxVarintLen64; i++ {</code></span>
<span class="codeline" id="line-110"><code>		b, err := r.ReadByte()</code></span>
<span class="codeline" id="line-111"><code>		if err != nil {</code></span>
<span class="codeline" id="line-112"><code>			return x, err</code></span>
<span class="codeline" id="line-113"><code>		}</code></span>
<span class="codeline" id="line-114"><code>		if b &lt; 0x80 {</code></span>
<span class="codeline" id="line-115"><code>			if i == MaxVarintLen64-1 &amp;&amp; b &gt; 1 {</code></span>
<span class="codeline" id="line-116"><code>				return x, overflow</code></span>
<span class="codeline" id="line-117"><code>			}</code></span>
<span class="codeline" id="line-118"><code>			return x | uint64(b)&lt;&lt;s, nil</code></span>
<span class="codeline" id="line-119"><code>		}</code></span>
<span class="codeline" id="line-120"><code>		x |= uint64(b&amp;0x7f) &lt;&lt; s</code></span>
<span class="codeline" id="line-121"><code>		s += 7</code></span>
<span class="codeline" id="line-122"><code>	}</code></span>
<span class="codeline" id="line-123"><code>	return x, overflow</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>// ReadVarint reads an encoded signed integer from r and returns it as an int64.</code></span>
<span class="codeline" id="line-127"><code>func ReadVarint(r io.ByteReader) (int64, error) {</code></span>
<span class="codeline" id="line-128"><code>	ux, err := ReadUvarint(r) // ok to continue in presence of error</code></span>
<span class="codeline" id="line-129"><code>	x := int64(ux &gt;&gt; 1)</code></span>
<span class="codeline" id="line-130"><code>	if ux&amp;1 != 0 {</code></span>
<span class="codeline" id="line-131"><code>		x = ^x</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	return x, err</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>