<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: encode.go in package encoding/json</title>
<link href="../../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	encode.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/json.html">encoding/json</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2010 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package json implements encoding and decoding of JSON as defined in</code></span>
<span class="codeline" id="line-6"><code>// RFC 7159. The mapping between JSON and Go values is described</code></span>
<span class="codeline" id="line-7"><code>// in the documentation for the Marshal and Unmarshal functions.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// See "JSON and Go" for an introduction to this package:</code></span>
<span class="codeline" id="line-10"><code>// https://golang.org/doc/articles/json_and_go.html</code></span></div><span class="codeline" id="line-11"><code>package json</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>import (</code></span>
<span class="codeline" id="line-14"><code>	"bytes"</code></span>
<span class="codeline" id="line-15"><code>	"encoding"</code></span>
<span class="codeline" id="line-16"><code>	"encoding/base64"</code></span>
<span class="codeline" id="line-17"><code>	"fmt"</code></span>
<span class="codeline" id="line-18"><code>	"math"</code></span>
<span class="codeline" id="line-19"><code>	"reflect"</code></span>
<span class="codeline" id="line-20"><code>	"sort"</code></span>
<span class="codeline" id="line-21"><code>	"strconv"</code></span>
<span class="codeline" id="line-22"><code>	"strings"</code></span>
<span class="codeline" id="line-23"><code>	"sync"</code></span>
<span class="codeline" id="line-24"><code>	"unicode"</code></span>
<span class="codeline" id="line-25"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-26"><code>)</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>// Marshal returns the JSON encoding of v.</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// Marshal traverses the value v recursively.</code></span>
<span class="codeline" id="line-31"><code>// If an encountered value implements the Marshaler interface</code></span>
<span class="codeline" id="line-32"><code>// and is not a nil pointer, Marshal calls its MarshalJSON method</code></span>
<span class="codeline" id="line-33"><code>// to produce JSON. If no MarshalJSON method is present but the</code></span>
<span class="codeline" id="line-34"><code>// value implements encoding.TextMarshaler instead, Marshal calls</code></span>
<span class="codeline" id="line-35"><code>// its MarshalText method and encodes the result as a JSON string.</code></span>
<span class="codeline" id="line-36"><code>// The nil pointer exception is not strictly necessary</code></span>
<span class="codeline" id="line-37"><code>// but mimics a similar, necessary exception in the behavior of</code></span>
<span class="codeline" id="line-38"><code>// UnmarshalJSON.</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// Otherwise, Marshal uses the following type-dependent default encodings:</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// Boolean values encode as JSON booleans.</code></span>
<span class="codeline" id="line-43"><code>//</code></span>
<span class="codeline" id="line-44"><code>// Floating point, integer, and Number values encode as JSON numbers.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>// String values encode as JSON strings coerced to valid UTF-8,</code></span>
<span class="codeline" id="line-47"><code>// replacing invalid bytes with the Unicode replacement rune.</code></span>
<span class="codeline" id="line-48"><code>// So that the JSON will be safe to embed inside HTML &lt;script&gt; tags,</code></span>
<span class="codeline" id="line-49"><code>// the string is encoded using HTMLEscape,</code></span>
<span class="codeline" id="line-50"><code>// which replaces "&lt;", "&gt;", "&amp;", U+2028, and U+2029 are escaped</code></span>
<span class="codeline" id="line-51"><code>// to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".</code></span>
<span class="codeline" id="line-52"><code>// This replacement can be disabled when using an Encoder,</code></span>
<span class="codeline" id="line-53"><code>// by calling SetEscapeHTML(false).</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// Array and slice values encode as JSON arrays, except that</code></span>
<span class="codeline" id="line-56"><code>// []byte encodes as a base64-encoded string, and a nil slice</code></span>
<span class="codeline" id="line-57"><code>// encodes as the null JSON value.</code></span>
<span class="codeline" id="line-58"><code>//</code></span>
<span class="codeline" id="line-59"><code>// Struct values encode as JSON objects.</code></span>
<span class="codeline" id="line-60"><code>// Each exported struct field becomes a member of the object, using the</code></span>
<span class="codeline" id="line-61"><code>// field name as the object key, unless the field is omitted for one of the</code></span>
<span class="codeline" id="line-62"><code>// reasons given below.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// The encoding of each struct field can be customized by the format string</code></span>
<span class="codeline" id="line-65"><code>// stored under the "json" key in the struct field's tag.</code></span>
<span class="codeline" id="line-66"><code>// The format string gives the name of the field, possibly followed by a</code></span>
<span class="codeline" id="line-67"><code>// comma-separated list of options. The name may be empty in order to</code></span>
<span class="codeline" id="line-68"><code>// specify options without overriding the default field name.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// The "omitempty" option specifies that the field should be omitted</code></span>
<span class="codeline" id="line-71"><code>// from the encoding if the field has an empty value, defined as</code></span>
<span class="codeline" id="line-72"><code>// false, 0, a nil pointer, a nil interface value, and any empty array,</code></span>
<span class="codeline" id="line-73"><code>// slice, map, or string.</code></span>
<span class="codeline" id="line-74"><code>//</code></span>
<span class="codeline" id="line-75"><code>// As a special case, if the field tag is "-", the field is always omitted.</code></span>
<span class="codeline" id="line-76"><code>// Note that a field with name "-" can still be generated using the tag "-,".</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>// Examples of struct field tags and their meanings:</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>//   // Field appears in JSON as key "myName".</code></span>
<span class="codeline" id="line-81"><code>//   Field int `json:"myName"`</code></span>
<span class="codeline" id="line-82"><code>//</code></span>
<span class="codeline" id="line-83"><code>//   // Field appears in JSON as key "myName" and</code></span>
<span class="codeline" id="line-84"><code>//   // the field is omitted from the object if its value is empty,</code></span>
<span class="codeline" id="line-85"><code>//   // as defined above.</code></span>
<span class="codeline" id="line-86"><code>//   Field int `json:"myName,omitempty"`</code></span>
<span class="codeline" id="line-87"><code>//</code></span>
<span class="codeline" id="line-88"><code>//   // Field appears in JSON as key "Field" (the default), but</code></span>
<span class="codeline" id="line-89"><code>//   // the field is skipped if empty.</code></span>
<span class="codeline" id="line-90"><code>//   // Note the leading comma.</code></span>
<span class="codeline" id="line-91"><code>//   Field int `json:",omitempty"`</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>//   // Field is ignored by this package.</code></span>
<span class="codeline" id="line-94"><code>//   Field int `json:"-"`</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>//   // Field appears in JSON as key "-".</code></span>
<span class="codeline" id="line-97"><code>//   Field int `json:"-,"`</code></span>
<span class="codeline" id="line-98"><code>//</code></span>
<span class="codeline" id="line-99"><code>// The "string" option signals that a field is stored as JSON inside a</code></span>
<span class="codeline" id="line-100"><code>// JSON-encoded string. It applies only to fields of string, floating point,</code></span>
<span class="codeline" id="line-101"><code>// integer, or boolean types. This extra level of encoding is sometimes used</code></span>
<span class="codeline" id="line-102"><code>// when communicating with JavaScript programs:</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>//    Int64String int64 `json:",string"`</code></span>
<span class="codeline" id="line-105"><code>//</code></span>
<span class="codeline" id="line-106"><code>// The key name will be used if it's a non-empty string consisting of</code></span>
<span class="codeline" id="line-107"><code>// only Unicode letters, digits, and ASCII punctuation except quotation</code></span>
<span class="codeline" id="line-108"><code>// marks, backslash, and comma.</code></span>
<span class="codeline" id="line-109"><code>//</code></span>
<span class="codeline" id="line-110"><code>// Anonymous struct fields are usually marshaled as if their inner exported fields</code></span>
<span class="codeline" id="line-111"><code>// were fields in the outer struct, subject to the usual Go visibility rules amended</code></span>
<span class="codeline" id="line-112"><code>// as described in the next paragraph.</code></span>
<span class="codeline" id="line-113"><code>// An anonymous struct field with a name given in its JSON tag is treated as</code></span>
<span class="codeline" id="line-114"><code>// having that name, rather than being anonymous.</code></span>
<span class="codeline" id="line-115"><code>// An anonymous struct field of interface type is treated the same as having</code></span>
<span class="codeline" id="line-116"><code>// that type as its name, rather than being anonymous.</code></span>
<span class="codeline" id="line-117"><code>//</code></span>
<span class="codeline" id="line-118"><code>// The Go visibility rules for struct fields are amended for JSON when</code></span>
<span class="codeline" id="line-119"><code>// deciding which field to marshal or unmarshal. If there are</code></span>
<span class="codeline" id="line-120"><code>// multiple fields at the same level, and that level is the least</code></span>
<span class="codeline" id="line-121"><code>// nested (and would therefore be the nesting level selected by the</code></span>
<span class="codeline" id="line-122"><code>// usual Go rules), the following extra rules apply:</code></span>
<span class="codeline" id="line-123"><code>//</code></span>
<span class="codeline" id="line-124"><code>// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,</code></span>
<span class="codeline" id="line-125"><code>// even if there are multiple untagged fields that would otherwise conflict.</code></span>
<span class="codeline" id="line-126"><code>//</code></span>
<span class="codeline" id="line-127"><code>// 2) If there is exactly one field (tagged or not according to the first rule), that is selected.</code></span>
<span class="codeline" id="line-128"><code>//</code></span>
<span class="codeline" id="line-129"><code>// 3) Otherwise there are multiple fields, and all are ignored; no error occurs.</code></span>
<span class="codeline" id="line-130"><code>//</code></span>
<span class="codeline" id="line-131"><code>// Handling of anonymous struct fields is new in Go 1.1.</code></span>
<span class="codeline" id="line-132"><code>// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of</code></span>
<span class="codeline" id="line-133"><code>// an anonymous struct field in both current and earlier versions, give the field</code></span>
<span class="codeline" id="line-134"><code>// a JSON tag of "-".</code></span>
<span class="codeline" id="line-135"><code>//</code></span>
<span class="codeline" id="line-136"><code>// Map values encode as JSON objects. The map's key type must either be a</code></span>
<span class="codeline" id="line-137"><code>// string, an integer type, or implement encoding.TextMarshaler. The map keys</code></span>
<span class="codeline" id="line-138"><code>// are sorted and used as JSON object keys by applying the following rules,</code></span>
<span class="codeline" id="line-139"><code>// subject to the UTF-8 coercion described for string values above:</code></span>
<span class="codeline" id="line-140"><code>//   - keys of any string type are used directly</code></span>
<span class="codeline" id="line-141"><code>//   - encoding.TextMarshalers are marshaled</code></span>
<span class="codeline" id="line-142"><code>//   - integer keys are converted to strings</code></span>
<span class="codeline" id="line-143"><code>//</code></span>
<span class="codeline" id="line-144"><code>// Pointer values encode as the value pointed to.</code></span>
<span class="codeline" id="line-145"><code>// A nil pointer encodes as the null JSON value.</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// Interface values encode as the value contained in the interface.</code></span>
<span class="codeline" id="line-148"><code>// A nil interface value encodes as the null JSON value.</code></span>
<span class="codeline" id="line-149"><code>//</code></span>
<span class="codeline" id="line-150"><code>// Channel, complex, and function values cannot be encoded in JSON.</code></span>
<span class="codeline" id="line-151"><code>// Attempting to encode such a value causes Marshal to return</code></span>
<span class="codeline" id="line-152"><code>// an UnsupportedTypeError.</code></span>
<span class="codeline" id="line-153"><code>//</code></span>
<span class="codeline" id="line-154"><code>// JSON cannot represent cyclic data structures and Marshal does not</code></span>
<span class="codeline" id="line-155"><code>// handle them. Passing cyclic structures to Marshal will result in</code></span>
<span class="codeline" id="line-156"><code>// an error.</code></span>
<span class="codeline" id="line-157"><code>//</code></span>
<span class="codeline" id="line-158"><code>func Marshal(v interface{}) ([]byte, error) {</code></span>
<span class="codeline" id="line-159"><code>	e := newEncodeState()</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	err := e.marshal(v, encOpts{escapeHTML: true})</code></span>
<span class="codeline" id="line-162"><code>	if err != nil {</code></span>
<span class="codeline" id="line-163"><code>		return nil, err</code></span>
<span class="codeline" id="line-164"><code>	}</code></span>
<span class="codeline" id="line-165"><code>	buf := append([]byte(nil), e.Bytes()...)</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	encodeStatePool.Put(e)</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	return buf, nil</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// MarshalIndent is like Marshal but applies Indent to format the output.</code></span>
<span class="codeline" id="line-173"><code>// Each JSON element in the output will begin on a new line beginning with prefix</code></span>
<span class="codeline" id="line-174"><code>// followed by one or more copies of indent according to the indentation nesting.</code></span>
<span class="codeline" id="line-175"><code>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {</code></span>
<span class="codeline" id="line-176"><code>	b, err := Marshal(v)</code></span>
<span class="codeline" id="line-177"><code>	if err != nil {</code></span>
<span class="codeline" id="line-178"><code>		return nil, err</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-181"><code>	err = Indent(&amp;buf, b, prefix, indent)</code></span>
<span class="codeline" id="line-182"><code>	if err != nil {</code></span>
<span class="codeline" id="line-183"><code>		return nil, err</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>	return buf.Bytes(), nil</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// HTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, &amp;, U+2028 and U+2029</code></span>
<span class="codeline" id="line-189"><code>// characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029</code></span>
<span class="codeline" id="line-190"><code>// so that the JSON will be safe to embed inside HTML &lt;script&gt; tags.</code></span>
<span class="codeline" id="line-191"><code>// For historical reasons, web browsers don't honor standard HTML</code></span>
<span class="codeline" id="line-192"><code>// escaping within &lt;script&gt; tags, so an alternative JSON encoding must</code></span>
<span class="codeline" id="line-193"><code>// be used.</code></span>
<span class="codeline" id="line-194"><code>func HTMLEscape(dst *bytes.Buffer, src []byte) {</code></span>
<span class="codeline" id="line-195"><code>	// The characters can only appear in string literals,</code></span>
<span class="codeline" id="line-196"><code>	// so just scan the string one byte at a time.</code></span>
<span class="codeline" id="line-197"><code>	start := 0</code></span>
<span class="codeline" id="line-198"><code>	for i, c := range src {</code></span>
<span class="codeline" id="line-199"><code>		if c == '&lt;' || c == '&gt;' || c == '&amp;' {</code></span>
<span class="codeline" id="line-200"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-201"><code>				dst.Write(src[start:i])</code></span>
<span class="codeline" id="line-202"><code>			}</code></span>
<span class="codeline" id="line-203"><code>			dst.WriteString(`\u00`)</code></span>
<span class="codeline" id="line-204"><code>			dst.WriteByte(hex[c&gt;&gt;4])</code></span>
<span class="codeline" id="line-205"><code>			dst.WriteByte(hex[c&amp;0xF])</code></span>
<span class="codeline" id="line-206"><code>			start = i + 1</code></span>
<span class="codeline" id="line-207"><code>		}</code></span>
<span class="codeline" id="line-208"><code>		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).</code></span>
<span class="codeline" id="line-209"><code>		if c == 0xE2 &amp;&amp; i+2 &lt; len(src) &amp;&amp; src[i+1] == 0x80 &amp;&amp; src[i+2]&amp;^1 == 0xA8 {</code></span>
<span class="codeline" id="line-210"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-211"><code>				dst.Write(src[start:i])</code></span>
<span class="codeline" id="line-212"><code>			}</code></span>
<span class="codeline" id="line-213"><code>			dst.WriteString(`\u202`)</code></span>
<span class="codeline" id="line-214"><code>			dst.WriteByte(hex[src[i+2]&amp;0xF])</code></span>
<span class="codeline" id="line-215"><code>			start = i + 3</code></span>
<span class="codeline" id="line-216"><code>		}</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	if start &lt; len(src) {</code></span>
<span class="codeline" id="line-219"><code>		dst.Write(src[start:])</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code>}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>// Marshaler is the interface implemented by types that</code></span>
<span class="codeline" id="line-224"><code>// can marshal themselves into valid JSON.</code></span>
<span class="codeline" id="line-225"><code>type Marshaler interface {</code></span>
<span class="codeline" id="line-226"><code>	MarshalJSON() ([]byte, error)</code></span>
<span class="codeline" id="line-227"><code>}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>// An UnsupportedTypeError is returned by Marshal when attempting</code></span>
<span class="codeline" id="line-230"><code>// to encode an unsupported value type.</code></span>
<span class="codeline" id="line-231"><code>type UnsupportedTypeError struct {</code></span>
<span class="codeline" id="line-232"><code>	Type reflect.Type</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>func (e *UnsupportedTypeError) Error() string {</code></span>
<span class="codeline" id="line-236"><code>	return "json: unsupported type: " + e.Type.String()</code></span>
<span class="codeline" id="line-237"><code>}</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>// An UnsupportedValueError is returned by Marshal when attempting</code></span>
<span class="codeline" id="line-240"><code>// to encode an unsupported value.</code></span>
<span class="codeline" id="line-241"><code>type UnsupportedValueError struct {</code></span>
<span class="codeline" id="line-242"><code>	Value reflect.Value</code></span>
<span class="codeline" id="line-243"><code>	Str   string</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>func (e *UnsupportedValueError) Error() string {</code></span>
<span class="codeline" id="line-247"><code>	return "json: unsupported value: " + e.Str</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when</code></span>
<span class="codeline" id="line-251"><code>// attempting to encode a string value with invalid UTF-8 sequences.</code></span>
<span class="codeline" id="line-252"><code>// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by</code></span>
<span class="codeline" id="line-253"><code>// replacing invalid bytes with the Unicode replacement rune U+FFFD.</code></span>
<span class="codeline" id="line-254"><code>//</code></span>
<span class="codeline" id="line-255"><code>// Deprecated: No longer used; kept for compatibility.</code></span>
<span class="codeline" id="line-256"><code>type InvalidUTF8Error struct {</code></span>
<span class="codeline" id="line-257"><code>	S string // the whole string value that caused the error</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>func (e *InvalidUTF8Error) Error() string {</code></span>
<span class="codeline" id="line-261"><code>	return "json: invalid UTF-8 in string: " + strconv.Quote(e.S)</code></span>
<span class="codeline" id="line-262"><code>}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>// A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.</code></span>
<span class="codeline" id="line-265"><code>type MarshalerError struct {</code></span>
<span class="codeline" id="line-266"><code>	Type       reflect.Type</code></span>
<span class="codeline" id="line-267"><code>	Err        error</code></span>
<span class="codeline" id="line-268"><code>	sourceFunc string</code></span>
<span class="codeline" id="line-269"><code>}</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>func (e *MarshalerError) Error() string {</code></span>
<span class="codeline" id="line-272"><code>	srcFunc := e.sourceFunc</code></span>
<span class="codeline" id="line-273"><code>	if srcFunc == "" {</code></span>
<span class="codeline" id="line-274"><code>		srcFunc = "MarshalJSON"</code></span>
<span class="codeline" id="line-275"><code>	}</code></span>
<span class="codeline" id="line-276"><code>	return "json: error calling " + srcFunc +</code></span>
<span class="codeline" id="line-277"><code>		" for type " + e.Type.String() +</code></span>
<span class="codeline" id="line-278"><code>		": " + e.Err.Error()</code></span>
<span class="codeline" id="line-279"><code>}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>// Unwrap returns the underlying error.</code></span>
<span class="codeline" id="line-282"><code>func (e *MarshalerError) Unwrap() error { return e.Err }</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>var hex = "0123456789abcdef"</code></span>
<span class="codeline" id="line-285"><code></code></span>
<span class="codeline" id="line-286"><code>// An encodeState encodes JSON into a bytes.Buffer.</code></span>
<span class="codeline" id="line-287"><code>type encodeState struct {</code></span>
<span class="codeline" id="line-288"><code>	bytes.Buffer // accumulated output</code></span>
<span class="codeline" id="line-289"><code>	scratch      [64]byte</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	// Keep track of what pointers we've seen in the current recursive call</code></span>
<span class="codeline" id="line-292"><code>	// path, to avoid cycles that could lead to a stack overflow. Only do</code></span>
<span class="codeline" id="line-293"><code>	// the relatively expensive map operations if ptrLevel is larger than</code></span>
<span class="codeline" id="line-294"><code>	// startDetectingCyclesAfter, so that we skip the work if we're within a</code></span>
<span class="codeline" id="line-295"><code>	// reasonable amount of nested pointers deep.</code></span>
<span class="codeline" id="line-296"><code>	ptrLevel uint</code></span>
<span class="codeline" id="line-297"><code>	ptrSeen  map[interface{}]struct{}</code></span>
<span class="codeline" id="line-298"><code>}</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>const startDetectingCyclesAfter = 1000</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>var encodeStatePool sync.Pool</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>func newEncodeState() *encodeState {</code></span>
<span class="codeline" id="line-305"><code>	if v := encodeStatePool.Get(); v != nil {</code></span>
<span class="codeline" id="line-306"><code>		e := v.(*encodeState)</code></span>
<span class="codeline" id="line-307"><code>		e.Reset()</code></span>
<span class="codeline" id="line-308"><code>		if len(e.ptrSeen) &gt; 0 {</code></span>
<span class="codeline" id="line-309"><code>			panic("ptrEncoder.encode should have emptied ptrSeen via defers")</code></span>
<span class="codeline" id="line-310"><code>		}</code></span>
<span class="codeline" id="line-311"><code>		e.ptrLevel = 0</code></span>
<span class="codeline" id="line-312"><code>		return e</code></span>
<span class="codeline" id="line-313"><code>	}</code></span>
<span class="codeline" id="line-314"><code>	return &amp;encodeState{ptrSeen: make(map[interface{}]struct{})}</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// jsonError is an error wrapper type for internal use only.</code></span>
<span class="codeline" id="line-318"><code>// Panics with errors are wrapped in jsonError so that the top-level recover</code></span>
<span class="codeline" id="line-319"><code>// can distinguish intentional panics from this package.</code></span>
<span class="codeline" id="line-320"><code>type jsonError struct{ error }</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>func (e *encodeState) marshal(v interface{}, opts encOpts) (err error) {</code></span>
<span class="codeline" id="line-323"><code>	defer func() {</code></span>
<span class="codeline" id="line-324"><code>		if r := recover(); r != nil {</code></span>
<span class="codeline" id="line-325"><code>			if je, ok := r.(jsonError); ok {</code></span>
<span class="codeline" id="line-326"><code>				err = je.error</code></span>
<span class="codeline" id="line-327"><code>			} else {</code></span>
<span class="codeline" id="line-328"><code>				panic(r)</code></span>
<span class="codeline" id="line-329"><code>			}</code></span>
<span class="codeline" id="line-330"><code>		}</code></span>
<span class="codeline" id="line-331"><code>	}()</code></span>
<span class="codeline" id="line-332"><code>	e.reflectValue(reflect.ValueOf(v), opts)</code></span>
<span class="codeline" id="line-333"><code>	return nil</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// error aborts the encoding by panicking with err wrapped in jsonError.</code></span>
<span class="codeline" id="line-337"><code>func (e *encodeState) error(err error) {</code></span>
<span class="codeline" id="line-338"><code>	panic(jsonError{err})</code></span>
<span class="codeline" id="line-339"><code>}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>func isEmptyValue(v reflect.Value) bool {</code></span>
<span class="codeline" id="line-342"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-343"><code>	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:</code></span>
<span class="codeline" id="line-344"><code>		return v.Len() == 0</code></span>
<span class="codeline" id="line-345"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-346"><code>		return !v.Bool()</code></span>
<span class="codeline" id="line-347"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-348"><code>		return v.Int() == 0</code></span>
<span class="codeline" id="line-349"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-350"><code>		return v.Uint() == 0</code></span>
<span class="codeline" id="line-351"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-352"><code>		return v.Float() == 0</code></span>
<span class="codeline" id="line-353"><code>	case reflect.Interface, reflect.Ptr:</code></span>
<span class="codeline" id="line-354"><code>		return v.IsNil()</code></span>
<span class="codeline" id="line-355"><code>	}</code></span>
<span class="codeline" id="line-356"><code>	return false</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>func (e *encodeState) reflectValue(v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-360"><code>	valueEncoder(v)(e, v, opts)</code></span>
<span class="codeline" id="line-361"><code>}</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>type encOpts struct {</code></span>
<span class="codeline" id="line-364"><code>	// quoted causes primitive fields to be encoded inside JSON strings.</code></span>
<span class="codeline" id="line-365"><code>	quoted bool</code></span>
<span class="codeline" id="line-366"><code>	// escapeHTML causes '&lt;', '&gt;', and '&amp;' to be escaped in JSON strings.</code></span>
<span class="codeline" id="line-367"><code>	escapeHTML bool</code></span>
<span class="codeline" id="line-368"><code>}</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>type encoderFunc func(e *encodeState, v reflect.Value, opts encOpts)</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>var encoderCache sync.Map // map[reflect.Type]encoderFunc</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>func valueEncoder(v reflect.Value) encoderFunc {</code></span>
<span class="codeline" id="line-375"><code>	if !v.IsValid() {</code></span>
<span class="codeline" id="line-376"><code>		return invalidValueEncoder</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	return typeEncoder(v.Type())</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>func typeEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-382"><code>	if fi, ok := encoderCache.Load(t); ok {</code></span>
<span class="codeline" id="line-383"><code>		return fi.(encoderFunc)</code></span>
<span class="codeline" id="line-384"><code>	}</code></span>
<span class="codeline" id="line-385"><code></code></span>
<span class="codeline" id="line-386"><code>	// To deal with recursive types, populate the map with an</code></span>
<span class="codeline" id="line-387"><code>	// indirect func before we build it. This type waits on the</code></span>
<span class="codeline" id="line-388"><code>	// real func (f) to be ready and then calls it. This indirect</code></span>
<span class="codeline" id="line-389"><code>	// func is only used for recursive types.</code></span>
<span class="codeline" id="line-390"><code>	var (</code></span>
<span class="codeline" id="line-391"><code>		wg sync.WaitGroup</code></span>
<span class="codeline" id="line-392"><code>		f  encoderFunc</code></span>
<span class="codeline" id="line-393"><code>	)</code></span>
<span class="codeline" id="line-394"><code>	wg.Add(1)</code></span>
<span class="codeline" id="line-395"><code>	fi, loaded := encoderCache.LoadOrStore(t, encoderFunc(func(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-396"><code>		wg.Wait()</code></span>
<span class="codeline" id="line-397"><code>		f(e, v, opts)</code></span>
<span class="codeline" id="line-398"><code>	}))</code></span>
<span class="codeline" id="line-399"><code>	if loaded {</code></span>
<span class="codeline" id="line-400"><code>		return fi.(encoderFunc)</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>	// Compute the real encoder and replace the indirect func with it.</code></span>
<span class="codeline" id="line-404"><code>	f = newTypeEncoder(t, true)</code></span>
<span class="codeline" id="line-405"><code>	wg.Done()</code></span>
<span class="codeline" id="line-406"><code>	encoderCache.Store(t, f)</code></span>
<span class="codeline" id="line-407"><code>	return f</code></span>
<span class="codeline" id="line-408"><code>}</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>var (</code></span>
<span class="codeline" id="line-411"><code>	marshalerType     = reflect.TypeOf((*Marshaler)(nil)).Elem()</code></span>
<span class="codeline" id="line-412"><code>	textMarshalerType = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()</code></span>
<span class="codeline" id="line-413"><code>)</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>// newTypeEncoder constructs an encoderFunc for a type.</code></span>
<span class="codeline" id="line-416"><code>// The returned encoder only checks CanAddr when allowAddr is true.</code></span>
<span class="codeline" id="line-417"><code>func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {</code></span>
<span class="codeline" id="line-418"><code>	// If we have a non-pointer value whose type implements</code></span>
<span class="codeline" id="line-419"><code>	// Marshaler with a value receiver, then we're better off taking</code></span>
<span class="codeline" id="line-420"><code>	// the address of the value - otherwise we end up with an</code></span>
<span class="codeline" id="line-421"><code>	// allocation as we cast the value to an interface.</code></span>
<span class="codeline" id="line-422"><code>	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(marshalerType) {</code></span>
<span class="codeline" id="line-423"><code>		return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))</code></span>
<span class="codeline" id="line-424"><code>	}</code></span>
<span class="codeline" id="line-425"><code>	if t.Implements(marshalerType) {</code></span>
<span class="codeline" id="line-426"><code>		return marshalerEncoder</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-429"><code>		return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))</code></span>
<span class="codeline" id="line-430"><code>	}</code></span>
<span class="codeline" id="line-431"><code>	if t.Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-432"><code>		return textMarshalerEncoder</code></span>
<span class="codeline" id="line-433"><code>	}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>	switch t.Kind() {</code></span>
<span class="codeline" id="line-436"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-437"><code>		return boolEncoder</code></span>
<span class="codeline" id="line-438"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-439"><code>		return intEncoder</code></span>
<span class="codeline" id="line-440"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-441"><code>		return uintEncoder</code></span>
<span class="codeline" id="line-442"><code>	case reflect.Float32:</code></span>
<span class="codeline" id="line-443"><code>		return float32Encoder</code></span>
<span class="codeline" id="line-444"><code>	case reflect.Float64:</code></span>
<span class="codeline" id="line-445"><code>		return float64Encoder</code></span>
<span class="codeline" id="line-446"><code>	case reflect.String:</code></span>
<span class="codeline" id="line-447"><code>		return stringEncoder</code></span>
<span class="codeline" id="line-448"><code>	case reflect.Interface:</code></span>
<span class="codeline" id="line-449"><code>		return interfaceEncoder</code></span>
<span class="codeline" id="line-450"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-451"><code>		return newStructEncoder(t)</code></span>
<span class="codeline" id="line-452"><code>	case reflect.Map:</code></span>
<span class="codeline" id="line-453"><code>		return newMapEncoder(t)</code></span>
<span class="codeline" id="line-454"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-455"><code>		return newSliceEncoder(t)</code></span>
<span class="codeline" id="line-456"><code>	case reflect.Array:</code></span>
<span class="codeline" id="line-457"><code>		return newArrayEncoder(t)</code></span>
<span class="codeline" id="line-458"><code>	case reflect.Ptr:</code></span>
<span class="codeline" id="line-459"><code>		return newPtrEncoder(t)</code></span>
<span class="codeline" id="line-460"><code>	default:</code></span>
<span class="codeline" id="line-461"><code>		return unsupportedTypeEncoder</code></span>
<span class="codeline" id="line-462"><code>	}</code></span>
<span class="codeline" id="line-463"><code>}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>func invalidValueEncoder(e *encodeState, v reflect.Value, _ encOpts) {</code></span>
<span class="codeline" id="line-466"><code>	e.WriteString("null")</code></span>
<span class="codeline" id="line-467"><code>}</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-470"><code>	if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() {</code></span>
<span class="codeline" id="line-471"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-472"><code>		return</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code>	m, ok := v.Interface().(Marshaler)</code></span>
<span class="codeline" id="line-475"><code>	if !ok {</code></span>
<span class="codeline" id="line-476"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-477"><code>		return</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code>	b, err := m.MarshalJSON()</code></span>
<span class="codeline" id="line-480"><code>	if err == nil {</code></span>
<span class="codeline" id="line-481"><code>		// copy JSON into buffer, checking validity.</code></span>
<span class="codeline" id="line-482"><code>		err = compact(&amp;e.Buffer, b, opts.escapeHTML)</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code>	if err != nil {</code></span>
<span class="codeline" id="line-485"><code>		e.error(&amp;MarshalerError{v.Type(), err, "MarshalJSON"})</code></span>
<span class="codeline" id="line-486"><code>	}</code></span>
<span class="codeline" id="line-487"><code>}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-490"><code>	va := v.Addr()</code></span>
<span class="codeline" id="line-491"><code>	if va.IsNil() {</code></span>
<span class="codeline" id="line-492"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-493"><code>		return</code></span>
<span class="codeline" id="line-494"><code>	}</code></span>
<span class="codeline" id="line-495"><code>	m := va.Interface().(Marshaler)</code></span>
<span class="codeline" id="line-496"><code>	b, err := m.MarshalJSON()</code></span>
<span class="codeline" id="line-497"><code>	if err == nil {</code></span>
<span class="codeline" id="line-498"><code>		// copy JSON into buffer, checking validity.</code></span>
<span class="codeline" id="line-499"><code>		err = compact(&amp;e.Buffer, b, opts.escapeHTML)</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code>	if err != nil {</code></span>
<span class="codeline" id="line-502"><code>		e.error(&amp;MarshalerError{v.Type(), err, "MarshalJSON"})</code></span>
<span class="codeline" id="line-503"><code>	}</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>func textMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-507"><code>	if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() {</code></span>
<span class="codeline" id="line-508"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-509"><code>		return</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code>	m, ok := v.Interface().(encoding.TextMarshaler)</code></span>
<span class="codeline" id="line-512"><code>	if !ok {</code></span>
<span class="codeline" id="line-513"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-514"><code>		return</code></span>
<span class="codeline" id="line-515"><code>	}</code></span>
<span class="codeline" id="line-516"><code>	b, err := m.MarshalText()</code></span>
<span class="codeline" id="line-517"><code>	if err != nil {</code></span>
<span class="codeline" id="line-518"><code>		e.error(&amp;MarshalerError{v.Type(), err, "MarshalText"})</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code>	e.stringBytes(b, opts.escapeHTML)</code></span>
<span class="codeline" id="line-521"><code>}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-524"><code>	va := v.Addr()</code></span>
<span class="codeline" id="line-525"><code>	if va.IsNil() {</code></span>
<span class="codeline" id="line-526"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-527"><code>		return</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code>	m := va.Interface().(encoding.TextMarshaler)</code></span>
<span class="codeline" id="line-530"><code>	b, err := m.MarshalText()</code></span>
<span class="codeline" id="line-531"><code>	if err != nil {</code></span>
<span class="codeline" id="line-532"><code>		e.error(&amp;MarshalerError{v.Type(), err, "MarshalText"})</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code>	e.stringBytes(b, opts.escapeHTML)</code></span>
<span class="codeline" id="line-535"><code>}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>func boolEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-538"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-539"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-540"><code>	}</code></span>
<span class="codeline" id="line-541"><code>	if v.Bool() {</code></span>
<span class="codeline" id="line-542"><code>		e.WriteString("true")</code></span>
<span class="codeline" id="line-543"><code>	} else {</code></span>
<span class="codeline" id="line-544"><code>		e.WriteString("false")</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-547"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-548"><code>	}</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>func intEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-552"><code>	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)</code></span>
<span class="codeline" id="line-553"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-554"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-555"><code>	}</code></span>
<span class="codeline" id="line-556"><code>	e.Write(b)</code></span>
<span class="codeline" id="line-557"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-558"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>func uintEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-563"><code>	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)</code></span>
<span class="codeline" id="line-564"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-565"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-566"><code>	}</code></span>
<span class="codeline" id="line-567"><code>	e.Write(b)</code></span>
<span class="codeline" id="line-568"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-569"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-570"><code>	}</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>type floatEncoder int // number of bits</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>func (bits floatEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-576"><code>	f := v.Float()</code></span>
<span class="codeline" id="line-577"><code>	if math.IsInf(f, 0) || math.IsNaN(f) {</code></span>
<span class="codeline" id="line-578"><code>		e.error(&amp;UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})</code></span>
<span class="codeline" id="line-579"><code>	}</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>	// Convert as if by ES6 number to string conversion.</code></span>
<span class="codeline" id="line-582"><code>	// This matches most other JSON generators.</code></span>
<span class="codeline" id="line-583"><code>	// See golang.org/issue/6384 and golang.org/issue/14135.</code></span>
<span class="codeline" id="line-584"><code>	// Like fmt %g, but the exponent cutoffs are different</code></span>
<span class="codeline" id="line-585"><code>	// and exponents themselves are not padded to two digits.</code></span>
<span class="codeline" id="line-586"><code>	b := e.scratch[:0]</code></span>
<span class="codeline" id="line-587"><code>	abs := math.Abs(f)</code></span>
<span class="codeline" id="line-588"><code>	fmt := byte('f')</code></span>
<span class="codeline" id="line-589"><code>	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.</code></span>
<span class="codeline" id="line-590"><code>	if abs != 0 {</code></span>
<span class="codeline" id="line-591"><code>		if bits == 64 &amp;&amp; (abs &lt; 1e-6 || abs &gt;= 1e21) || bits == 32 &amp;&amp; (float32(abs) &lt; 1e-6 || float32(abs) &gt;= 1e21) {</code></span>
<span class="codeline" id="line-592"><code>			fmt = 'e'</code></span>
<span class="codeline" id="line-593"><code>		}</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code>	b = strconv.AppendFloat(b, f, fmt, -1, int(bits))</code></span>
<span class="codeline" id="line-596"><code>	if fmt == 'e' {</code></span>
<span class="codeline" id="line-597"><code>		// clean up e-09 to e-9</code></span>
<span class="codeline" id="line-598"><code>		n := len(b)</code></span>
<span class="codeline" id="line-599"><code>		if n &gt;= 4 &amp;&amp; b[n-4] == 'e' &amp;&amp; b[n-3] == '-' &amp;&amp; b[n-2] == '0' {</code></span>
<span class="codeline" id="line-600"><code>			b[n-2] = b[n-1]</code></span>
<span class="codeline" id="line-601"><code>			b = b[:n-1]</code></span>
<span class="codeline" id="line-602"><code>		}</code></span>
<span class="codeline" id="line-603"><code>	}</code></span>
<span class="codeline" id="line-604"><code></code></span>
<span class="codeline" id="line-605"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-606"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-607"><code>	}</code></span>
<span class="codeline" id="line-608"><code>	e.Write(b)</code></span>
<span class="codeline" id="line-609"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-610"><code>		e.WriteByte('"')</code></span>
<span class="codeline" id="line-611"><code>	}</code></span>
<span class="codeline" id="line-612"><code>}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>var (</code></span>
<span class="codeline" id="line-615"><code>	float32Encoder = (floatEncoder(32)).encode</code></span>
<span class="codeline" id="line-616"><code>	float64Encoder = (floatEncoder(64)).encode</code></span>
<span class="codeline" id="line-617"><code>)</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>func stringEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-620"><code>	if v.Type() == numberType {</code></span>
<span class="codeline" id="line-621"><code>		numStr := v.String()</code></span>
<span class="codeline" id="line-622"><code>		// In Go1.5 the empty string encodes to "0", while this is not a valid number literal</code></span>
<span class="codeline" id="line-623"><code>		// we keep compatibility so check validity after this.</code></span>
<span class="codeline" id="line-624"><code>		if numStr == "" {</code></span>
<span class="codeline" id="line-625"><code>			numStr = "0" // Number's zero-val</code></span>
<span class="codeline" id="line-626"><code>		}</code></span>
<span class="codeline" id="line-627"><code>		if !isValidNumber(numStr) {</code></span>
<span class="codeline" id="line-628"><code>			e.error(fmt.Errorf("json: invalid number literal %q", numStr))</code></span>
<span class="codeline" id="line-629"><code>		}</code></span>
<span class="codeline" id="line-630"><code>		if opts.quoted {</code></span>
<span class="codeline" id="line-631"><code>			e.WriteByte('"')</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>		e.WriteString(numStr)</code></span>
<span class="codeline" id="line-634"><code>		if opts.quoted {</code></span>
<span class="codeline" id="line-635"><code>			e.WriteByte('"')</code></span>
<span class="codeline" id="line-636"><code>		}</code></span>
<span class="codeline" id="line-637"><code>		return</code></span>
<span class="codeline" id="line-638"><code>	}</code></span>
<span class="codeline" id="line-639"><code>	if opts.quoted {</code></span>
<span class="codeline" id="line-640"><code>		e2 := newEncodeState()</code></span>
<span class="codeline" id="line-641"><code>		// Since we encode the string twice, we only need to escape HTML</code></span>
<span class="codeline" id="line-642"><code>		// the first time.</code></span>
<span class="codeline" id="line-643"><code>		e2.string(v.String(), opts.escapeHTML)</code></span>
<span class="codeline" id="line-644"><code>		e.stringBytes(e2.Bytes(), false)</code></span>
<span class="codeline" id="line-645"><code>		encodeStatePool.Put(e2)</code></span>
<span class="codeline" id="line-646"><code>	} else {</code></span>
<span class="codeline" id="line-647"><code>		e.string(v.String(), opts.escapeHTML)</code></span>
<span class="codeline" id="line-648"><code>	}</code></span>
<span class="codeline" id="line-649"><code>}</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>// isValidNumber reports whether s is a valid JSON number literal.</code></span>
<span class="codeline" id="line-652"><code>func isValidNumber(s string) bool {</code></span>
<span class="codeline" id="line-653"><code>	// This function implements the JSON numbers grammar.</code></span>
<span class="codeline" id="line-654"><code>	// See https://tools.ietf.org/html/rfc7159#section-6</code></span>
<span class="codeline" id="line-655"><code>	// and https://www.json.org/img/number.png</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>	if s == "" {</code></span>
<span class="codeline" id="line-658"><code>		return false</code></span>
<span class="codeline" id="line-659"><code>	}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>	// Optional -</code></span>
<span class="codeline" id="line-662"><code>	if s[0] == '-' {</code></span>
<span class="codeline" id="line-663"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-664"><code>		if s == "" {</code></span>
<span class="codeline" id="line-665"><code>			return false</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code>	}</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>	// Digits</code></span>
<span class="codeline" id="line-670"><code>	switch {</code></span>
<span class="codeline" id="line-671"><code>	default:</code></span>
<span class="codeline" id="line-672"><code>		return false</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	case s[0] == '0':</code></span>
<span class="codeline" id="line-675"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	case '1' &lt;= s[0] &amp;&amp; s[0] &lt;= '9':</code></span>
<span class="codeline" id="line-678"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-679"><code>		for len(s) &gt; 0 &amp;&amp; '0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9' {</code></span>
<span class="codeline" id="line-680"><code>			s = s[1:]</code></span>
<span class="codeline" id="line-681"><code>		}</code></span>
<span class="codeline" id="line-682"><code>	}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>	// . followed by 1 or more digits.</code></span>
<span class="codeline" id="line-685"><code>	if len(s) &gt;= 2 &amp;&amp; s[0] == '.' &amp;&amp; '0' &lt;= s[1] &amp;&amp; s[1] &lt;= '9' {</code></span>
<span class="codeline" id="line-686"><code>		s = s[2:]</code></span>
<span class="codeline" id="line-687"><code>		for len(s) &gt; 0 &amp;&amp; '0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9' {</code></span>
<span class="codeline" id="line-688"><code>			s = s[1:]</code></span>
<span class="codeline" id="line-689"><code>		}</code></span>
<span class="codeline" id="line-690"><code>	}</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>	// e or E followed by an optional - or + and</code></span>
<span class="codeline" id="line-693"><code>	// 1 or more digits.</code></span>
<span class="codeline" id="line-694"><code>	if len(s) &gt;= 2 &amp;&amp; (s[0] == 'e' || s[0] == 'E') {</code></span>
<span class="codeline" id="line-695"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-696"><code>		if s[0] == '+' || s[0] == '-' {</code></span>
<span class="codeline" id="line-697"><code>			s = s[1:]</code></span>
<span class="codeline" id="line-698"><code>			if s == "" {</code></span>
<span class="codeline" id="line-699"><code>				return false</code></span>
<span class="codeline" id="line-700"><code>			}</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>		for len(s) &gt; 0 &amp;&amp; '0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9' {</code></span>
<span class="codeline" id="line-703"><code>			s = s[1:]</code></span>
<span class="codeline" id="line-704"><code>		}</code></span>
<span class="codeline" id="line-705"><code>	}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>	// Make sure we are at the end.</code></span>
<span class="codeline" id="line-708"><code>	return s == ""</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>func interfaceEncoder(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-712"><code>	if v.IsNil() {</code></span>
<span class="codeline" id="line-713"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-714"><code>		return</code></span>
<span class="codeline" id="line-715"><code>	}</code></span>
<span class="codeline" id="line-716"><code>	e.reflectValue(v.Elem(), opts)</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>func unsupportedTypeEncoder(e *encodeState, v reflect.Value, _ encOpts) {</code></span>
<span class="codeline" id="line-720"><code>	e.error(&amp;UnsupportedTypeError{v.Type()})</code></span>
<span class="codeline" id="line-721"><code>}</code></span>
<span class="codeline" id="line-722"><code></code></span>
<span class="codeline" id="line-723"><code>type structEncoder struct {</code></span>
<span class="codeline" id="line-724"><code>	fields structFields</code></span>
<span class="codeline" id="line-725"><code>}</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>type structFields struct {</code></span>
<span class="codeline" id="line-728"><code>	list      []field</code></span>
<span class="codeline" id="line-729"><code>	nameIndex map[string]int</code></span>
<span class="codeline" id="line-730"><code>}</code></span>
<span class="codeline" id="line-731"><code></code></span>
<span class="codeline" id="line-732"><code>func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-733"><code>	next := byte('{')</code></span>
<span class="codeline" id="line-734"><code>FieldLoop:</code></span>
<span class="codeline" id="line-735"><code>	for i := range se.fields.list {</code></span>
<span class="codeline" id="line-736"><code>		f := &amp;se.fields.list[i]</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>		// Find the nested struct field by following f.index.</code></span>
<span class="codeline" id="line-739"><code>		fv := v</code></span>
<span class="codeline" id="line-740"><code>		for _, i := range f.index {</code></span>
<span class="codeline" id="line-741"><code>			if fv.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-742"><code>				if fv.IsNil() {</code></span>
<span class="codeline" id="line-743"><code>					continue FieldLoop</code></span>
<span class="codeline" id="line-744"><code>				}</code></span>
<span class="codeline" id="line-745"><code>				fv = fv.Elem()</code></span>
<span class="codeline" id="line-746"><code>			}</code></span>
<span class="codeline" id="line-747"><code>			fv = fv.Field(i)</code></span>
<span class="codeline" id="line-748"><code>		}</code></span>
<span class="codeline" id="line-749"><code></code></span>
<span class="codeline" id="line-750"><code>		if f.omitEmpty &amp;&amp; isEmptyValue(fv) {</code></span>
<span class="codeline" id="line-751"><code>			continue</code></span>
<span class="codeline" id="line-752"><code>		}</code></span>
<span class="codeline" id="line-753"><code>		e.WriteByte(next)</code></span>
<span class="codeline" id="line-754"><code>		next = ','</code></span>
<span class="codeline" id="line-755"><code>		if opts.escapeHTML {</code></span>
<span class="codeline" id="line-756"><code>			e.WriteString(f.nameEscHTML)</code></span>
<span class="codeline" id="line-757"><code>		} else {</code></span>
<span class="codeline" id="line-758"><code>			e.WriteString(f.nameNonEsc)</code></span>
<span class="codeline" id="line-759"><code>		}</code></span>
<span class="codeline" id="line-760"><code>		opts.quoted = f.quoted</code></span>
<span class="codeline" id="line-761"><code>		f.encoder(e, fv, opts)</code></span>
<span class="codeline" id="line-762"><code>	}</code></span>
<span class="codeline" id="line-763"><code>	if next == '{' {</code></span>
<span class="codeline" id="line-764"><code>		e.WriteString("{}")</code></span>
<span class="codeline" id="line-765"><code>	} else {</code></span>
<span class="codeline" id="line-766"><code>		e.WriteByte('}')</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>func newStructEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-771"><code>	se := structEncoder{fields: cachedTypeFields(t)}</code></span>
<span class="codeline" id="line-772"><code>	return se.encode</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>type mapEncoder struct {</code></span>
<span class="codeline" id="line-776"><code>	elemEnc encoderFunc</code></span>
<span class="codeline" id="line-777"><code>}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-780"><code>	if v.IsNil() {</code></span>
<span class="codeline" id="line-781"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-782"><code>		return</code></span>
<span class="codeline" id="line-783"><code>	}</code></span>
<span class="codeline" id="line-784"><code>	if e.ptrLevel++; e.ptrLevel &gt; startDetectingCyclesAfter {</code></span>
<span class="codeline" id="line-785"><code>		// We're a large number of nested ptrEncoder.encode calls deep;</code></span>
<span class="codeline" id="line-786"><code>		// start checking if we've run into a pointer cycle.</code></span>
<span class="codeline" id="line-787"><code>		ptr := v.Pointer()</code></span>
<span class="codeline" id="line-788"><code>		if _, ok := e.ptrSeen[ptr]; ok {</code></span>
<span class="codeline" id="line-789"><code>			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})</code></span>
<span class="codeline" id="line-790"><code>		}</code></span>
<span class="codeline" id="line-791"><code>		e.ptrSeen[ptr] = struct{}{}</code></span>
<span class="codeline" id="line-792"><code>		defer delete(e.ptrSeen, ptr)</code></span>
<span class="codeline" id="line-793"><code>	}</code></span>
<span class="codeline" id="line-794"><code>	e.WriteByte('{')</code></span>
<span class="codeline" id="line-795"><code></code></span>
<span class="codeline" id="line-796"><code>	// Extract and sort the keys.</code></span>
<span class="codeline" id="line-797"><code>	keys := v.MapKeys()</code></span>
<span class="codeline" id="line-798"><code>	sv := make([]reflectWithString, len(keys))</code></span>
<span class="codeline" id="line-799"><code>	for i, v := range keys {</code></span>
<span class="codeline" id="line-800"><code>		sv[i].v = v</code></span>
<span class="codeline" id="line-801"><code>		if err := sv[i].resolve(); err != nil {</code></span>
<span class="codeline" id="line-802"><code>			e.error(fmt.Errorf("json: encoding error for type %q: %q", v.Type().String(), err.Error()))</code></span>
<span class="codeline" id="line-803"><code>		}</code></span>
<span class="codeline" id="line-804"><code>	}</code></span>
<span class="codeline" id="line-805"><code>	sort.Slice(sv, func(i, j int) bool { return sv[i].s &lt; sv[j].s })</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>	for i, kv := range sv {</code></span>
<span class="codeline" id="line-808"><code>		if i &gt; 0 {</code></span>
<span class="codeline" id="line-809"><code>			e.WriteByte(',')</code></span>
<span class="codeline" id="line-810"><code>		}</code></span>
<span class="codeline" id="line-811"><code>		e.string(kv.s, opts.escapeHTML)</code></span>
<span class="codeline" id="line-812"><code>		e.WriteByte(':')</code></span>
<span class="codeline" id="line-813"><code>		me.elemEnc(e, v.MapIndex(kv.v), opts)</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code>	e.WriteByte('}')</code></span>
<span class="codeline" id="line-816"><code>	e.ptrLevel--</code></span>
<span class="codeline" id="line-817"><code>}</code></span>
<span class="codeline" id="line-818"><code></code></span>
<span class="codeline" id="line-819"><code>func newMapEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-820"><code>	switch t.Key().Kind() {</code></span>
<span class="codeline" id="line-821"><code>	case reflect.String,</code></span>
<span class="codeline" id="line-822"><code>		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-823"><code>		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-824"><code>	default:</code></span>
<span class="codeline" id="line-825"><code>		if !t.Key().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-826"><code>			return unsupportedTypeEncoder</code></span>
<span class="codeline" id="line-827"><code>		}</code></span>
<span class="codeline" id="line-828"><code>	}</code></span>
<span class="codeline" id="line-829"><code>	me := mapEncoder{typeEncoder(t.Elem())}</code></span>
<span class="codeline" id="line-830"><code>	return me.encode</code></span>
<span class="codeline" id="line-831"><code>}</code></span>
<span class="codeline" id="line-832"><code></code></span>
<span class="codeline" id="line-833"><code>func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts) {</code></span>
<span class="codeline" id="line-834"><code>	if v.IsNil() {</code></span>
<span class="codeline" id="line-835"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-836"><code>		return</code></span>
<span class="codeline" id="line-837"><code>	}</code></span>
<span class="codeline" id="line-838"><code>	s := v.Bytes()</code></span>
<span class="codeline" id="line-839"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-840"><code>	encodedLen := base64.StdEncoding.EncodedLen(len(s))</code></span>
<span class="codeline" id="line-841"><code>	if encodedLen &lt;= len(e.scratch) {</code></span>
<span class="codeline" id="line-842"><code>		// If the encoded bytes fit in e.scratch, avoid an extra</code></span>
<span class="codeline" id="line-843"><code>		// allocation and use the cheaper Encoding.Encode.</code></span>
<span class="codeline" id="line-844"><code>		dst := e.scratch[:encodedLen]</code></span>
<span class="codeline" id="line-845"><code>		base64.StdEncoding.Encode(dst, s)</code></span>
<span class="codeline" id="line-846"><code>		e.Write(dst)</code></span>
<span class="codeline" id="line-847"><code>	} else if encodedLen &lt;= 1024 {</code></span>
<span class="codeline" id="line-848"><code>		// The encoded bytes are short enough to allocate for, and</code></span>
<span class="codeline" id="line-849"><code>		// Encoding.Encode is still cheaper.</code></span>
<span class="codeline" id="line-850"><code>		dst := make([]byte, encodedLen)</code></span>
<span class="codeline" id="line-851"><code>		base64.StdEncoding.Encode(dst, s)</code></span>
<span class="codeline" id="line-852"><code>		e.Write(dst)</code></span>
<span class="codeline" id="line-853"><code>	} else {</code></span>
<span class="codeline" id="line-854"><code>		// The encoded bytes are too long to cheaply allocate, and</code></span>
<span class="codeline" id="line-855"><code>		// Encoding.Encode is no longer noticeably cheaper.</code></span>
<span class="codeline" id="line-856"><code>		enc := base64.NewEncoder(base64.StdEncoding, e)</code></span>
<span class="codeline" id="line-857"><code>		enc.Write(s)</code></span>
<span class="codeline" id="line-858"><code>		enc.Close()</code></span>
<span class="codeline" id="line-859"><code>	}</code></span>
<span class="codeline" id="line-860"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-861"><code>}</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.</code></span>
<span class="codeline" id="line-864"><code>type sliceEncoder struct {</code></span>
<span class="codeline" id="line-865"><code>	arrayEnc encoderFunc</code></span>
<span class="codeline" id="line-866"><code>}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>func (se sliceEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-869"><code>	if v.IsNil() {</code></span>
<span class="codeline" id="line-870"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-871"><code>		return</code></span>
<span class="codeline" id="line-872"><code>	}</code></span>
<span class="codeline" id="line-873"><code>	if e.ptrLevel++; e.ptrLevel &gt; startDetectingCyclesAfter {</code></span>
<span class="codeline" id="line-874"><code>		// We're a large number of nested ptrEncoder.encode calls deep;</code></span>
<span class="codeline" id="line-875"><code>		// start checking if we've run into a pointer cycle.</code></span>
<span class="codeline" id="line-876"><code>		// Here we use a struct to memorize the pointer to the first element of the slice</code></span>
<span class="codeline" id="line-877"><code>		// and its length.</code></span>
<span class="codeline" id="line-878"><code>		ptr := struct {</code></span>
<span class="codeline" id="line-879"><code>			ptr uintptr</code></span>
<span class="codeline" id="line-880"><code>			len int</code></span>
<span class="codeline" id="line-881"><code>		}{v.Pointer(), v.Len()}</code></span>
<span class="codeline" id="line-882"><code>		if _, ok := e.ptrSeen[ptr]; ok {</code></span>
<span class="codeline" id="line-883"><code>			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})</code></span>
<span class="codeline" id="line-884"><code>		}</code></span>
<span class="codeline" id="line-885"><code>		e.ptrSeen[ptr] = struct{}{}</code></span>
<span class="codeline" id="line-886"><code>		defer delete(e.ptrSeen, ptr)</code></span>
<span class="codeline" id="line-887"><code>	}</code></span>
<span class="codeline" id="line-888"><code>	se.arrayEnc(e, v, opts)</code></span>
<span class="codeline" id="line-889"><code>	e.ptrLevel--</code></span>
<span class="codeline" id="line-890"><code>}</code></span>
<span class="codeline" id="line-891"><code></code></span>
<span class="codeline" id="line-892"><code>func newSliceEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-893"><code>	// Byte slices get special treatment; arrays don't.</code></span>
<span class="codeline" id="line-894"><code>	if t.Elem().Kind() == reflect.Uint8 {</code></span>
<span class="codeline" id="line-895"><code>		p := reflect.PtrTo(t.Elem())</code></span>
<span class="codeline" id="line-896"><code>		if !p.Implements(marshalerType) &amp;&amp; !p.Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-897"><code>			return encodeByteSlice</code></span>
<span class="codeline" id="line-898"><code>		}</code></span>
<span class="codeline" id="line-899"><code>	}</code></span>
<span class="codeline" id="line-900"><code>	enc := sliceEncoder{newArrayEncoder(t)}</code></span>
<span class="codeline" id="line-901"><code>	return enc.encode</code></span>
<span class="codeline" id="line-902"><code>}</code></span>
<span class="codeline" id="line-903"><code></code></span>
<span class="codeline" id="line-904"><code>type arrayEncoder struct {</code></span>
<span class="codeline" id="line-905"><code>	elemEnc encoderFunc</code></span>
<span class="codeline" id="line-906"><code>}</code></span>
<span class="codeline" id="line-907"><code></code></span>
<span class="codeline" id="line-908"><code>func (ae arrayEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-909"><code>	e.WriteByte('[')</code></span>
<span class="codeline" id="line-910"><code>	n := v.Len()</code></span>
<span class="codeline" id="line-911"><code>	for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-912"><code>		if i &gt; 0 {</code></span>
<span class="codeline" id="line-913"><code>			e.WriteByte(',')</code></span>
<span class="codeline" id="line-914"><code>		}</code></span>
<span class="codeline" id="line-915"><code>		ae.elemEnc(e, v.Index(i), opts)</code></span>
<span class="codeline" id="line-916"><code>	}</code></span>
<span class="codeline" id="line-917"><code>	e.WriteByte(']')</code></span>
<span class="codeline" id="line-918"><code>}</code></span>
<span class="codeline" id="line-919"><code></code></span>
<span class="codeline" id="line-920"><code>func newArrayEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-921"><code>	enc := arrayEncoder{typeEncoder(t.Elem())}</code></span>
<span class="codeline" id="line-922"><code>	return enc.encode</code></span>
<span class="codeline" id="line-923"><code>}</code></span>
<span class="codeline" id="line-924"><code></code></span>
<span class="codeline" id="line-925"><code>type ptrEncoder struct {</code></span>
<span class="codeline" id="line-926"><code>	elemEnc encoderFunc</code></span>
<span class="codeline" id="line-927"><code>}</code></span>
<span class="codeline" id="line-928"><code></code></span>
<span class="codeline" id="line-929"><code>func (pe ptrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-930"><code>	if v.IsNil() {</code></span>
<span class="codeline" id="line-931"><code>		e.WriteString("null")</code></span>
<span class="codeline" id="line-932"><code>		return</code></span>
<span class="codeline" id="line-933"><code>	}</code></span>
<span class="codeline" id="line-934"><code>	if e.ptrLevel++; e.ptrLevel &gt; startDetectingCyclesAfter {</code></span>
<span class="codeline" id="line-935"><code>		// We're a large number of nested ptrEncoder.encode calls deep;</code></span>
<span class="codeline" id="line-936"><code>		// start checking if we've run into a pointer cycle.</code></span>
<span class="codeline" id="line-937"><code>		ptr := v.Interface()</code></span>
<span class="codeline" id="line-938"><code>		if _, ok := e.ptrSeen[ptr]; ok {</code></span>
<span class="codeline" id="line-939"><code>			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})</code></span>
<span class="codeline" id="line-940"><code>		}</code></span>
<span class="codeline" id="line-941"><code>		e.ptrSeen[ptr] = struct{}{}</code></span>
<span class="codeline" id="line-942"><code>		defer delete(e.ptrSeen, ptr)</code></span>
<span class="codeline" id="line-943"><code>	}</code></span>
<span class="codeline" id="line-944"><code>	pe.elemEnc(e, v.Elem(), opts)</code></span>
<span class="codeline" id="line-945"><code>	e.ptrLevel--</code></span>
<span class="codeline" id="line-946"><code>}</code></span>
<span class="codeline" id="line-947"><code></code></span>
<span class="codeline" id="line-948"><code>func newPtrEncoder(t reflect.Type) encoderFunc {</code></span>
<span class="codeline" id="line-949"><code>	enc := ptrEncoder{typeEncoder(t.Elem())}</code></span>
<span class="codeline" id="line-950"><code>	return enc.encode</code></span>
<span class="codeline" id="line-951"><code>}</code></span>
<span class="codeline" id="line-952"><code></code></span>
<span class="codeline" id="line-953"><code>type condAddrEncoder struct {</code></span>
<span class="codeline" id="line-954"><code>	canAddrEnc, elseEnc encoderFunc</code></span>
<span class="codeline" id="line-955"><code>}</code></span>
<span class="codeline" id="line-956"><code></code></span>
<span class="codeline" id="line-957"><code>func (ce condAddrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {</code></span>
<span class="codeline" id="line-958"><code>	if v.CanAddr() {</code></span>
<span class="codeline" id="line-959"><code>		ce.canAddrEnc(e, v, opts)</code></span>
<span class="codeline" id="line-960"><code>	} else {</code></span>
<span class="codeline" id="line-961"><code>		ce.elseEnc(e, v, opts)</code></span>
<span class="codeline" id="line-962"><code>	}</code></span>
<span class="codeline" id="line-963"><code>}</code></span>
<span class="codeline" id="line-964"><code></code></span>
<span class="codeline" id="line-965"><code>// newCondAddrEncoder returns an encoder that checks whether its value</code></span>
<span class="codeline" id="line-966"><code>// CanAddr and delegates to canAddrEnc if so, else to elseEnc.</code></span>
<span class="codeline" id="line-967"><code>func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {</code></span>
<span class="codeline" id="line-968"><code>	enc := condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}</code></span>
<span class="codeline" id="line-969"><code>	return enc.encode</code></span>
<span class="codeline" id="line-970"><code>}</code></span>
<span class="codeline" id="line-971"><code></code></span>
<span class="codeline" id="line-972"><code>func isValidTag(s string) bool {</code></span>
<span class="codeline" id="line-973"><code>	if s == "" {</code></span>
<span class="codeline" id="line-974"><code>		return false</code></span>
<span class="codeline" id="line-975"><code>	}</code></span>
<span class="codeline" id="line-976"><code>	for _, c := range s {</code></span>
<span class="codeline" id="line-977"><code>		switch {</code></span>
<span class="codeline" id="line-978"><code>		case strings.ContainsRune("!#$%&amp;()*+-./:;&lt;=&gt;?@[]^_{|}~ ", c):</code></span>
<span class="codeline" id="line-979"><code>			// Backslash and quote chars are reserved, but</code></span>
<span class="codeline" id="line-980"><code>			// otherwise any punctuation chars are allowed</code></span>
<span class="codeline" id="line-981"><code>			// in a tag name.</code></span>
<span class="codeline" id="line-982"><code>		case !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c):</code></span>
<span class="codeline" id="line-983"><code>			return false</code></span>
<span class="codeline" id="line-984"><code>		}</code></span>
<span class="codeline" id="line-985"><code>	}</code></span>
<span class="codeline" id="line-986"><code>	return true</code></span>
<span class="codeline" id="line-987"><code>}</code></span>
<span class="codeline" id="line-988"><code></code></span>
<span class="codeline" id="line-989"><code>func typeByIndex(t reflect.Type, index []int) reflect.Type {</code></span>
<span class="codeline" id="line-990"><code>	for _, i := range index {</code></span>
<span class="codeline" id="line-991"><code>		if t.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-992"><code>			t = t.Elem()</code></span>
<span class="codeline" id="line-993"><code>		}</code></span>
<span class="codeline" id="line-994"><code>		t = t.Field(i).Type</code></span>
<span class="codeline" id="line-995"><code>	}</code></span>
<span class="codeline" id="line-996"><code>	return t</code></span>
<span class="codeline" id="line-997"><code>}</code></span>
<span class="codeline" id="line-998"><code></code></span>
<span class="codeline" id="line-999"><code>type reflectWithString struct {</code></span>
<span class="codeline" id="line-1000"><code>	v reflect.Value</code></span>
<span class="codeline" id="line-1001"><code>	s string</code></span>
<span class="codeline" id="line-1002"><code>}</code></span>
<span class="codeline" id="line-1003"><code></code></span>
<span class="codeline" id="line-1004"><code>func (w *reflectWithString) resolve() error {</code></span>
<span class="codeline" id="line-1005"><code>	if w.v.Kind() == reflect.String {</code></span>
<span class="codeline" id="line-1006"><code>		w.s = w.v.String()</code></span>
<span class="codeline" id="line-1007"><code>		return nil</code></span>
<span class="codeline" id="line-1008"><code>	}</code></span>
<span class="codeline" id="line-1009"><code>	if tm, ok := w.v.Interface().(encoding.TextMarshaler); ok {</code></span>
<span class="codeline" id="line-1010"><code>		if w.v.Kind() == reflect.Ptr &amp;&amp; w.v.IsNil() {</code></span>
<span class="codeline" id="line-1011"><code>			return nil</code></span>
<span class="codeline" id="line-1012"><code>		}</code></span>
<span class="codeline" id="line-1013"><code>		buf, err := tm.MarshalText()</code></span>
<span class="codeline" id="line-1014"><code>		w.s = string(buf)</code></span>
<span class="codeline" id="line-1015"><code>		return err</code></span>
<span class="codeline" id="line-1016"><code>	}</code></span>
<span class="codeline" id="line-1017"><code>	switch w.v.Kind() {</code></span>
<span class="codeline" id="line-1018"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-1019"><code>		w.s = strconv.FormatInt(w.v.Int(), 10)</code></span>
<span class="codeline" id="line-1020"><code>		return nil</code></span>
<span class="codeline" id="line-1021"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-1022"><code>		w.s = strconv.FormatUint(w.v.Uint(), 10)</code></span>
<span class="codeline" id="line-1023"><code>		return nil</code></span>
<span class="codeline" id="line-1024"><code>	}</code></span>
<span class="codeline" id="line-1025"><code>	panic("unexpected map key type")</code></span>
<span class="codeline" id="line-1026"><code>}</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>// NOTE: keep in sync with stringBytes below.</code></span>
<span class="codeline" id="line-1029"><code>func (e *encodeState) string(s string, escapeHTML bool) {</code></span>
<span class="codeline" id="line-1030"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-1031"><code>	start := 0</code></span>
<span class="codeline" id="line-1032"><code>	for i := 0; i &lt; len(s); {</code></span>
<span class="codeline" id="line-1033"><code>		if b := s[i]; b &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1034"><code>			if htmlSafeSet[b] || (!escapeHTML &amp;&amp; safeSet[b]) {</code></span>
<span class="codeline" id="line-1035"><code>				i++</code></span>
<span class="codeline" id="line-1036"><code>				continue</code></span>
<span class="codeline" id="line-1037"><code>			}</code></span>
<span class="codeline" id="line-1038"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1039"><code>				e.WriteString(s[start:i])</code></span>
<span class="codeline" id="line-1040"><code>			}</code></span>
<span class="codeline" id="line-1041"><code>			e.WriteByte('\\')</code></span>
<span class="codeline" id="line-1042"><code>			switch b {</code></span>
<span class="codeline" id="line-1043"><code>			case '\\', '"':</code></span>
<span class="codeline" id="line-1044"><code>				e.WriteByte(b)</code></span>
<span class="codeline" id="line-1045"><code>			case '\n':</code></span>
<span class="codeline" id="line-1046"><code>				e.WriteByte('n')</code></span>
<span class="codeline" id="line-1047"><code>			case '\r':</code></span>
<span class="codeline" id="line-1048"><code>				e.WriteByte('r')</code></span>
<span class="codeline" id="line-1049"><code>			case '\t':</code></span>
<span class="codeline" id="line-1050"><code>				e.WriteByte('t')</code></span>
<span class="codeline" id="line-1051"><code>			default:</code></span>
<span class="codeline" id="line-1052"><code>				// This encodes bytes &lt; 0x20 except for \t, \n and \r.</code></span>
<span class="codeline" id="line-1053"><code>				// If escapeHTML is set, it also escapes &lt;, &gt;, and &amp;</code></span>
<span class="codeline" id="line-1054"><code>				// because they can lead to security holes when</code></span>
<span class="codeline" id="line-1055"><code>				// user-controlled strings are rendered into JSON</code></span>
<span class="codeline" id="line-1056"><code>				// and served to some browsers.</code></span>
<span class="codeline" id="line-1057"><code>				e.WriteString(`u00`)</code></span>
<span class="codeline" id="line-1058"><code>				e.WriteByte(hex[b&gt;&gt;4])</code></span>
<span class="codeline" id="line-1059"><code>				e.WriteByte(hex[b&amp;0xF])</code></span>
<span class="codeline" id="line-1060"><code>			}</code></span>
<span class="codeline" id="line-1061"><code>			i++</code></span>
<span class="codeline" id="line-1062"><code>			start = i</code></span>
<span class="codeline" id="line-1063"><code>			continue</code></span>
<span class="codeline" id="line-1064"><code>		}</code></span>
<span class="codeline" id="line-1065"><code>		c, size := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-1066"><code>		if c == utf8.RuneError &amp;&amp; size == 1 {</code></span>
<span class="codeline" id="line-1067"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1068"><code>				e.WriteString(s[start:i])</code></span>
<span class="codeline" id="line-1069"><code>			}</code></span>
<span class="codeline" id="line-1070"><code>			e.WriteString(`\ufffd`)</code></span>
<span class="codeline" id="line-1071"><code>			i += size</code></span>
<span class="codeline" id="line-1072"><code>			start = i</code></span>
<span class="codeline" id="line-1073"><code>			continue</code></span>
<span class="codeline" id="line-1074"><code>		}</code></span>
<span class="codeline" id="line-1075"><code>		// U+2028 is LINE SEPARATOR.</code></span>
<span class="codeline" id="line-1076"><code>		// U+2029 is PARAGRAPH SEPARATOR.</code></span>
<span class="codeline" id="line-1077"><code>		// They are both technically valid characters in JSON strings,</code></span>
<span class="codeline" id="line-1078"><code>		// but don't work in JSONP, which has to be evaluated as JavaScript,</code></span>
<span class="codeline" id="line-1079"><code>		// and can lead to security holes there. It is valid JSON to</code></span>
<span class="codeline" id="line-1080"><code>		// escape them, so we do so unconditionally.</code></span>
<span class="codeline" id="line-1081"><code>		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.</code></span>
<span class="codeline" id="line-1082"><code>		if c == '\u2028' || c == '\u2029' {</code></span>
<span class="codeline" id="line-1083"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1084"><code>				e.WriteString(s[start:i])</code></span>
<span class="codeline" id="line-1085"><code>			}</code></span>
<span class="codeline" id="line-1086"><code>			e.WriteString(`\u202`)</code></span>
<span class="codeline" id="line-1087"><code>			e.WriteByte(hex[c&amp;0xF])</code></span>
<span class="codeline" id="line-1088"><code>			i += size</code></span>
<span class="codeline" id="line-1089"><code>			start = i</code></span>
<span class="codeline" id="line-1090"><code>			continue</code></span>
<span class="codeline" id="line-1091"><code>		}</code></span>
<span class="codeline" id="line-1092"><code>		i += size</code></span>
<span class="codeline" id="line-1093"><code>	}</code></span>
<span class="codeline" id="line-1094"><code>	if start &lt; len(s) {</code></span>
<span class="codeline" id="line-1095"><code>		e.WriteString(s[start:])</code></span>
<span class="codeline" id="line-1096"><code>	}</code></span>
<span class="codeline" id="line-1097"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-1098"><code>}</code></span>
<span class="codeline" id="line-1099"><code></code></span>
<span class="codeline" id="line-1100"><code>// NOTE: keep in sync with string above.</code></span>
<span class="codeline" id="line-1101"><code>func (e *encodeState) stringBytes(s []byte, escapeHTML bool) {</code></span>
<span class="codeline" id="line-1102"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-1103"><code>	start := 0</code></span>
<span class="codeline" id="line-1104"><code>	for i := 0; i &lt; len(s); {</code></span>
<span class="codeline" id="line-1105"><code>		if b := s[i]; b &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1106"><code>			if htmlSafeSet[b] || (!escapeHTML &amp;&amp; safeSet[b]) {</code></span>
<span class="codeline" id="line-1107"><code>				i++</code></span>
<span class="codeline" id="line-1108"><code>				continue</code></span>
<span class="codeline" id="line-1109"><code>			}</code></span>
<span class="codeline" id="line-1110"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1111"><code>				e.Write(s[start:i])</code></span>
<span class="codeline" id="line-1112"><code>			}</code></span>
<span class="codeline" id="line-1113"><code>			e.WriteByte('\\')</code></span>
<span class="codeline" id="line-1114"><code>			switch b {</code></span>
<span class="codeline" id="line-1115"><code>			case '\\', '"':</code></span>
<span class="codeline" id="line-1116"><code>				e.WriteByte(b)</code></span>
<span class="codeline" id="line-1117"><code>			case '\n':</code></span>
<span class="codeline" id="line-1118"><code>				e.WriteByte('n')</code></span>
<span class="codeline" id="line-1119"><code>			case '\r':</code></span>
<span class="codeline" id="line-1120"><code>				e.WriteByte('r')</code></span>
<span class="codeline" id="line-1121"><code>			case '\t':</code></span>
<span class="codeline" id="line-1122"><code>				e.WriteByte('t')</code></span>
<span class="codeline" id="line-1123"><code>			default:</code></span>
<span class="codeline" id="line-1124"><code>				// This encodes bytes &lt; 0x20 except for \t, \n and \r.</code></span>
<span class="codeline" id="line-1125"><code>				// If escapeHTML is set, it also escapes &lt;, &gt;, and &amp;</code></span>
<span class="codeline" id="line-1126"><code>				// because they can lead to security holes when</code></span>
<span class="codeline" id="line-1127"><code>				// user-controlled strings are rendered into JSON</code></span>
<span class="codeline" id="line-1128"><code>				// and served to some browsers.</code></span>
<span class="codeline" id="line-1129"><code>				e.WriteString(`u00`)</code></span>
<span class="codeline" id="line-1130"><code>				e.WriteByte(hex[b&gt;&gt;4])</code></span>
<span class="codeline" id="line-1131"><code>				e.WriteByte(hex[b&amp;0xF])</code></span>
<span class="codeline" id="line-1132"><code>			}</code></span>
<span class="codeline" id="line-1133"><code>			i++</code></span>
<span class="codeline" id="line-1134"><code>			start = i</code></span>
<span class="codeline" id="line-1135"><code>			continue</code></span>
<span class="codeline" id="line-1136"><code>		}</code></span>
<span class="codeline" id="line-1137"><code>		c, size := utf8.DecodeRune(s[i:])</code></span>
<span class="codeline" id="line-1138"><code>		if c == utf8.RuneError &amp;&amp; size == 1 {</code></span>
<span class="codeline" id="line-1139"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1140"><code>				e.Write(s[start:i])</code></span>
<span class="codeline" id="line-1141"><code>			}</code></span>
<span class="codeline" id="line-1142"><code>			e.WriteString(`\ufffd`)</code></span>
<span class="codeline" id="line-1143"><code>			i += size</code></span>
<span class="codeline" id="line-1144"><code>			start = i</code></span>
<span class="codeline" id="line-1145"><code>			continue</code></span>
<span class="codeline" id="line-1146"><code>		}</code></span>
<span class="codeline" id="line-1147"><code>		// U+2028 is LINE SEPARATOR.</code></span>
<span class="codeline" id="line-1148"><code>		// U+2029 is PARAGRAPH SEPARATOR.</code></span>
<span class="codeline" id="line-1149"><code>		// They are both technically valid characters in JSON strings,</code></span>
<span class="codeline" id="line-1150"><code>		// but don't work in JSONP, which has to be evaluated as JavaScript,</code></span>
<span class="codeline" id="line-1151"><code>		// and can lead to security holes there. It is valid JSON to</code></span>
<span class="codeline" id="line-1152"><code>		// escape them, so we do so unconditionally.</code></span>
<span class="codeline" id="line-1153"><code>		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.</code></span>
<span class="codeline" id="line-1154"><code>		if c == '\u2028' || c == '\u2029' {</code></span>
<span class="codeline" id="line-1155"><code>			if start &lt; i {</code></span>
<span class="codeline" id="line-1156"><code>				e.Write(s[start:i])</code></span>
<span class="codeline" id="line-1157"><code>			}</code></span>
<span class="codeline" id="line-1158"><code>			e.WriteString(`\u202`)</code></span>
<span class="codeline" id="line-1159"><code>			e.WriteByte(hex[c&amp;0xF])</code></span>
<span class="codeline" id="line-1160"><code>			i += size</code></span>
<span class="codeline" id="line-1161"><code>			start = i</code></span>
<span class="codeline" id="line-1162"><code>			continue</code></span>
<span class="codeline" id="line-1163"><code>		}</code></span>
<span class="codeline" id="line-1164"><code>		i += size</code></span>
<span class="codeline" id="line-1165"><code>	}</code></span>
<span class="codeline" id="line-1166"><code>	if start &lt; len(s) {</code></span>
<span class="codeline" id="line-1167"><code>		e.Write(s[start:])</code></span>
<span class="codeline" id="line-1168"><code>	}</code></span>
<span class="codeline" id="line-1169"><code>	e.WriteByte('"')</code></span>
<span class="codeline" id="line-1170"><code>}</code></span>
<span class="codeline" id="line-1171"><code></code></span>
<span class="codeline" id="line-1172"><code>// A field represents a single field found in a struct.</code></span>
<span class="codeline" id="line-1173"><code>type field struct {</code></span>
<span class="codeline" id="line-1174"><code>	name      string</code></span>
<span class="codeline" id="line-1175"><code>	nameBytes []byte                 // []byte(name)</code></span>
<span class="codeline" id="line-1176"><code>	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>	nameNonEsc  string // `"` + name + `":`</code></span>
<span class="codeline" id="line-1179"><code>	nameEscHTML string // `"` + HTMLEscape(name) + `":`</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>	tag       bool</code></span>
<span class="codeline" id="line-1182"><code>	index     []int</code></span>
<span class="codeline" id="line-1183"><code>	typ       reflect.Type</code></span>
<span class="codeline" id="line-1184"><code>	omitEmpty bool</code></span>
<span class="codeline" id="line-1185"><code>	quoted    bool</code></span>
<span class="codeline" id="line-1186"><code></code></span>
<span class="codeline" id="line-1187"><code>	encoder encoderFunc</code></span>
<span class="codeline" id="line-1188"><code>}</code></span>
<span class="codeline" id="line-1189"><code></code></span>
<span class="codeline" id="line-1190"><code>// byIndex sorts field by index sequence.</code></span>
<span class="codeline" id="line-1191"><code>type byIndex []field</code></span>
<span class="codeline" id="line-1192"><code></code></span>
<span class="codeline" id="line-1193"><code>func (x byIndex) Len() int { return len(x) }</code></span>
<span class="codeline" id="line-1194"><code></code></span>
<span class="codeline" id="line-1195"><code>func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>func (x byIndex) Less(i, j int) bool {</code></span>
<span class="codeline" id="line-1198"><code>	for k, xik := range x[i].index {</code></span>
<span class="codeline" id="line-1199"><code>		if k &gt;= len(x[j].index) {</code></span>
<span class="codeline" id="line-1200"><code>			return false</code></span>
<span class="codeline" id="line-1201"><code>		}</code></span>
<span class="codeline" id="line-1202"><code>		if xik != x[j].index[k] {</code></span>
<span class="codeline" id="line-1203"><code>			return xik &lt; x[j].index[k]</code></span>
<span class="codeline" id="line-1204"><code>		}</code></span>
<span class="codeline" id="line-1205"><code>	}</code></span>
<span class="codeline" id="line-1206"><code>	return len(x[i].index) &lt; len(x[j].index)</code></span>
<span class="codeline" id="line-1207"><code>}</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>// typeFields returns a list of fields that JSON should recognize for the given type.</code></span>
<span class="codeline" id="line-1210"><code>// The algorithm is breadth-first search over the set of structs to include - the top struct</code></span>
<span class="codeline" id="line-1211"><code>// and then any reachable anonymous structs.</code></span>
<span class="codeline" id="line-1212"><code>func typeFields(t reflect.Type) structFields {</code></span>
<span class="codeline" id="line-1213"><code>	// Anonymous fields to explore at the current level and the next.</code></span>
<span class="codeline" id="line-1214"><code>	current := []field{}</code></span>
<span class="codeline" id="line-1215"><code>	next := []field{{typ: t}}</code></span>
<span class="codeline" id="line-1216"><code></code></span>
<span class="codeline" id="line-1217"><code>	// Count of queued names for current level and the next.</code></span>
<span class="codeline" id="line-1218"><code>	var count, nextCount map[reflect.Type]int</code></span>
<span class="codeline" id="line-1219"><code></code></span>
<span class="codeline" id="line-1220"><code>	// Types already visited at an earlier level.</code></span>
<span class="codeline" id="line-1221"><code>	visited := map[reflect.Type]bool{}</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>	// Fields found.</code></span>
<span class="codeline" id="line-1224"><code>	var fields []field</code></span>
<span class="codeline" id="line-1225"><code></code></span>
<span class="codeline" id="line-1226"><code>	// Buffer to run HTMLEscape on field names.</code></span>
<span class="codeline" id="line-1227"><code>	var nameEscBuf bytes.Buffer</code></span>
<span class="codeline" id="line-1228"><code></code></span>
<span class="codeline" id="line-1229"><code>	for len(next) &gt; 0 {</code></span>
<span class="codeline" id="line-1230"><code>		current, next = next, current[:0]</code></span>
<span class="codeline" id="line-1231"><code>		count, nextCount = nextCount, map[reflect.Type]int{}</code></span>
<span class="codeline" id="line-1232"><code></code></span>
<span class="codeline" id="line-1233"><code>		for _, f := range current {</code></span>
<span class="codeline" id="line-1234"><code>			if visited[f.typ] {</code></span>
<span class="codeline" id="line-1235"><code>				continue</code></span>
<span class="codeline" id="line-1236"><code>			}</code></span>
<span class="codeline" id="line-1237"><code>			visited[f.typ] = true</code></span>
<span class="codeline" id="line-1238"><code></code></span>
<span class="codeline" id="line-1239"><code>			// Scan f.typ for fields to include.</code></span>
<span class="codeline" id="line-1240"><code>			for i := 0; i &lt; f.typ.NumField(); i++ {</code></span>
<span class="codeline" id="line-1241"><code>				sf := f.typ.Field(i)</code></span>
<span class="codeline" id="line-1242"><code>				isUnexported := sf.PkgPath != ""</code></span>
<span class="codeline" id="line-1243"><code>				if sf.Anonymous {</code></span>
<span class="codeline" id="line-1244"><code>					t := sf.Type</code></span>
<span class="codeline" id="line-1245"><code>					if t.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-1246"><code>						t = t.Elem()</code></span>
<span class="codeline" id="line-1247"><code>					}</code></span>
<span class="codeline" id="line-1248"><code>					if isUnexported &amp;&amp; t.Kind() != reflect.Struct {</code></span>
<span class="codeline" id="line-1249"><code>						// Ignore embedded fields of unexported non-struct types.</code></span>
<span class="codeline" id="line-1250"><code>						continue</code></span>
<span class="codeline" id="line-1251"><code>					}</code></span>
<span class="codeline" id="line-1252"><code>					// Do not ignore embedded fields of unexported struct types</code></span>
<span class="codeline" id="line-1253"><code>					// since they may have exported fields.</code></span>
<span class="codeline" id="line-1254"><code>				} else if isUnexported {</code></span>
<span class="codeline" id="line-1255"><code>					// Ignore unexported non-embedded fields.</code></span>
<span class="codeline" id="line-1256"><code>					continue</code></span>
<span class="codeline" id="line-1257"><code>				}</code></span>
<span class="codeline" id="line-1258"><code>				tag := sf.Tag.Get("json")</code></span>
<span class="codeline" id="line-1259"><code>				if tag == "-" {</code></span>
<span class="codeline" id="line-1260"><code>					continue</code></span>
<span class="codeline" id="line-1261"><code>				}</code></span>
<span class="codeline" id="line-1262"><code>				name, opts := parseTag(tag)</code></span>
<span class="codeline" id="line-1263"><code>				if !isValidTag(name) {</code></span>
<span class="codeline" id="line-1264"><code>					name = ""</code></span>
<span class="codeline" id="line-1265"><code>				}</code></span>
<span class="codeline" id="line-1266"><code>				index := make([]int, len(f.index)+1)</code></span>
<span class="codeline" id="line-1267"><code>				copy(index, f.index)</code></span>
<span class="codeline" id="line-1268"><code>				index[len(f.index)] = i</code></span>
<span class="codeline" id="line-1269"><code></code></span>
<span class="codeline" id="line-1270"><code>				ft := sf.Type</code></span>
<span class="codeline" id="line-1271"><code>				if ft.Name() == "" &amp;&amp; ft.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-1272"><code>					// Follow pointer.</code></span>
<span class="codeline" id="line-1273"><code>					ft = ft.Elem()</code></span>
<span class="codeline" id="line-1274"><code>				}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>				// Only strings, floats, integers, and booleans can be quoted.</code></span>
<span class="codeline" id="line-1277"><code>				quoted := false</code></span>
<span class="codeline" id="line-1278"><code>				if opts.Contains("string") {</code></span>
<span class="codeline" id="line-1279"><code>					switch ft.Kind() {</code></span>
<span class="codeline" id="line-1280"><code>					case reflect.Bool,</code></span>
<span class="codeline" id="line-1281"><code>						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-1282"><code>						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,</code></span>
<span class="codeline" id="line-1283"><code>						reflect.Float32, reflect.Float64,</code></span>
<span class="codeline" id="line-1284"><code>						reflect.String:</code></span>
<span class="codeline" id="line-1285"><code>						quoted = true</code></span>
<span class="codeline" id="line-1286"><code>					}</code></span>
<span class="codeline" id="line-1287"><code>				}</code></span>
<span class="codeline" id="line-1288"><code></code></span>
<span class="codeline" id="line-1289"><code>				// Record found field and index sequence.</code></span>
<span class="codeline" id="line-1290"><code>				if name != "" || !sf.Anonymous || ft.Kind() != reflect.Struct {</code></span>
<span class="codeline" id="line-1291"><code>					tagged := name != ""</code></span>
<span class="codeline" id="line-1292"><code>					if name == "" {</code></span>
<span class="codeline" id="line-1293"><code>						name = sf.Name</code></span>
<span class="codeline" id="line-1294"><code>					}</code></span>
<span class="codeline" id="line-1295"><code>					field := field{</code></span>
<span class="codeline" id="line-1296"><code>						name:      name,</code></span>
<span class="codeline" id="line-1297"><code>						tag:       tagged,</code></span>
<span class="codeline" id="line-1298"><code>						index:     index,</code></span>
<span class="codeline" id="line-1299"><code>						typ:       ft,</code></span>
<span class="codeline" id="line-1300"><code>						omitEmpty: opts.Contains("omitempty"),</code></span>
<span class="codeline" id="line-1301"><code>						quoted:    quoted,</code></span>
<span class="codeline" id="line-1302"><code>					}</code></span>
<span class="codeline" id="line-1303"><code>					field.nameBytes = []byte(field.name)</code></span>
<span class="codeline" id="line-1304"><code>					field.equalFold = foldFunc(field.nameBytes)</code></span>
<span class="codeline" id="line-1305"><code></code></span>
<span class="codeline" id="line-1306"><code>					// Build nameEscHTML and nameNonEsc ahead of time.</code></span>
<span class="codeline" id="line-1307"><code>					nameEscBuf.Reset()</code></span>
<span class="codeline" id="line-1308"><code>					nameEscBuf.WriteString(`"`)</code></span>
<span class="codeline" id="line-1309"><code>					HTMLEscape(&amp;nameEscBuf, field.nameBytes)</code></span>
<span class="codeline" id="line-1310"><code>					nameEscBuf.WriteString(`":`)</code></span>
<span class="codeline" id="line-1311"><code>					field.nameEscHTML = nameEscBuf.String()</code></span>
<span class="codeline" id="line-1312"><code>					field.nameNonEsc = `"` + field.name + `":`</code></span>
<span class="codeline" id="line-1313"><code></code></span>
<span class="codeline" id="line-1314"><code>					fields = append(fields, field)</code></span>
<span class="codeline" id="line-1315"><code>					if count[f.typ] &gt; 1 {</code></span>
<span class="codeline" id="line-1316"><code>						// If there were multiple instances, add a second,</code></span>
<span class="codeline" id="line-1317"><code>						// so that the annihilation code will see a duplicate.</code></span>
<span class="codeline" id="line-1318"><code>						// It only cares about the distinction between 1 or 2,</code></span>
<span class="codeline" id="line-1319"><code>						// so don't bother generating any more copies.</code></span>
<span class="codeline" id="line-1320"><code>						fields = append(fields, fields[len(fields)-1])</code></span>
<span class="codeline" id="line-1321"><code>					}</code></span>
<span class="codeline" id="line-1322"><code>					continue</code></span>
<span class="codeline" id="line-1323"><code>				}</code></span>
<span class="codeline" id="line-1324"><code></code></span>
<span class="codeline" id="line-1325"><code>				// Record new anonymous struct to explore in next round.</code></span>
<span class="codeline" id="line-1326"><code>				nextCount[ft]++</code></span>
<span class="codeline" id="line-1327"><code>				if nextCount[ft] == 1 {</code></span>
<span class="codeline" id="line-1328"><code>					next = append(next, field{name: ft.Name(), index: index, typ: ft})</code></span>
<span class="codeline" id="line-1329"><code>				}</code></span>
<span class="codeline" id="line-1330"><code>			}</code></span>
<span class="codeline" id="line-1331"><code>		}</code></span>
<span class="codeline" id="line-1332"><code>	}</code></span>
<span class="codeline" id="line-1333"><code></code></span>
<span class="codeline" id="line-1334"><code>	sort.Slice(fields, func(i, j int) bool {</code></span>
<span class="codeline" id="line-1335"><code>		x := fields</code></span>
<span class="codeline" id="line-1336"><code>		// sort field by name, breaking ties with depth, then</code></span>
<span class="codeline" id="line-1337"><code>		// breaking ties with "name came from json tag", then</code></span>
<span class="codeline" id="line-1338"><code>		// breaking ties with index sequence.</code></span>
<span class="codeline" id="line-1339"><code>		if x[i].name != x[j].name {</code></span>
<span class="codeline" id="line-1340"><code>			return x[i].name &lt; x[j].name</code></span>
<span class="codeline" id="line-1341"><code>		}</code></span>
<span class="codeline" id="line-1342"><code>		if len(x[i].index) != len(x[j].index) {</code></span>
<span class="codeline" id="line-1343"><code>			return len(x[i].index) &lt; len(x[j].index)</code></span>
<span class="codeline" id="line-1344"><code>		}</code></span>
<span class="codeline" id="line-1345"><code>		if x[i].tag != x[j].tag {</code></span>
<span class="codeline" id="line-1346"><code>			return x[i].tag</code></span>
<span class="codeline" id="line-1347"><code>		}</code></span>
<span class="codeline" id="line-1348"><code>		return byIndex(x).Less(i, j)</code></span>
<span class="codeline" id="line-1349"><code>	})</code></span>
<span class="codeline" id="line-1350"><code></code></span>
<span class="codeline" id="line-1351"><code>	// Delete all fields that are hidden by the Go rules for embedded fields,</code></span>
<span class="codeline" id="line-1352"><code>	// except that fields with JSON tags are promoted.</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>	// The fields are sorted in primary order of name, secondary order</code></span>
<span class="codeline" id="line-1355"><code>	// of field index length. Loop over names; for each name, delete</code></span>
<span class="codeline" id="line-1356"><code>	// hidden fields by choosing the one dominant field that survives.</code></span>
<span class="codeline" id="line-1357"><code>	out := fields[:0]</code></span>
<span class="codeline" id="line-1358"><code>	for advance, i := 0, 0; i &lt; len(fields); i += advance {</code></span>
<span class="codeline" id="line-1359"><code>		// One iteration per name.</code></span>
<span class="codeline" id="line-1360"><code>		// Find the sequence of fields with the name of this first field.</code></span>
<span class="codeline" id="line-1361"><code>		fi := fields[i]</code></span>
<span class="codeline" id="line-1362"><code>		name := fi.name</code></span>
<span class="codeline" id="line-1363"><code>		for advance = 1; i+advance &lt; len(fields); advance++ {</code></span>
<span class="codeline" id="line-1364"><code>			fj := fields[i+advance]</code></span>
<span class="codeline" id="line-1365"><code>			if fj.name != name {</code></span>
<span class="codeline" id="line-1366"><code>				break</code></span>
<span class="codeline" id="line-1367"><code>			}</code></span>
<span class="codeline" id="line-1368"><code>		}</code></span>
<span class="codeline" id="line-1369"><code>		if advance == 1 { // Only one field with this name</code></span>
<span class="codeline" id="line-1370"><code>			out = append(out, fi)</code></span>
<span class="codeline" id="line-1371"><code>			continue</code></span>
<span class="codeline" id="line-1372"><code>		}</code></span>
<span class="codeline" id="line-1373"><code>		dominant, ok := dominantField(fields[i : i+advance])</code></span>
<span class="codeline" id="line-1374"><code>		if ok {</code></span>
<span class="codeline" id="line-1375"><code>			out = append(out, dominant)</code></span>
<span class="codeline" id="line-1376"><code>		}</code></span>
<span class="codeline" id="line-1377"><code>	}</code></span>
<span class="codeline" id="line-1378"><code></code></span>
<span class="codeline" id="line-1379"><code>	fields = out</code></span>
<span class="codeline" id="line-1380"><code>	sort.Sort(byIndex(fields))</code></span>
<span class="codeline" id="line-1381"><code></code></span>
<span class="codeline" id="line-1382"><code>	for i := range fields {</code></span>
<span class="codeline" id="line-1383"><code>		f := &amp;fields[i]</code></span>
<span class="codeline" id="line-1384"><code>		f.encoder = typeEncoder(typeByIndex(t, f.index))</code></span>
<span class="codeline" id="line-1385"><code>	}</code></span>
<span class="codeline" id="line-1386"><code>	nameIndex := make(map[string]int, len(fields))</code></span>
<span class="codeline" id="line-1387"><code>	for i, field := range fields {</code></span>
<span class="codeline" id="line-1388"><code>		nameIndex[field.name] = i</code></span>
<span class="codeline" id="line-1389"><code>	}</code></span>
<span class="codeline" id="line-1390"><code>	return structFields{fields, nameIndex}</code></span>
<span class="codeline" id="line-1391"><code>}</code></span>
<span class="codeline" id="line-1392"><code></code></span>
<span class="codeline" id="line-1393"><code>// dominantField looks through the fields, all of which are known to</code></span>
<span class="codeline" id="line-1394"><code>// have the same name, to find the single field that dominates the</code></span>
<span class="codeline" id="line-1395"><code>// others using Go's embedding rules, modified by the presence of</code></span>
<span class="codeline" id="line-1396"><code>// JSON tags. If there are multiple top-level fields, the boolean</code></span>
<span class="codeline" id="line-1397"><code>// will be false: This condition is an error in Go and we skip all</code></span>
<span class="codeline" id="line-1398"><code>// the fields.</code></span>
<span class="codeline" id="line-1399"><code>func dominantField(fields []field) (field, bool) {</code></span>
<span class="codeline" id="line-1400"><code>	// The fields are sorted in increasing index-length order, then by presence of tag.</code></span>
<span class="codeline" id="line-1401"><code>	// That means that the first field is the dominant one. We need only check</code></span>
<span class="codeline" id="line-1402"><code>	// for error cases: two fields at top level, either both tagged or neither tagged.</code></span>
<span class="codeline" id="line-1403"><code>	if len(fields) &gt; 1 &amp;&amp; len(fields[0].index) == len(fields[1].index) &amp;&amp; fields[0].tag == fields[1].tag {</code></span>
<span class="codeline" id="line-1404"><code>		return field{}, false</code></span>
<span class="codeline" id="line-1405"><code>	}</code></span>
<span class="codeline" id="line-1406"><code>	return fields[0], true</code></span>
<span class="codeline" id="line-1407"><code>}</code></span>
<span class="codeline" id="line-1408"><code></code></span>
<span class="codeline" id="line-1409"><code>var fieldCache sync.Map // map[reflect.Type]structFields</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.</code></span>
<span class="codeline" id="line-1412"><code>func cachedTypeFields(t reflect.Type) structFields {</code></span>
<span class="codeline" id="line-1413"><code>	if f, ok := fieldCache.Load(t); ok {</code></span>
<span class="codeline" id="line-1414"><code>		return f.(structFields)</code></span>
<span class="codeline" id="line-1415"><code>	}</code></span>
<span class="codeline" id="line-1416"><code>	f, _ := fieldCache.LoadOrStore(t, typeFields(t))</code></span>
<span class="codeline" id="line-1417"><code>	return f.(structFields)</code></span>
<span class="codeline" id="line-1418"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>