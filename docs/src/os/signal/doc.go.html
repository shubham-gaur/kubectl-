<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package os/signal</title>
<link href="../../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/os/signal.html">os/signal</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2015 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>Package signal implements access to incoming signals.</code></span>
<span class="codeline" id="line-7"><code></code></span>
<span class="codeline" id="line-8"><code>Signals are primarily used on Unix-like systems. For the use of this</code></span>
<span class="codeline" id="line-9"><code>package on Windows and Plan 9, see below.</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>Types of signals</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>The signals SIGKILL and SIGSTOP may not be caught by a program, and</code></span>
<span class="codeline" id="line-14"><code>therefore cannot be affected by this package.</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>Synchronous signals are signals triggered by errors in program</code></span>
<span class="codeline" id="line-17"><code>execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered</code></span>
<span class="codeline" id="line-18"><code>synchronous when caused by program execution, not when sent using</code></span>
<span class="codeline" id="line-19"><code>os.Process.Kill or the kill program or some similar mechanism. In</code></span>
<span class="codeline" id="line-20"><code>general, except as discussed below, Go programs will convert a</code></span>
<span class="codeline" id="line-21"><code>synchronous signal into a run-time panic.</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>The remaining signals are asynchronous signals. They are not</code></span>
<span class="codeline" id="line-24"><code>triggered by program errors, but are instead sent from the kernel or</code></span>
<span class="codeline" id="line-25"><code>from some other program.</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>Of the asynchronous signals, the SIGHUP signal is sent when a program</code></span>
<span class="codeline" id="line-28"><code>loses its controlling terminal. The SIGINT signal is sent when the</code></span>
<span class="codeline" id="line-29"><code>user at the controlling terminal presses the interrupt character,</code></span>
<span class="codeline" id="line-30"><code>which by default is ^C (Control-C). The SIGQUIT signal is sent when</code></span>
<span class="codeline" id="line-31"><code>the user at the controlling terminal presses the quit character, which</code></span>
<span class="codeline" id="line-32"><code>by default is ^\ (Control-Backslash). In general you can cause a</code></span>
<span class="codeline" id="line-33"><code>program to simply exit by pressing ^C, and you can cause it to exit</code></span>
<span class="codeline" id="line-34"><code>with a stack dump by pressing ^\.</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>Default behavior of signals in Go programs</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>By default, a synchronous signal is converted into a run-time panic. A</code></span>
<span class="codeline" id="line-39"><code>SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A</code></span>
<span class="codeline" id="line-40"><code>SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal</code></span>
<span class="codeline" id="line-41"><code>causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or</code></span>
<span class="codeline" id="line-42"><code>SIGTTOU signal gets the system default behavior (these signals are</code></span>
<span class="codeline" id="line-43"><code>used by the shell for job control). The SIGPROF signal is handled</code></span>
<span class="codeline" id="line-44"><code>directly by the Go runtime to implement runtime.CPUProfile. Other</code></span>
<span class="codeline" id="line-45"><code>signals will be caught but no action will be taken.</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code>If the Go program is started with either SIGHUP or SIGINT ignored</code></span>
<span class="codeline" id="line-48"><code>(signal handler set to SIG_IGN), they will remain ignored.</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>If the Go program is started with a non-empty signal mask, that will</code></span>
<span class="codeline" id="line-51"><code>generally be honored. However, some signals are explicitly unblocked:</code></span>
<span class="codeline" id="line-52"><code>the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF,</code></span>
<span class="codeline" id="line-53"><code>and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID)</code></span>
<span class="codeline" id="line-54"><code>(SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses</code></span>
<span class="codeline" id="line-55"><code>started by os.Exec, or by the os/exec package, will inherit the</code></span>
<span class="codeline" id="line-56"><code>modified signal mask.</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>Changing the behavior of signals in Go programs</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>The functions in this package allow a program to change the way Go</code></span>
<span class="codeline" id="line-61"><code>programs handle signals.</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>Notify disables the default behavior for a given set of asynchronous</code></span>
<span class="codeline" id="line-64"><code>signals and instead delivers them over one or more registered</code></span>
<span class="codeline" id="line-65"><code>channels. Specifically, it applies to the signals SIGHUP, SIGINT,</code></span>
<span class="codeline" id="line-66"><code>SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control</code></span>
<span class="codeline" id="line-67"><code>signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system</code></span>
<span class="codeline" id="line-68"><code>default behavior does not occur. It also applies to some signals that</code></span>
<span class="codeline" id="line-69"><code>otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM,</code></span>
<span class="codeline" id="line-70"><code>SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH,</code></span>
<span class="codeline" id="line-71"><code>SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE,</code></span>
<span class="codeline" id="line-72"><code>SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals</code></span>
<span class="codeline" id="line-73"><code>used on the system. Note that not all of these signals are available</code></span>
<span class="codeline" id="line-74"><code>on all systems.</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>If the program was started with SIGHUP or SIGINT ignored, and Notify</code></span>
<span class="codeline" id="line-77"><code>is called for either signal, a signal handler will be installed for</code></span>
<span class="codeline" id="line-78"><code>that signal and it will no longer be ignored. If, later, Reset or</code></span>
<span class="codeline" id="line-79"><code>Ignore is called for that signal, or Stop is called on all channels</code></span>
<span class="codeline" id="line-80"><code>passed to Notify for that signal, the signal will once again be</code></span>
<span class="codeline" id="line-81"><code>ignored. Reset will restore the system default behavior for the</code></span>
<span class="codeline" id="line-82"><code>signal, while Ignore will cause the system to ignore the signal</code></span>
<span class="codeline" id="line-83"><code>entirely.</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>If the program is started with a non-empty signal mask, some signals</code></span>
<span class="codeline" id="line-86"><code>will be explicitly unblocked as described above. If Notify is called</code></span>
<span class="codeline" id="line-87"><code>for a blocked signal, it will be unblocked. If, later, Reset is</code></span>
<span class="codeline" id="line-88"><code>called for that signal, or Stop is called on all channels passed to</code></span>
<span class="codeline" id="line-89"><code>Notify for that signal, the signal will once again be blocked.</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>SIGPIPE</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>When a Go program writes to a broken pipe, the kernel will raise a</code></span>
<span class="codeline" id="line-94"><code>SIGPIPE signal.</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>If the program has not called Notify to receive SIGPIPE signals, then</code></span>
<span class="codeline" id="line-97"><code>the behavior depends on the file descriptor number. A write to a</code></span>
<span class="codeline" id="line-98"><code>broken pipe on file descriptors 1 or 2 (standard output or standard</code></span>
<span class="codeline" id="line-99"><code>error) will cause the program to exit with a SIGPIPE signal. A write</code></span>
<span class="codeline" id="line-100"><code>to a broken pipe on some other file descriptor will take no action on</code></span>
<span class="codeline" id="line-101"><code>the SIGPIPE signal, and the write will fail with an EPIPE error.</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>If the program has called Notify to receive SIGPIPE signals, the file</code></span>
<span class="codeline" id="line-104"><code>descriptor number does not matter. The SIGPIPE signal will be</code></span>
<span class="codeline" id="line-105"><code>delivered to the Notify channel, and the write will fail with an EPIPE</code></span>
<span class="codeline" id="line-106"><code>error.</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>This means that, by default, command line programs will behave like</code></span>
<span class="codeline" id="line-109"><code>typical Unix command line programs, while other programs will not</code></span>
<span class="codeline" id="line-110"><code>crash with SIGPIPE when writing to a closed network connection.</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>Go programs that use cgo or SWIG</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>In a Go program that includes non-Go code, typically C/C++ code</code></span>
<span class="codeline" id="line-115"><code>accessed using cgo or SWIG, Go's startup code normally runs first. It</code></span>
<span class="codeline" id="line-116"><code>configures the signal handlers as expected by the Go runtime, before</code></span>
<span class="codeline" id="line-117"><code>the non-Go startup code runs. If the non-Go startup code wishes to</code></span>
<span class="codeline" id="line-118"><code>install its own signal handlers, it must take certain steps to keep Go</code></span>
<span class="codeline" id="line-119"><code>working well. This section documents those steps and the overall</code></span>
<span class="codeline" id="line-120"><code>effect changes to signal handler settings by the non-Go code can have</code></span>
<span class="codeline" id="line-121"><code>on Go programs. In rare cases, the non-Go code may run before the Go</code></span>
<span class="codeline" id="line-122"><code>code, in which case the next section also applies.</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>If the non-Go code called by the Go program does not change any signal</code></span>
<span class="codeline" id="line-125"><code>handlers or masks, then the behavior is the same as for a pure Go</code></span>
<span class="codeline" id="line-126"><code>program.</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>If the non-Go code installs any signal handlers, it must use the</code></span>
<span class="codeline" id="line-129"><code>SA_ONSTACK flag with sigaction. Failing to do so is likely to cause</code></span>
<span class="codeline" id="line-130"><code>the program to crash if the signal is received. Go programs routinely</code></span>
<span class="codeline" id="line-131"><code>run with a limited stack, and therefore set up an alternate signal</code></span>
<span class="codeline" id="line-132"><code>stack. Also, the Go standard library expects that any signal handlers</code></span>
<span class="codeline" id="line-133"><code>will use the SA_RESTART flag. Failing to do so may cause some library</code></span>
<span class="codeline" id="line-134"><code>calls to return "interrupted system call" errors.</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>If the non-Go code installs a signal handler for any of the</code></span>
<span class="codeline" id="line-137"><code>synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record</code></span>
<span class="codeline" id="line-138"><code>the existing Go signal handler. If those signals occur while</code></span>
<span class="codeline" id="line-139"><code>executing Go code, it should invoke the Go signal handler (whether the</code></span>
<span class="codeline" id="line-140"><code>signal occurs while executing Go code can be determined by looking at</code></span>
<span class="codeline" id="line-141"><code>the PC passed to the signal handler). Otherwise some Go run-time</code></span>
<span class="codeline" id="line-142"><code>panics will not occur as expected.</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>If the non-Go code installs a signal handler for any of the</code></span>
<span class="codeline" id="line-145"><code>asynchronous signals, it may invoke the Go signal handler or not as it</code></span>
<span class="codeline" id="line-146"><code>chooses. Naturally, if it does not invoke the Go signal handler, the</code></span>
<span class="codeline" id="line-147"><code>Go behavior described above will not occur. This can be an issue with</code></span>
<span class="codeline" id="line-148"><code>the SIGPROF signal in particular.</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>The non-Go code should not change the signal mask on any threads</code></span>
<span class="codeline" id="line-151"><code>created by the Go runtime. If the non-Go code starts new threads of</code></span>
<span class="codeline" id="line-152"><code>its own, it may set the signal mask as it pleases.</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>If the non-Go code starts a new thread, changes the signal mask, and</code></span>
<span class="codeline" id="line-155"><code>then invokes a Go function in that thread, the Go runtime will</code></span>
<span class="codeline" id="line-156"><code>automatically unblock certain signals: the synchronous signals,</code></span>
<span class="codeline" id="line-157"><code>SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and</code></span>
<span class="codeline" id="line-158"><code>SIGSETXID. When the Go function returns, the non-Go signal mask will</code></span>
<span class="codeline" id="line-159"><code>be restored.</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>If the Go signal handler is invoked on a non-Go thread not running Go</code></span>
<span class="codeline" id="line-162"><code>code, the handler generally forwards the signal to the non-Go code, as</code></span>
<span class="codeline" id="line-163"><code>follows. If the signal is SIGPROF, the Go handler does</code></span>
<span class="codeline" id="line-164"><code>nothing. Otherwise, the Go handler removes itself, unblocks the</code></span>
<span class="codeline" id="line-165"><code>signal, and raises it again, to invoke any non-Go handler or default</code></span>
<span class="codeline" id="line-166"><code>system handler. If the program does not exit, the Go handler then</code></span>
<span class="codeline" id="line-167"><code>reinstalls itself and continues execution of the program.</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>Non-Go programs that call Go code</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>When Go code is built with options like -buildmode=c-shared, it will</code></span>
<span class="codeline" id="line-172"><code>be run as part of an existing non-Go program. The non-Go code may</code></span>
<span class="codeline" id="line-173"><code>have already installed signal handlers when the Go code starts (that</code></span>
<span class="codeline" id="line-174"><code>may also happen in unusual cases when using cgo or SWIG; in that case,</code></span>
<span class="codeline" id="line-175"><code>the discussion here applies).  For -buildmode=c-archive the Go runtime</code></span>
<span class="codeline" id="line-176"><code>will initialize signals at global constructor time.  For</code></span>
<span class="codeline" id="line-177"><code>-buildmode=c-shared the Go runtime will initialize signals when the</code></span>
<span class="codeline" id="line-178"><code>shared library is loaded.</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>If the Go runtime sees an existing signal handler for the SIGCANCEL or</code></span>
<span class="codeline" id="line-181"><code>SIGSETXID signals (which are used only on GNU/Linux), it will turn on</code></span>
<span class="codeline" id="line-182"><code>the SA_ONSTACK flag and otherwise keep the signal handler.</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>For the synchronous signals and SIGPIPE, the Go runtime will install a</code></span>
<span class="codeline" id="line-185"><code>signal handler. It will save any existing signal handler. If a</code></span>
<span class="codeline" id="line-186"><code>synchronous signal arrives while executing non-Go code, the Go runtime</code></span>
<span class="codeline" id="line-187"><code>will invoke the existing signal handler instead of the Go signal</code></span>
<span class="codeline" id="line-188"><code>handler.</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>Go code built with -buildmode=c-archive or -buildmode=c-shared will</code></span>
<span class="codeline" id="line-191"><code>not install any other signal handlers by default. If there is an</code></span>
<span class="codeline" id="line-192"><code>existing signal handler, the Go runtime will turn on the SA_ONSTACK</code></span>
<span class="codeline" id="line-193"><code>flag and otherwise keep the signal handler. If Notify is called for an</code></span>
<span class="codeline" id="line-194"><code>asynchronous signal, a Go signal handler will be installed for that</code></span>
<span class="codeline" id="line-195"><code>signal. If, later, Reset is called for that signal, the original</code></span>
<span class="codeline" id="line-196"><code>handling for that signal will be reinstalled, restoring the non-Go</code></span>
<span class="codeline" id="line-197"><code>signal handler if any.</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>Go code built without -buildmode=c-archive or -buildmode=c-shared will</code></span>
<span class="codeline" id="line-200"><code>install a signal handler for the asynchronous signals listed above,</code></span>
<span class="codeline" id="line-201"><code>and save any existing signal handler. If a signal is delivered to a</code></span>
<span class="codeline" id="line-202"><code>non-Go thread, it will act as described above, except that if there is</code></span>
<span class="codeline" id="line-203"><code>an existing non-Go signal handler, that handler will be installed</code></span>
<span class="codeline" id="line-204"><code>before raising the signal.</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>Windows</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause</code></span>
<span class="codeline" id="line-209"><code>the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK</code></span>
<span class="codeline" id="line-210"><code>will cause os.Interrupt to be sent on the channel, and the program will</code></span>
<span class="codeline" id="line-211"><code>not exit. If Reset is called, or Stop is called on all channels passed</code></span>
<span class="codeline" id="line-212"><code>to Notify, then the default behavior will be restored.</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>Additionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT,</code></span>
<span class="codeline" id="line-215"><code>CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will</code></span>
<span class="codeline" id="line-216"><code>return syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does</code></span>
<span class="codeline" id="line-217"><code>not change process behavior when either CTRL_CLOSE_EVENT,</code></span>
<span class="codeline" id="line-218"><code>CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT is received - the process will</code></span>
<span class="codeline" id="line-219"><code>still get terminated unless it exits. But receiving syscall.SIGTERM will</code></span>
<span class="codeline" id="line-220"><code>give the process an opportunity to clean up before termination.</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>Plan 9</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>On Plan 9, signals have type syscall.Note, which is a string. Calling</code></span>
<span class="codeline" id="line-225"><code>Notify with a syscall.Note will cause that value to be sent on the</code></span>
<span class="codeline" id="line-226"><code>channel when that string is posted as a note.</code></span>
<span class="codeline" id="line-227"><code></code></span>
<span class="codeline" id="line-228"><code>*/</code></span></div><span class="codeline" id="line-229"><code>package signal</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>