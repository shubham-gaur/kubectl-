<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: exec.go in package os/exec</title>
<link href="../../../css/light-v0.3.2.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	exec.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/os/exec.html">os/exec</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package exec runs external commands. It wraps os.StartProcess to make it</code></span>
<span class="codeline" id="line-6"><code>// easier to remap stdin and stdout, connect I/O with pipes, and do other</code></span>
<span class="codeline" id="line-7"><code>// adjustments.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// Unlike the "system" library call from C and other languages, the</code></span>
<span class="codeline" id="line-10"><code>// os/exec package intentionally does not invoke the system shell and</code></span>
<span class="codeline" id="line-11"><code>// does not expand any glob patterns or handle other expansions,</code></span>
<span class="codeline" id="line-12"><code>// pipelines, or redirections typically done by shells. The package</code></span>
<span class="codeline" id="line-13"><code>// behaves more like C's "exec" family of functions. To expand glob</code></span>
<span class="codeline" id="line-14"><code>// patterns, either call the shell directly, taking care to escape any</code></span>
<span class="codeline" id="line-15"><code>// dangerous input, or use the path/filepath package's Glob function.</code></span>
<span class="codeline" id="line-16"><code>// To expand environment variables, use package os's ExpandEnv.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// Note that the examples in this package assume a Unix system.</code></span>
<span class="codeline" id="line-19"><code>// They may not run on Windows, and they do not run in the Go Playground</code></span>
<span class="codeline" id="line-20"><code>// used by golang.org and godoc.org.</code></span></div><span class="codeline" id="line-21"><code>package exec</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>import (</code></span>
<span class="codeline" id="line-24"><code>	"bytes"</code></span>
<span class="codeline" id="line-25"><code>	"context"</code></span>
<span class="codeline" id="line-26"><code>	"errors"</code></span>
<span class="codeline" id="line-27"><code>	"internal/syscall/execenv"</code></span>
<span class="codeline" id="line-28"><code>	"io"</code></span>
<span class="codeline" id="line-29"><code>	"os"</code></span>
<span class="codeline" id="line-30"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-31"><code>	"runtime"</code></span>
<span class="codeline" id="line-32"><code>	"strconv"</code></span>
<span class="codeline" id="line-33"><code>	"strings"</code></span>
<span class="codeline" id="line-34"><code>	"sync"</code></span>
<span class="codeline" id="line-35"><code>	"syscall"</code></span>
<span class="codeline" id="line-36"><code>)</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>// Error is returned by LookPath when it fails to classify a file as an</code></span>
<span class="codeline" id="line-39"><code>// executable.</code></span>
<span class="codeline" id="line-40"><code>type Error struct {</code></span>
<span class="codeline" id="line-41"><code>	// Name is the file name for which the error occurred.</code></span>
<span class="codeline" id="line-42"><code>	Name string</code></span>
<span class="codeline" id="line-43"><code>	// Err is the underlying error.</code></span>
<span class="codeline" id="line-44"><code>	Err error</code></span>
<span class="codeline" id="line-45"><code>}</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code>func (e *Error) Error() string {</code></span>
<span class="codeline" id="line-48"><code>	return "exec: " + strconv.Quote(e.Name) + ": " + e.Err.Error()</code></span>
<span class="codeline" id="line-49"><code>}</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>func (e *Error) Unwrap() error { return e.Err }</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>// Cmd represents an external command being prepared or run.</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// A Cmd cannot be reused after calling its Run, Output or CombinedOutput</code></span>
<span class="codeline" id="line-56"><code>// methods.</code></span>
<span class="codeline" id="line-57"><code>type Cmd struct {</code></span>
<span class="codeline" id="line-58"><code>	// Path is the path of the command to run.</code></span>
<span class="codeline" id="line-59"><code>	//</code></span>
<span class="codeline" id="line-60"><code>	// This is the only field that must be set to a non-zero</code></span>
<span class="codeline" id="line-61"><code>	// value. If Path is relative, it is evaluated relative</code></span>
<span class="codeline" id="line-62"><code>	// to Dir.</code></span>
<span class="codeline" id="line-63"><code>	Path string</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>	// Args holds command line arguments, including the command as Args[0].</code></span>
<span class="codeline" id="line-66"><code>	// If the Args field is empty or nil, Run uses {Path}.</code></span>
<span class="codeline" id="line-67"><code>	//</code></span>
<span class="codeline" id="line-68"><code>	// In typical use, both Path and Args are set by calling Command.</code></span>
<span class="codeline" id="line-69"><code>	Args []string</code></span>
<span class="codeline" id="line-70"><code></code></span>
<span class="codeline" id="line-71"><code>	// Env specifies the environment of the process.</code></span>
<span class="codeline" id="line-72"><code>	// Each entry is of the form "key=value".</code></span>
<span class="codeline" id="line-73"><code>	// If Env is nil, the new process uses the current process's</code></span>
<span class="codeline" id="line-74"><code>	// environment.</code></span>
<span class="codeline" id="line-75"><code>	// If Env contains duplicate environment keys, only the last</code></span>
<span class="codeline" id="line-76"><code>	// value in the slice for each duplicate key is used.</code></span>
<span class="codeline" id="line-77"><code>	// As a special case on Windows, SYSTEMROOT is always added if</code></span>
<span class="codeline" id="line-78"><code>	// missing and not explicitly set to the empty string.</code></span>
<span class="codeline" id="line-79"><code>	Env []string</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>	// Dir specifies the working directory of the command.</code></span>
<span class="codeline" id="line-82"><code>	// If Dir is the empty string, Run runs the command in the</code></span>
<span class="codeline" id="line-83"><code>	// calling process's current directory.</code></span>
<span class="codeline" id="line-84"><code>	Dir string</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>	// Stdin specifies the process's standard input.</code></span>
<span class="codeline" id="line-87"><code>	//</code></span>
<span class="codeline" id="line-88"><code>	// If Stdin is nil, the process reads from the null device (os.DevNull).</code></span>
<span class="codeline" id="line-89"><code>	//</code></span>
<span class="codeline" id="line-90"><code>	// If Stdin is an *os.File, the process's standard input is connected</code></span>
<span class="codeline" id="line-91"><code>	// directly to that file.</code></span>
<span class="codeline" id="line-92"><code>	//</code></span>
<span class="codeline" id="line-93"><code>	// Otherwise, during the execution of the command a separate</code></span>
<span class="codeline" id="line-94"><code>	// goroutine reads from Stdin and delivers that data to the command</code></span>
<span class="codeline" id="line-95"><code>	// over a pipe. In this case, Wait does not complete until the goroutine</code></span>
<span class="codeline" id="line-96"><code>	// stops copying, either because it has reached the end of Stdin</code></span>
<span class="codeline" id="line-97"><code>	// (EOF or a read error) or because writing to the pipe returned an error.</code></span>
<span class="codeline" id="line-98"><code>	Stdin io.Reader</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>	// Stdout and Stderr specify the process's standard output and error.</code></span>
<span class="codeline" id="line-101"><code>	//</code></span>
<span class="codeline" id="line-102"><code>	// If either is nil, Run connects the corresponding file descriptor</code></span>
<span class="codeline" id="line-103"><code>	// to the null device (os.DevNull).</code></span>
<span class="codeline" id="line-104"><code>	//</code></span>
<span class="codeline" id="line-105"><code>	// If either is an *os.File, the corresponding output from the process</code></span>
<span class="codeline" id="line-106"><code>	// is connected directly to that file.</code></span>
<span class="codeline" id="line-107"><code>	//</code></span>
<span class="codeline" id="line-108"><code>	// Otherwise, during the execution of the command a separate goroutine</code></span>
<span class="codeline" id="line-109"><code>	// reads from the process over a pipe and delivers that data to the</code></span>
<span class="codeline" id="line-110"><code>	// corresponding Writer. In this case, Wait does not complete until the</code></span>
<span class="codeline" id="line-111"><code>	// goroutine reaches EOF or encounters an error.</code></span>
<span class="codeline" id="line-112"><code>	//</code></span>
<span class="codeline" id="line-113"><code>	// If Stdout and Stderr are the same writer, and have a type that can</code></span>
<span class="codeline" id="line-114"><code>	// be compared with ==, at most one goroutine at a time will call Write.</code></span>
<span class="codeline" id="line-115"><code>	Stdout io.Writer</code></span>
<span class="codeline" id="line-116"><code>	Stderr io.Writer</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>	// ExtraFiles specifies additional open files to be inherited by the</code></span>
<span class="codeline" id="line-119"><code>	// new process. It does not include standard input, standard output, or</code></span>
<span class="codeline" id="line-120"><code>	// standard error. If non-nil, entry i becomes file descriptor 3+i.</code></span>
<span class="codeline" id="line-121"><code>	//</code></span>
<span class="codeline" id="line-122"><code>	// ExtraFiles is not supported on Windows.</code></span>
<span class="codeline" id="line-123"><code>	ExtraFiles []*os.File</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>	// SysProcAttr holds optional, operating system-specific attributes.</code></span>
<span class="codeline" id="line-126"><code>	// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.</code></span>
<span class="codeline" id="line-127"><code>	SysProcAttr *syscall.SysProcAttr</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>	// Process is the underlying process, once started.</code></span>
<span class="codeline" id="line-130"><code>	Process *os.Process</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>	// ProcessState contains information about an exited process,</code></span>
<span class="codeline" id="line-133"><code>	// available after a call to Wait or Run.</code></span>
<span class="codeline" id="line-134"><code>	ProcessState *os.ProcessState</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>	ctx             context.Context // nil means none</code></span>
<span class="codeline" id="line-137"><code>	lookPathErr     error           // LookPath error, if any.</code></span>
<span class="codeline" id="line-138"><code>	finished        bool            // when Wait was called</code></span>
<span class="codeline" id="line-139"><code>	childFiles      []*os.File</code></span>
<span class="codeline" id="line-140"><code>	closeAfterStart []io.Closer</code></span>
<span class="codeline" id="line-141"><code>	closeAfterWait  []io.Closer</code></span>
<span class="codeline" id="line-142"><code>	goroutine       []func() error</code></span>
<span class="codeline" id="line-143"><code>	errch           chan error // one send per goroutine</code></span>
<span class="codeline" id="line-144"><code>	waitDone        chan struct{}</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// Command returns the Cmd struct to execute the named program with</code></span>
<span class="codeline" id="line-148"><code>// the given arguments.</code></span>
<span class="codeline" id="line-149"><code>//</code></span>
<span class="codeline" id="line-150"><code>// It sets only the Path and Args in the returned structure.</code></span>
<span class="codeline" id="line-151"><code>//</code></span>
<span class="codeline" id="line-152"><code>// If name contains no path separators, Command uses LookPath to</code></span>
<span class="codeline" id="line-153"><code>// resolve name to a complete path if possible. Otherwise it uses name</code></span>
<span class="codeline" id="line-154"><code>// directly as Path.</code></span>
<span class="codeline" id="line-155"><code>//</code></span>
<span class="codeline" id="line-156"><code>// The returned Cmd's Args field is constructed from the command name</code></span>
<span class="codeline" id="line-157"><code>// followed by the elements of arg, so arg should not include the</code></span>
<span class="codeline" id="line-158"><code>// command name itself. For example, Command("echo", "hello").</code></span>
<span class="codeline" id="line-159"><code>// Args[0] is always name, not the possibly resolved Path.</code></span>
<span class="codeline" id="line-160"><code>//</code></span>
<span class="codeline" id="line-161"><code>// On Windows, processes receive the whole command line as a single string</code></span>
<span class="codeline" id="line-162"><code>// and do their own parsing. Command combines and quotes Args into a command</code></span>
<span class="codeline" id="line-163"><code>// line string with an algorithm compatible with applications using</code></span>
<span class="codeline" id="line-164"><code>// CommandLineToArgvW (which is the most common way). Notable exceptions are</code></span>
<span class="codeline" id="line-165"><code>// msiexec.exe and cmd.exe (and thus, all batch files), which have a different</code></span>
<span class="codeline" id="line-166"><code>// unquoting algorithm. In these or other similar cases, you can do the</code></span>
<span class="codeline" id="line-167"><code>// quoting yourself and provide the full command line in SysProcAttr.CmdLine,</code></span>
<span class="codeline" id="line-168"><code>// leaving Args empty.</code></span>
<span class="codeline" id="line-169"><code>func Command(name string, arg ...string) *Cmd {</code></span>
<span class="codeline" id="line-170"><code>	cmd := &amp;Cmd{</code></span>
<span class="codeline" id="line-171"><code>		Path: name,</code></span>
<span class="codeline" id="line-172"><code>		Args: append([]string{name}, arg...),</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code>	if filepath.Base(name) == name {</code></span>
<span class="codeline" id="line-175"><code>		if lp, err := LookPath(name); err != nil {</code></span>
<span class="codeline" id="line-176"><code>			cmd.lookPathErr = err</code></span>
<span class="codeline" id="line-177"><code>		} else {</code></span>
<span class="codeline" id="line-178"><code>			cmd.Path = lp</code></span>
<span class="codeline" id="line-179"><code>		}</code></span>
<span class="codeline" id="line-180"><code>	}</code></span>
<span class="codeline" id="line-181"><code>	return cmd</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>// CommandContext is like Command but includes a context.</code></span>
<span class="codeline" id="line-185"><code>//</code></span>
<span class="codeline" id="line-186"><code>// The provided context is used to kill the process (by calling</code></span>
<span class="codeline" id="line-187"><code>// os.Process.Kill) if the context becomes done before the command</code></span>
<span class="codeline" id="line-188"><code>// completes on its own.</code></span>
<span class="codeline" id="line-189"><code>func CommandContext(ctx context.Context, name string, arg ...string) *Cmd {</code></span>
<span class="codeline" id="line-190"><code>	if ctx == nil {</code></span>
<span class="codeline" id="line-191"><code>		panic("nil Context")</code></span>
<span class="codeline" id="line-192"><code>	}</code></span>
<span class="codeline" id="line-193"><code>	cmd := Command(name, arg...)</code></span>
<span class="codeline" id="line-194"><code>	cmd.ctx = ctx</code></span>
<span class="codeline" id="line-195"><code>	return cmd</code></span>
<span class="codeline" id="line-196"><code>}</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>// String returns a human-readable description of c.</code></span>
<span class="codeline" id="line-199"><code>// It is intended only for debugging.</code></span>
<span class="codeline" id="line-200"><code>// In particular, it is not suitable for use as input to a shell.</code></span>
<span class="codeline" id="line-201"><code>// The output of String may vary across Go releases.</code></span>
<span class="codeline" id="line-202"><code>func (c *Cmd) String() string {</code></span>
<span class="codeline" id="line-203"><code>	if c.lookPathErr != nil {</code></span>
<span class="codeline" id="line-204"><code>		// failed to resolve path; report the original requested path (plus args)</code></span>
<span class="codeline" id="line-205"><code>		return strings.Join(c.Args, " ")</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	// report the exact executable path (plus args)</code></span>
<span class="codeline" id="line-208"><code>	b := new(strings.Builder)</code></span>
<span class="codeline" id="line-209"><code>	b.WriteString(c.Path)</code></span>
<span class="codeline" id="line-210"><code>	for _, a := range c.Args[1:] {</code></span>
<span class="codeline" id="line-211"><code>		b.WriteByte(' ')</code></span>
<span class="codeline" id="line-212"><code>		b.WriteString(a)</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code>	return b.String()</code></span>
<span class="codeline" id="line-215"><code>}</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>// interfaceEqual protects against panics from doing equality tests on</code></span>
<span class="codeline" id="line-218"><code>// two interfaces with non-comparable underlying types.</code></span>
<span class="codeline" id="line-219"><code>func interfaceEqual(a, b interface{}) bool {</code></span>
<span class="codeline" id="line-220"><code>	defer func() {</code></span>
<span class="codeline" id="line-221"><code>		recover()</code></span>
<span class="codeline" id="line-222"><code>	}()</code></span>
<span class="codeline" id="line-223"><code>	return a == b</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>func (c *Cmd) envv() ([]string, error) {</code></span>
<span class="codeline" id="line-227"><code>	if c.Env != nil {</code></span>
<span class="codeline" id="line-228"><code>		return c.Env, nil</code></span>
<span class="codeline" id="line-229"><code>	}</code></span>
<span class="codeline" id="line-230"><code>	return execenv.Default(c.SysProcAttr)</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>func (c *Cmd) argv() []string {</code></span>
<span class="codeline" id="line-234"><code>	if len(c.Args) &gt; 0 {</code></span>
<span class="codeline" id="line-235"><code>		return c.Args</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	return []string{c.Path}</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// skipStdinCopyError optionally specifies a function which reports</code></span>
<span class="codeline" id="line-241"><code>// whether the provided stdin copy error should be ignored.</code></span>
<span class="codeline" id="line-242"><code>var skipStdinCopyError func(error) bool</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>func (c *Cmd) stdin() (f *os.File, err error) {</code></span>
<span class="codeline" id="line-245"><code>	if c.Stdin == nil {</code></span>
<span class="codeline" id="line-246"><code>		f, err = os.Open(os.DevNull)</code></span>
<span class="codeline" id="line-247"><code>		if err != nil {</code></span>
<span class="codeline" id="line-248"><code>			return</code></span>
<span class="codeline" id="line-249"><code>		}</code></span>
<span class="codeline" id="line-250"><code>		c.closeAfterStart = append(c.closeAfterStart, f)</code></span>
<span class="codeline" id="line-251"><code>		return</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>	if f, ok := c.Stdin.(*os.File); ok {</code></span>
<span class="codeline" id="line-255"><code>		return f, nil</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-259"><code>	if err != nil {</code></span>
<span class="codeline" id="line-260"><code>		return</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	c.closeAfterStart = append(c.closeAfterStart, pr)</code></span>
<span class="codeline" id="line-264"><code>	c.closeAfterWait = append(c.closeAfterWait, pw)</code></span>
<span class="codeline" id="line-265"><code>	c.goroutine = append(c.goroutine, func() error {</code></span>
<span class="codeline" id="line-266"><code>		_, err := io.Copy(pw, c.Stdin)</code></span>
<span class="codeline" id="line-267"><code>		if skip := skipStdinCopyError; skip != nil &amp;&amp; skip(err) {</code></span>
<span class="codeline" id="line-268"><code>			err = nil</code></span>
<span class="codeline" id="line-269"><code>		}</code></span>
<span class="codeline" id="line-270"><code>		if err1 := pw.Close(); err == nil {</code></span>
<span class="codeline" id="line-271"><code>			err = err1</code></span>
<span class="codeline" id="line-272"><code>		}</code></span>
<span class="codeline" id="line-273"><code>		return err</code></span>
<span class="codeline" id="line-274"><code>	})</code></span>
<span class="codeline" id="line-275"><code>	return pr, nil</code></span>
<span class="codeline" id="line-276"><code>}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>func (c *Cmd) stdout() (f *os.File, err error) {</code></span>
<span class="codeline" id="line-279"><code>	return c.writerDescriptor(c.Stdout)</code></span>
<span class="codeline" id="line-280"><code>}</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>func (c *Cmd) stderr() (f *os.File, err error) {</code></span>
<span class="codeline" id="line-283"><code>	if c.Stderr != nil &amp;&amp; interfaceEqual(c.Stderr, c.Stdout) {</code></span>
<span class="codeline" id="line-284"><code>		return c.childFiles[1], nil</code></span>
<span class="codeline" id="line-285"><code>	}</code></span>
<span class="codeline" id="line-286"><code>	return c.writerDescriptor(c.Stderr)</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {</code></span>
<span class="codeline" id="line-290"><code>	if w == nil {</code></span>
<span class="codeline" id="line-291"><code>		f, err = os.OpenFile(os.DevNull, os.O_WRONLY, 0)</code></span>
<span class="codeline" id="line-292"><code>		if err != nil {</code></span>
<span class="codeline" id="line-293"><code>			return</code></span>
<span class="codeline" id="line-294"><code>		}</code></span>
<span class="codeline" id="line-295"><code>		c.closeAfterStart = append(c.closeAfterStart, f)</code></span>
<span class="codeline" id="line-296"><code>		return</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>	if f, ok := w.(*os.File); ok {</code></span>
<span class="codeline" id="line-300"><code>		return f, nil</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-304"><code>	if err != nil {</code></span>
<span class="codeline" id="line-305"><code>		return</code></span>
<span class="codeline" id="line-306"><code>	}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>	c.closeAfterStart = append(c.closeAfterStart, pw)</code></span>
<span class="codeline" id="line-309"><code>	c.closeAfterWait = append(c.closeAfterWait, pr)</code></span>
<span class="codeline" id="line-310"><code>	c.goroutine = append(c.goroutine, func() error {</code></span>
<span class="codeline" id="line-311"><code>		_, err := io.Copy(w, pr)</code></span>
<span class="codeline" id="line-312"><code>		pr.Close() // in case io.Copy stopped due to write error</code></span>
<span class="codeline" id="line-313"><code>		return err</code></span>
<span class="codeline" id="line-314"><code>	})</code></span>
<span class="codeline" id="line-315"><code>	return pw, nil</code></span>
<span class="codeline" id="line-316"><code>}</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>func (c *Cmd) closeDescriptors(closers []io.Closer) {</code></span>
<span class="codeline" id="line-319"><code>	for _, fd := range closers {</code></span>
<span class="codeline" id="line-320"><code>		fd.Close()</code></span>
<span class="codeline" id="line-321"><code>	}</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// Run starts the specified command and waits for it to complete.</code></span>
<span class="codeline" id="line-325"><code>//</code></span>
<span class="codeline" id="line-326"><code>// The returned error is nil if the command runs, has no problems</code></span>
<span class="codeline" id="line-327"><code>// copying stdin, stdout, and stderr, and exits with a zero exit</code></span>
<span class="codeline" id="line-328"><code>// status.</code></span>
<span class="codeline" id="line-329"><code>//</code></span>
<span class="codeline" id="line-330"><code>// If the command starts but does not complete successfully, the error is of</code></span>
<span class="codeline" id="line-331"><code>// type *ExitError. Other error types may be returned for other situations.</code></span>
<span class="codeline" id="line-332"><code>//</code></span>
<span class="codeline" id="line-333"><code>// If the calling goroutine has locked the operating system thread</code></span>
<span class="codeline" id="line-334"><code>// with runtime.LockOSThread and modified any inheritable OS-level</code></span>
<span class="codeline" id="line-335"><code>// thread state (for example, Linux or Plan 9 name spaces), the new</code></span>
<span class="codeline" id="line-336"><code>// process will inherit the caller's thread state.</code></span>
<span class="codeline" id="line-337"><code>func (c *Cmd) Run() error {</code></span>
<span class="codeline" id="line-338"><code>	if err := c.Start(); err != nil {</code></span>
<span class="codeline" id="line-339"><code>		return err</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code>	return c.Wait()</code></span>
<span class="codeline" id="line-342"><code>}</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>// lookExtensions finds windows executable by its dir and path.</code></span>
<span class="codeline" id="line-345"><code>// It uses LookPath to try appropriate extensions.</code></span>
<span class="codeline" id="line-346"><code>// lookExtensions does not search PATH, instead it converts `prog` into `.\prog`.</code></span>
<span class="codeline" id="line-347"><code>func lookExtensions(path, dir string) (string, error) {</code></span>
<span class="codeline" id="line-348"><code>	if filepath.Base(path) == path {</code></span>
<span class="codeline" id="line-349"><code>		path = filepath.Join(".", path)</code></span>
<span class="codeline" id="line-350"><code>	}</code></span>
<span class="codeline" id="line-351"><code>	if dir == "" {</code></span>
<span class="codeline" id="line-352"><code>		return LookPath(path)</code></span>
<span class="codeline" id="line-353"><code>	}</code></span>
<span class="codeline" id="line-354"><code>	if filepath.VolumeName(path) != "" {</code></span>
<span class="codeline" id="line-355"><code>		return LookPath(path)</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code>	if len(path) &gt; 1 &amp;&amp; os.IsPathSeparator(path[0]) {</code></span>
<span class="codeline" id="line-358"><code>		return LookPath(path)</code></span>
<span class="codeline" id="line-359"><code>	}</code></span>
<span class="codeline" id="line-360"><code>	dirandpath := filepath.Join(dir, path)</code></span>
<span class="codeline" id="line-361"><code>	// We assume that LookPath will only add file extension.</code></span>
<span class="codeline" id="line-362"><code>	lp, err := LookPath(dirandpath)</code></span>
<span class="codeline" id="line-363"><code>	if err != nil {</code></span>
<span class="codeline" id="line-364"><code>		return "", err</code></span>
<span class="codeline" id="line-365"><code>	}</code></span>
<span class="codeline" id="line-366"><code>	ext := strings.TrimPrefix(lp, dirandpath)</code></span>
<span class="codeline" id="line-367"><code>	return path + ext, nil</code></span>
<span class="codeline" id="line-368"><code>}</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>// Start starts the specified command but does not wait for it to complete.</code></span>
<span class="codeline" id="line-371"><code>//</code></span>
<span class="codeline" id="line-372"><code>// If Start returns successfully, the c.Process field will be set.</code></span>
<span class="codeline" id="line-373"><code>//</code></span>
<span class="codeline" id="line-374"><code>// The Wait method will return the exit code and release associated resources</code></span>
<span class="codeline" id="line-375"><code>// once the command exits.</code></span>
<span class="codeline" id="line-376"><code>func (c *Cmd) Start() error {</code></span>
<span class="codeline" id="line-377"><code>	if c.lookPathErr != nil {</code></span>
<span class="codeline" id="line-378"><code>		c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-379"><code>		c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-380"><code>		return c.lookPathErr</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code>	if runtime.GOOS == "windows" {</code></span>
<span class="codeline" id="line-383"><code>		lp, err := lookExtensions(c.Path, c.Dir)</code></span>
<span class="codeline" id="line-384"><code>		if err != nil {</code></span>
<span class="codeline" id="line-385"><code>			c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-386"><code>			c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-387"><code>			return err</code></span>
<span class="codeline" id="line-388"><code>		}</code></span>
<span class="codeline" id="line-389"><code>		c.Path = lp</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-392"><code>		return errors.New("exec: already started")</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	if c.ctx != nil {</code></span>
<span class="codeline" id="line-395"><code>		select {</code></span>
<span class="codeline" id="line-396"><code>		case &lt;-c.ctx.Done():</code></span>
<span class="codeline" id="line-397"><code>			c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-398"><code>			c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-399"><code>			return c.ctx.Err()</code></span>
<span class="codeline" id="line-400"><code>		default:</code></span>
<span class="codeline" id="line-401"><code>		}</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>	c.childFiles = make([]*os.File, 0, 3+len(c.ExtraFiles))</code></span>
<span class="codeline" id="line-405"><code>	type F func(*Cmd) (*os.File, error)</code></span>
<span class="codeline" id="line-406"><code>	for _, setupFd := range []F{(*Cmd).stdin, (*Cmd).stdout, (*Cmd).stderr} {</code></span>
<span class="codeline" id="line-407"><code>		fd, err := setupFd(c)</code></span>
<span class="codeline" id="line-408"><code>		if err != nil {</code></span>
<span class="codeline" id="line-409"><code>			c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-410"><code>			c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-411"><code>			return err</code></span>
<span class="codeline" id="line-412"><code>		}</code></span>
<span class="codeline" id="line-413"><code>		c.childFiles = append(c.childFiles, fd)</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>	c.childFiles = append(c.childFiles, c.ExtraFiles...)</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	envv, err := c.envv()</code></span>
<span class="codeline" id="line-418"><code>	if err != nil {</code></span>
<span class="codeline" id="line-419"><code>		return err</code></span>
<span class="codeline" id="line-420"><code>	}</code></span>
<span class="codeline" id="line-421"><code></code></span>
<span class="codeline" id="line-422"><code>	c.Process, err = os.StartProcess(c.Path, c.argv(), &amp;os.ProcAttr{</code></span>
<span class="codeline" id="line-423"><code>		Dir:   c.Dir,</code></span>
<span class="codeline" id="line-424"><code>		Files: c.childFiles,</code></span>
<span class="codeline" id="line-425"><code>		Env:   addCriticalEnv(dedupEnv(envv)),</code></span>
<span class="codeline" id="line-426"><code>		Sys:   c.SysProcAttr,</code></span>
<span class="codeline" id="line-427"><code>	})</code></span>
<span class="codeline" id="line-428"><code>	if err != nil {</code></span>
<span class="codeline" id="line-429"><code>		c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-430"><code>		c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-431"><code>		return err</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>	c.closeDescriptors(c.closeAfterStart)</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>	// Don't allocate the channel unless there are goroutines to fire.</code></span>
<span class="codeline" id="line-437"><code>	if len(c.goroutine) &gt; 0 {</code></span>
<span class="codeline" id="line-438"><code>		c.errch = make(chan error, len(c.goroutine))</code></span>
<span class="codeline" id="line-439"><code>		for _, fn := range c.goroutine {</code></span>
<span class="codeline" id="line-440"><code>			go func(fn func() error) {</code></span>
<span class="codeline" id="line-441"><code>				c.errch &lt;- fn()</code></span>
<span class="codeline" id="line-442"><code>			}(fn)</code></span>
<span class="codeline" id="line-443"><code>		}</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>	if c.ctx != nil {</code></span>
<span class="codeline" id="line-447"><code>		c.waitDone = make(chan struct{})</code></span>
<span class="codeline" id="line-448"><code>		go func() {</code></span>
<span class="codeline" id="line-449"><code>			select {</code></span>
<span class="codeline" id="line-450"><code>			case &lt;-c.ctx.Done():</code></span>
<span class="codeline" id="line-451"><code>				c.Process.Kill()</code></span>
<span class="codeline" id="line-452"><code>			case &lt;-c.waitDone:</code></span>
<span class="codeline" id="line-453"><code>			}</code></span>
<span class="codeline" id="line-454"><code>		}()</code></span>
<span class="codeline" id="line-455"><code>	}</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>	return nil</code></span>
<span class="codeline" id="line-458"><code>}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>// An ExitError reports an unsuccessful exit by a command.</code></span>
<span class="codeline" id="line-461"><code>type ExitError struct {</code></span>
<span class="codeline" id="line-462"><code>	*os.ProcessState</code></span>
<span class="codeline" id="line-463"><code></code></span>
<span class="codeline" id="line-464"><code>	// Stderr holds a subset of the standard error output from the</code></span>
<span class="codeline" id="line-465"><code>	// Cmd.Output method if standard error was not otherwise being</code></span>
<span class="codeline" id="line-466"><code>	// collected.</code></span>
<span class="codeline" id="line-467"><code>	//</code></span>
<span class="codeline" id="line-468"><code>	// If the error output is long, Stderr may contain only a prefix</code></span>
<span class="codeline" id="line-469"><code>	// and suffix of the output, with the middle replaced with</code></span>
<span class="codeline" id="line-470"><code>	// text about the number of omitted bytes.</code></span>
<span class="codeline" id="line-471"><code>	//</code></span>
<span class="codeline" id="line-472"><code>	// Stderr is provided for debugging, for inclusion in error messages.</code></span>
<span class="codeline" id="line-473"><code>	// Users with other needs should redirect Cmd.Stderr as needed.</code></span>
<span class="codeline" id="line-474"><code>	Stderr []byte</code></span>
<span class="codeline" id="line-475"><code>}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>func (e *ExitError) Error() string {</code></span>
<span class="codeline" id="line-478"><code>	return e.ProcessState.String()</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// Wait waits for the command to exit and waits for any copying to</code></span>
<span class="codeline" id="line-482"><code>// stdin or copying from stdout or stderr to complete.</code></span>
<span class="codeline" id="line-483"><code>//</code></span>
<span class="codeline" id="line-484"><code>// The command must have been started by Start.</code></span>
<span class="codeline" id="line-485"><code>//</code></span>
<span class="codeline" id="line-486"><code>// The returned error is nil if the command runs, has no problems</code></span>
<span class="codeline" id="line-487"><code>// copying stdin, stdout, and stderr, and exits with a zero exit</code></span>
<span class="codeline" id="line-488"><code>// status.</code></span>
<span class="codeline" id="line-489"><code>//</code></span>
<span class="codeline" id="line-490"><code>// If the command fails to run or doesn't complete successfully, the</code></span>
<span class="codeline" id="line-491"><code>// error is of type *ExitError. Other error types may be</code></span>
<span class="codeline" id="line-492"><code>// returned for I/O problems.</code></span>
<span class="codeline" id="line-493"><code>//</code></span>
<span class="codeline" id="line-494"><code>// If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits</code></span>
<span class="codeline" id="line-495"><code>// for the respective I/O loop copying to or from the process to complete.</code></span>
<span class="codeline" id="line-496"><code>//</code></span>
<span class="codeline" id="line-497"><code>// Wait releases any resources associated with the Cmd.</code></span>
<span class="codeline" id="line-498"><code>func (c *Cmd) Wait() error {</code></span>
<span class="codeline" id="line-499"><code>	if c.Process == nil {</code></span>
<span class="codeline" id="line-500"><code>		return errors.New("exec: not started")</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code>	if c.finished {</code></span>
<span class="codeline" id="line-503"><code>		return errors.New("exec: Wait was already called")</code></span>
<span class="codeline" id="line-504"><code>	}</code></span>
<span class="codeline" id="line-505"><code>	c.finished = true</code></span>
<span class="codeline" id="line-506"><code></code></span>
<span class="codeline" id="line-507"><code>	state, err := c.Process.Wait()</code></span>
<span class="codeline" id="line-508"><code>	if c.waitDone != nil {</code></span>
<span class="codeline" id="line-509"><code>		close(c.waitDone)</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code>	c.ProcessState = state</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	var copyError error</code></span>
<span class="codeline" id="line-514"><code>	for range c.goroutine {</code></span>
<span class="codeline" id="line-515"><code>		if err := &lt;-c.errch; err != nil &amp;&amp; copyError == nil {</code></span>
<span class="codeline" id="line-516"><code>			copyError = err</code></span>
<span class="codeline" id="line-517"><code>		}</code></span>
<span class="codeline" id="line-518"><code>	}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>	c.closeDescriptors(c.closeAfterWait)</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>	if err != nil {</code></span>
<span class="codeline" id="line-523"><code>		return err</code></span>
<span class="codeline" id="line-524"><code>	} else if !state.Success() {</code></span>
<span class="codeline" id="line-525"><code>		return &amp;ExitError{ProcessState: state}</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>	return copyError</code></span>
<span class="codeline" id="line-529"><code>}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>// Output runs the command and returns its standard output.</code></span>
<span class="codeline" id="line-532"><code>// Any returned error will usually be of type *ExitError.</code></span>
<span class="codeline" id="line-533"><code>// If c.Stderr was nil, Output populates ExitError.Stderr.</code></span>
<span class="codeline" id="line-534"><code>func (c *Cmd) Output() ([]byte, error) {</code></span>
<span class="codeline" id="line-535"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-536"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-537"><code>	}</code></span>
<span class="codeline" id="line-538"><code>	var stdout bytes.Buffer</code></span>
<span class="codeline" id="line-539"><code>	c.Stdout = &amp;stdout</code></span>
<span class="codeline" id="line-540"><code></code></span>
<span class="codeline" id="line-541"><code>	captureErr := c.Stderr == nil</code></span>
<span class="codeline" id="line-542"><code>	if captureErr {</code></span>
<span class="codeline" id="line-543"><code>		c.Stderr = &amp;prefixSuffixSaver{N: 32 &lt;&lt; 10}</code></span>
<span class="codeline" id="line-544"><code>	}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>	err := c.Run()</code></span>
<span class="codeline" id="line-547"><code>	if err != nil &amp;&amp; captureErr {</code></span>
<span class="codeline" id="line-548"><code>		if ee, ok := err.(*ExitError); ok {</code></span>
<span class="codeline" id="line-549"><code>			ee.Stderr = c.Stderr.(*prefixSuffixSaver).Bytes()</code></span>
<span class="codeline" id="line-550"><code>		}</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code>	return stdout.Bytes(), err</code></span>
<span class="codeline" id="line-553"><code>}</code></span>
<span class="codeline" id="line-554"><code></code></span>
<span class="codeline" id="line-555"><code>// CombinedOutput runs the command and returns its combined standard</code></span>
<span class="codeline" id="line-556"><code>// output and standard error.</code></span>
<span class="codeline" id="line-557"><code>func (c *Cmd) CombinedOutput() ([]byte, error) {</code></span>
<span class="codeline" id="line-558"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-559"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-560"><code>	}</code></span>
<span class="codeline" id="line-561"><code>	if c.Stderr != nil {</code></span>
<span class="codeline" id="line-562"><code>		return nil, errors.New("exec: Stderr already set")</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code>	var b bytes.Buffer</code></span>
<span class="codeline" id="line-565"><code>	c.Stdout = &amp;b</code></span>
<span class="codeline" id="line-566"><code>	c.Stderr = &amp;b</code></span>
<span class="codeline" id="line-567"><code>	err := c.Run()</code></span>
<span class="codeline" id="line-568"><code>	return b.Bytes(), err</code></span>
<span class="codeline" id="line-569"><code>}</code></span>
<span class="codeline" id="line-570"><code></code></span>
<span class="codeline" id="line-571"><code>// StdinPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-572"><code>// standard input when the command starts.</code></span>
<span class="codeline" id="line-573"><code>// The pipe will be closed automatically after Wait sees the command exit.</code></span>
<span class="codeline" id="line-574"><code>// A caller need only call Close to force the pipe to close sooner.</code></span>
<span class="codeline" id="line-575"><code>// For example, if the command being run will not exit until standard input</code></span>
<span class="codeline" id="line-576"><code>// is closed, the caller must close the pipe.</code></span>
<span class="codeline" id="line-577"><code>func (c *Cmd) StdinPipe() (io.WriteCloser, error) {</code></span>
<span class="codeline" id="line-578"><code>	if c.Stdin != nil {</code></span>
<span class="codeline" id="line-579"><code>		return nil, errors.New("exec: Stdin already set")</code></span>
<span class="codeline" id="line-580"><code>	}</code></span>
<span class="codeline" id="line-581"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-582"><code>		return nil, errors.New("exec: StdinPipe after process started")</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-585"><code>	if err != nil {</code></span>
<span class="codeline" id="line-586"><code>		return nil, err</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code>	c.Stdin = pr</code></span>
<span class="codeline" id="line-589"><code>	c.closeAfterStart = append(c.closeAfterStart, pr)</code></span>
<span class="codeline" id="line-590"><code>	wc := &amp;closeOnce{File: pw}</code></span>
<span class="codeline" id="line-591"><code>	c.closeAfterWait = append(c.closeAfterWait, wc)</code></span>
<span class="codeline" id="line-592"><code>	return wc, nil</code></span>
<span class="codeline" id="line-593"><code>}</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>type closeOnce struct {</code></span>
<span class="codeline" id="line-596"><code>	*os.File</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>	once sync.Once</code></span>
<span class="codeline" id="line-599"><code>	err  error</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>func (c *closeOnce) Close() error {</code></span>
<span class="codeline" id="line-603"><code>	c.once.Do(c.close)</code></span>
<span class="codeline" id="line-604"><code>	return c.err</code></span>
<span class="codeline" id="line-605"><code>}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>func (c *closeOnce) close() {</code></span>
<span class="codeline" id="line-608"><code>	c.err = c.File.Close()</code></span>
<span class="codeline" id="line-609"><code>}</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>// StdoutPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-612"><code>// standard output when the command starts.</code></span>
<span class="codeline" id="line-613"><code>//</code></span>
<span class="codeline" id="line-614"><code>// Wait will close the pipe after seeing the command exit, so most callers</code></span>
<span class="codeline" id="line-615"><code>// need not close the pipe themselves. It is thus incorrect to call Wait</code></span>
<span class="codeline" id="line-616"><code>// before all reads from the pipe have completed.</code></span>
<span class="codeline" id="line-617"><code>// For the same reason, it is incorrect to call Run when using StdoutPipe.</code></span>
<span class="codeline" id="line-618"><code>// See the example for idiomatic usage.</code></span>
<span class="codeline" id="line-619"><code>func (c *Cmd) StdoutPipe() (io.ReadCloser, error) {</code></span>
<span class="codeline" id="line-620"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-621"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-622"><code>	}</code></span>
<span class="codeline" id="line-623"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-624"><code>		return nil, errors.New("exec: StdoutPipe after process started")</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-627"><code>	if err != nil {</code></span>
<span class="codeline" id="line-628"><code>		return nil, err</code></span>
<span class="codeline" id="line-629"><code>	}</code></span>
<span class="codeline" id="line-630"><code>	c.Stdout = pw</code></span>
<span class="codeline" id="line-631"><code>	c.closeAfterStart = append(c.closeAfterStart, pw)</code></span>
<span class="codeline" id="line-632"><code>	c.closeAfterWait = append(c.closeAfterWait, pr)</code></span>
<span class="codeline" id="line-633"><code>	return pr, nil</code></span>
<span class="codeline" id="line-634"><code>}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>// StderrPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-637"><code>// standard error when the command starts.</code></span>
<span class="codeline" id="line-638"><code>//</code></span>
<span class="codeline" id="line-639"><code>// Wait will close the pipe after seeing the command exit, so most callers</code></span>
<span class="codeline" id="line-640"><code>// need not close the pipe themselves. It is thus incorrect to call Wait</code></span>
<span class="codeline" id="line-641"><code>// before all reads from the pipe have completed.</code></span>
<span class="codeline" id="line-642"><code>// For the same reason, it is incorrect to use Run when using StderrPipe.</code></span>
<span class="codeline" id="line-643"><code>// See the StdoutPipe example for idiomatic usage.</code></span>
<span class="codeline" id="line-644"><code>func (c *Cmd) StderrPipe() (io.ReadCloser, error) {</code></span>
<span class="codeline" id="line-645"><code>	if c.Stderr != nil {</code></span>
<span class="codeline" id="line-646"><code>		return nil, errors.New("exec: Stderr already set")</code></span>
<span class="codeline" id="line-647"><code>	}</code></span>
<span class="codeline" id="line-648"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-649"><code>		return nil, errors.New("exec: StderrPipe after process started")</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-652"><code>	if err != nil {</code></span>
<span class="codeline" id="line-653"><code>		return nil, err</code></span>
<span class="codeline" id="line-654"><code>	}</code></span>
<span class="codeline" id="line-655"><code>	c.Stderr = pw</code></span>
<span class="codeline" id="line-656"><code>	c.closeAfterStart = append(c.closeAfterStart, pw)</code></span>
<span class="codeline" id="line-657"><code>	c.closeAfterWait = append(c.closeAfterWait, pr)</code></span>
<span class="codeline" id="line-658"><code>	return pr, nil</code></span>
<span class="codeline" id="line-659"><code>}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>// prefixSuffixSaver is an io.Writer which retains the first N bytes</code></span>
<span class="codeline" id="line-662"><code>// and the last N bytes written to it. The Bytes() methods reconstructs</code></span>
<span class="codeline" id="line-663"><code>// it with a pretty error message.</code></span>
<span class="codeline" id="line-664"><code>type prefixSuffixSaver struct {</code></span>
<span class="codeline" id="line-665"><code>	N         int // max size of prefix or suffix</code></span>
<span class="codeline" id="line-666"><code>	prefix    []byte</code></span>
<span class="codeline" id="line-667"><code>	suffix    []byte // ring buffer once len(suffix) == N</code></span>
<span class="codeline" id="line-668"><code>	suffixOff int    // offset to write into suffix</code></span>
<span class="codeline" id="line-669"><code>	skipped   int64</code></span>
<span class="codeline" id="line-670"><code></code></span>
<span class="codeline" id="line-671"><code>	// TODO(bradfitz): we could keep one large []byte and use part of it for</code></span>
<span class="codeline" id="line-672"><code>	// the prefix, reserve space for the '... Omitting N bytes ...' message,</code></span>
<span class="codeline" id="line-673"><code>	// then the ring buffer suffix, and just rearrange the ring buffer</code></span>
<span class="codeline" id="line-674"><code>	// suffix when Bytes() is called, but it doesn't seem worth it for</code></span>
<span class="codeline" id="line-675"><code>	// now just for error messages. It's only ~64KB anyway.</code></span>
<span class="codeline" id="line-676"><code>}</code></span>
<span class="codeline" id="line-677"><code></code></span>
<span class="codeline" id="line-678"><code>func (w *prefixSuffixSaver) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-679"><code>	lenp := len(p)</code></span>
<span class="codeline" id="line-680"><code>	p = w.fill(&amp;w.prefix, p)</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>	// Only keep the last w.N bytes of suffix data.</code></span>
<span class="codeline" id="line-683"><code>	if overage := len(p) - w.N; overage &gt; 0 {</code></span>
<span class="codeline" id="line-684"><code>		p = p[overage:]</code></span>
<span class="codeline" id="line-685"><code>		w.skipped += int64(overage)</code></span>
<span class="codeline" id="line-686"><code>	}</code></span>
<span class="codeline" id="line-687"><code>	p = w.fill(&amp;w.suffix, p)</code></span>
<span class="codeline" id="line-688"><code></code></span>
<span class="codeline" id="line-689"><code>	// w.suffix is full now if p is non-empty. Overwrite it in a circle.</code></span>
<span class="codeline" id="line-690"><code>	for len(p) &gt; 0 { // 0, 1, or 2 iterations.</code></span>
<span class="codeline" id="line-691"><code>		n := copy(w.suffix[w.suffixOff:], p)</code></span>
<span class="codeline" id="line-692"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-693"><code>		w.skipped += int64(n)</code></span>
<span class="codeline" id="line-694"><code>		w.suffixOff += n</code></span>
<span class="codeline" id="line-695"><code>		if w.suffixOff == w.N {</code></span>
<span class="codeline" id="line-696"><code>			w.suffixOff = 0</code></span>
<span class="codeline" id="line-697"><code>		}</code></span>
<span class="codeline" id="line-698"><code>	}</code></span>
<span class="codeline" id="line-699"><code>	return lenp, nil</code></span>
<span class="codeline" id="line-700"><code>}</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>// fill appends up to len(p) bytes of p to *dst, such that *dst does not</code></span>
<span class="codeline" id="line-703"><code>// grow larger than w.N. It returns the un-appended suffix of p.</code></span>
<span class="codeline" id="line-704"><code>func (w *prefixSuffixSaver) fill(dst *[]byte, p []byte) (pRemain []byte) {</code></span>
<span class="codeline" id="line-705"><code>	if remain := w.N - len(*dst); remain &gt; 0 {</code></span>
<span class="codeline" id="line-706"><code>		add := minInt(len(p), remain)</code></span>
<span class="codeline" id="line-707"><code>		*dst = append(*dst, p[:add]...)</code></span>
<span class="codeline" id="line-708"><code>		p = p[add:]</code></span>
<span class="codeline" id="line-709"><code>	}</code></span>
<span class="codeline" id="line-710"><code>	return p</code></span>
<span class="codeline" id="line-711"><code>}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>func (w *prefixSuffixSaver) Bytes() []byte {</code></span>
<span class="codeline" id="line-714"><code>	if w.suffix == nil {</code></span>
<span class="codeline" id="line-715"><code>		return w.prefix</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code>	if w.skipped == 0 {</code></span>
<span class="codeline" id="line-718"><code>		return append(w.prefix, w.suffix...)</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-721"><code>	buf.Grow(len(w.prefix) + len(w.suffix) + 50)</code></span>
<span class="codeline" id="line-722"><code>	buf.Write(w.prefix)</code></span>
<span class="codeline" id="line-723"><code>	buf.WriteString("\n... omitting ")</code></span>
<span class="codeline" id="line-724"><code>	buf.WriteString(strconv.FormatInt(w.skipped, 10))</code></span>
<span class="codeline" id="line-725"><code>	buf.WriteString(" bytes ...\n")</code></span>
<span class="codeline" id="line-726"><code>	buf.Write(w.suffix[w.suffixOff:])</code></span>
<span class="codeline" id="line-727"><code>	buf.Write(w.suffix[:w.suffixOff])</code></span>
<span class="codeline" id="line-728"><code>	return buf.Bytes()</code></span>
<span class="codeline" id="line-729"><code>}</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>func minInt(a, b int) int {</code></span>
<span class="codeline" id="line-732"><code>	if a &lt; b {</code></span>
<span class="codeline" id="line-733"><code>		return a</code></span>
<span class="codeline" id="line-734"><code>	}</code></span>
<span class="codeline" id="line-735"><code>	return b</code></span>
<span class="codeline" id="line-736"><code>}</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>// dedupEnv returns a copy of env with any duplicates removed, in favor of</code></span>
<span class="codeline" id="line-739"><code>// later values.</code></span>
<span class="codeline" id="line-740"><code>// Items not of the normal environment "key=value" form are preserved unchanged.</code></span>
<span class="codeline" id="line-741"><code>func dedupEnv(env []string) []string {</code></span>
<span class="codeline" id="line-742"><code>	return dedupEnvCase(runtime.GOOS == "windows", env)</code></span>
<span class="codeline" id="line-743"><code>}</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>// dedupEnvCase is dedupEnv with a case option for testing.</code></span>
<span class="codeline" id="line-746"><code>// If caseInsensitive is true, the case of keys is ignored.</code></span>
<span class="codeline" id="line-747"><code>func dedupEnvCase(caseInsensitive bool, env []string) []string {</code></span>
<span class="codeline" id="line-748"><code>	out := make([]string, 0, len(env))</code></span>
<span class="codeline" id="line-749"><code>	saw := make(map[string]int, len(env)) // key =&gt; index into out</code></span>
<span class="codeline" id="line-750"><code>	for _, kv := range env {</code></span>
<span class="codeline" id="line-751"><code>		eq := strings.Index(kv, "=")</code></span>
<span class="codeline" id="line-752"><code>		if eq &lt; 0 {</code></span>
<span class="codeline" id="line-753"><code>			out = append(out, kv)</code></span>
<span class="codeline" id="line-754"><code>			continue</code></span>
<span class="codeline" id="line-755"><code>		}</code></span>
<span class="codeline" id="line-756"><code>		k := kv[:eq]</code></span>
<span class="codeline" id="line-757"><code>		if caseInsensitive {</code></span>
<span class="codeline" id="line-758"><code>			k = strings.ToLower(k)</code></span>
<span class="codeline" id="line-759"><code>		}</code></span>
<span class="codeline" id="line-760"><code>		if dupIdx, isDup := saw[k]; isDup {</code></span>
<span class="codeline" id="line-761"><code>			out[dupIdx] = kv</code></span>
<span class="codeline" id="line-762"><code>			continue</code></span>
<span class="codeline" id="line-763"><code>		}</code></span>
<span class="codeline" id="line-764"><code>		saw[k] = len(out)</code></span>
<span class="codeline" id="line-765"><code>		out = append(out, kv)</code></span>
<span class="codeline" id="line-766"><code>	}</code></span>
<span class="codeline" id="line-767"><code>	return out</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>// addCriticalEnv adds any critical environment variables that are required</code></span>
<span class="codeline" id="line-771"><code>// (or at least almost always required) on the operating system.</code></span>
<span class="codeline" id="line-772"><code>// Currently this is only used for Windows.</code></span>
<span class="codeline" id="line-773"><code>func addCriticalEnv(env []string) []string {</code></span>
<span class="codeline" id="line-774"><code>	if runtime.GOOS != "windows" {</code></span>
<span class="codeline" id="line-775"><code>		return env</code></span>
<span class="codeline" id="line-776"><code>	}</code></span>
<span class="codeline" id="line-777"><code>	for _, kv := range env {</code></span>
<span class="codeline" id="line-778"><code>		eq := strings.Index(kv, "=")</code></span>
<span class="codeline" id="line-779"><code>		if eq &lt; 0 {</code></span>
<span class="codeline" id="line-780"><code>			continue</code></span>
<span class="codeline" id="line-781"><code>		}</code></span>
<span class="codeline" id="line-782"><code>		k := kv[:eq]</code></span>
<span class="codeline" id="line-783"><code>		if strings.EqualFold(k, "SYSTEMROOT") {</code></span>
<span class="codeline" id="line-784"><code>			// We already have it.</code></span>
<span class="codeline" id="line-785"><code>			return env</code></span>
<span class="codeline" id="line-786"><code>		}</code></span>
<span class="codeline" id="line-787"><code>	}</code></span>
<span class="codeline" id="line-788"><code>	return append(env, "SYSTEMROOT="+os.Getenv("SYSTEMROOT"))</code></span>
<span class="codeline" id="line-789"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>